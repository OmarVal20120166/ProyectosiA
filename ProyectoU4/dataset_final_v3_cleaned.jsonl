{"id": "942415bc2d", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Dijkstra en la vida real?", "input": "", "output": "Google Maps lo usa para encontrar la ruta más rápida entre dos puntos. Calcula caminos más cortos como si fueran carreteras interconectadas por nodos."}
{"id": "9e131c827a", "mode": "bigtech", "instruction": "¿Cuál es la utilidad de el algoritmo de Dijkstra en la vida real?", "input": "", "output": "Google Maps lo usa para encontrar la ruta más rápida entre dos puntos. Calcula caminos más cortos como si fueran carreteras interconectadas por nodos."}
{"id": "b3a3f0dfdb", "mode": "bigtech", "instruction": "¿En qué casos se usa el algoritmo de Dijkstra en la vida real?", "input": "", "output": "Google Maps lo usa para encontrar la ruta más rápida entre dos puntos. Calcula caminos más cortos como si fueran carreteras interconectadas por nodos."}
{"id": "68611bb096", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Dijkstra en la vida real con ejemplos de código?", "input": "", "output": "Google Maps lo usa para encontrar la ruta más rápida entre dos puntos. Calcula caminos más cortos como si fueran carreteras interconectadas por nodos."}
{"id": "3b3c0e0c92", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Dijkstra en la vida real paso a paso?", "input": "", "output": "Google Maps lo usa para encontrar la ruta más rápida entre dos puntos. Calcula caminos más cortos como si fueran carreteras interconectadas por nodos."}
{"id": "50d72e7a9b", "mode": "bigtech", "instruction": "¿Para qué sirve la búsqueda binaria?", "input": "", "output": "Amazon la utiliza cuando buscas un producto entre millones. La búsqueda binaria reduce el tiempo de búsqueda a la mitad en cada paso."}
{"id": "99e7a365f4", "mode": "general", "instruction": "¿Cuál es la utilidad de la búsqueda binaria?", "input": "", "output": "Amazon la utiliza cuando buscas un producto entre millones. La búsqueda binaria reduce el tiempo de búsqueda a la mitad en cada paso."}
{"id": "8c09f87f48", "mode": "general", "instruction": "¿En qué casos se usa la búsqueda binaria?", "input": "", "output": "Amazon la utiliza cuando buscas un producto entre millones. La búsqueda binaria reduce el tiempo de búsqueda a la mitad en cada paso."}
{"id": "fe5933a2ce", "mode": "bigtech", "instruction": "¿Para qué sirve la búsqueda binaria con ejemplos de código?", "input": "", "output": "Amazon la utiliza cuando buscas un producto entre millones. La búsqueda binaria reduce el tiempo de búsqueda a la mitad en cada paso."}
{"id": "a96f7d74cf", "mode": "bigtech", "instruction": "¿Para qué sirve la búsqueda binaria paso a paso?", "input": "", "output": "Amazon la utiliza cuando buscas un producto entre millones. La búsqueda binaria reduce el tiempo de búsqueda a la mitad en cada paso."}
{"id": "81e9921a8a", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de hashing?", "input": "", "output": "Facebook usa hashing para guardar tus contraseñas de forma segura. No se guarda tu contraseña real, sino una versión irreconocible."}
{"id": "a0565ca4b5", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de hashing?", "input": "", "output": "Facebook usa hashing para guardar tus contraseñas de forma segura. No se guarda tu contraseña real, sino una versión irreconocible."}
{"id": "7fd3a46855", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de hashing?", "input": "", "output": "Facebook usa hashing para guardar tus contraseñas de forma segura. No se guarda tu contraseña real, sino una versión irreconocible."}
{"id": "e8972c7cfd", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de hashing con ejemplos de código?", "input": "", "output": "Facebook usa hashing para guardar tus contraseñas de forma segura. No se guarda tu contraseña real, sino una versión irreconocible."}
{"id": "3e5c023c4c", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de hashing paso a paso?", "input": "", "output": "Facebook usa hashing para guardar tus contraseñas de forma segura. No se guarda tu contraseña real, sino una versión irreconocible."}
{"id": "edbcb6de18", "mode": "bigtech", "instruction": "¿Para qué sirve un árbol binario de búsqueda (BST)?", "input": "", "output": "LinkedIn usa estructuras tipo BST para buscar conexiones rápidamente. Ordena usuarios por nombre, ID u otros atributos."}
{"id": "48946d5be1", "mode": "general", "instruction": "¿Cuál es la utilidad de un árbol binario de búsqueda (BST)?", "input": "", "output": "LinkedIn usa estructuras tipo BST para buscar conexiones rápidamente. Ordena usuarios por nombre, ID u otros atributos."}
{"id": "ceaec6a0ee", "mode": "general", "instruction": "¿En qué casos se usa un árbol binario de búsqueda (BST)?", "input": "", "output": "LinkedIn usa estructuras tipo BST para buscar conexiones rápidamente. Ordena usuarios por nombre, ID u otros atributos."}
{"id": "83d2310693", "mode": "bigtech", "instruction": "¿Para qué sirve un árbol binario de búsqueda (BST) con ejemplos de código?", "input": "", "output": "LinkedIn usa estructuras tipo BST para buscar conexiones rápidamente. Ordena usuarios por nombre, ID u otros atributos."}
{"id": "93419e932a", "mode": "bigtech", "instruction": "¿Para qué sirve un árbol binario de búsqueda (BST) paso a paso?", "input": "", "output": "LinkedIn usa estructuras tipo BST para buscar conexiones rápidamente. Ordena usuarios por nombre, ID u otros atributos."}
{"id": "404d481e67", "mode": "bigtech", "instruction": "¿Para qué sirve un stack (pila)?", "input": "", "output": "Microsoft Word usa stacks para el botón de deshacer (CtrlZ). Cada acción se apila, y puedes deshacerlas en orden inverso."}
{"id": "fa31c0d12d", "mode": "general", "instruction": "¿Cuál es la utilidad de un stack (pila)?", "input": "", "output": "Microsoft Word usa stacks para el botón de deshacer (CtrlZ). Cada acción se apila, y puedes deshacerlas en orden inverso."}
{"id": "913488014e", "mode": "general", "instruction": "¿En qué casos se usa un stack (pila)?", "input": "", "output": "Microsoft Word usa stacks para el botón de deshacer (CtrlZ). Cada acción se apila, y puedes deshacerlas en orden inverso."}
{"id": "4b98252391", "mode": "bigtech", "instruction": "¿Para qué sirve un stack (pila) con ejemplos de código?", "input": "", "output": "Microsoft Word usa stacks para el botón de deshacer (CtrlZ). Cada acción se apila, y puedes deshacerlas en orden inverso."}
{"id": "9cf4c2bd6f", "mode": "bigtech", "instruction": "¿Para qué sirve un stack (pila) paso a paso?", "input": "", "output": "Microsoft Word usa stacks para el botón de deshacer (CtrlZ). Cada acción se apila, y puedes deshacerlas en orden inverso."}
{"id": "8f87f15962", "mode": "bigtech", "instruction": "¿Para qué sirve un heap (montículo)?", "input": "", "output": "Netflix usa heaps para priorizar contenidos en cola, como mostrarte las recomendaciones más relevantes primero."}
{"id": "a2a3a1f134", "mode": "general", "instruction": "¿Cuál es la utilidad de un heap (montículo)?", "input": "", "output": "Netflix usa heaps para priorizar contenidos en cola, como mostrarte las recomendaciones más relevantes primero."}
{"id": "d7b3c2e6ed", "mode": "general", "instruction": "¿En qué casos se usa un heap (montículo)?", "input": "", "output": "Netflix usa heaps para priorizar contenidos en cola, como mostrarte las recomendaciones más relevantes primero."}
{"id": "9f510e6cee", "mode": "bigtech", "instruction": "¿Para qué sirve un heap (montículo) con ejemplos de código?", "input": "", "output": "Netflix usa heaps para priorizar contenidos en cola, como mostrarte las recomendaciones más relevantes primero."}
{"id": "f3cced967c", "mode": "bigtech", "instruction": "¿Para qué sirve un heap (montículo) paso a paso?", "input": "", "output": "Netflix usa heaps para priorizar contenidos en cola, como mostrarte las recomendaciones más relevantes primero."}
{"id": "836f904f73", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de K-Means?", "input": "", "output": "Spotify lo usa para agrupar canciones similares y crear playlists personalizadas según tus gustos."}
{"id": "0d565e9f88", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de K-Means?", "input": "", "output": "Spotify lo usa para agrupar canciones similares y crear playlists personalizadas según tus gustos."}
{"id": "bb3d0a79b3", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de K-Means?", "input": "", "output": "Spotify lo usa para agrupar canciones similares y crear playlists personalizadas según tus gustos."}
{"id": "30f00e20a8", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de K-Means con ejemplos de código?", "input": "", "output": "Spotify lo usa para agrupar canciones similares y crear playlists personalizadas según tus gustos."}
{"id": "545d2d46ee", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de K-Means paso a paso?", "input": "", "output": "Spotify lo usa para agrupar canciones similares y crear playlists personalizadas según tus gustos."}
{"id": "cfe9f9adac", "mode": "bigtech", "instruction": "¿Para qué sirven los grafos en redes sociales?", "input": "", "output": "Instagram modela tus amigos y seguidores como grafos. Así puede sugerirte a quién seguir o con quién te relacionas más."}
{"id": "8364f81f4d", "mode": "general", "instruction": "¿Cuál es la utilidad de n los grafos en redes sociales?", "input": "", "output": "Instagram modela tus amigos y seguidores como grafos. Así puede sugerirte a quién seguir o con quién te relacionas más."}
{"id": "83ac88439b", "mode": "general", "instruction": "¿En qué casos se usa n los grafos en redes sociales?", "input": "", "output": "Instagram modela tus amigos y seguidores como grafos. Así puede sugerirte a quién seguir o con quién te relacionas más."}
{"id": "41f254f397", "mode": "bigtech", "instruction": "¿Para qué sirven los grafos en redes sociales con ejemplos de código?", "input": "", "output": "Instagram modela tus amigos y seguidores como grafos. Así puede sugerirte a quién seguir o con quién te relacionas más."}
{"id": "1280e4fa1f", "mode": "bigtech", "instruction": "¿Para qué sirven los grafos en redes sociales paso a paso?", "input": "", "output": "Instagram modela tus amigos y seguidores como grafos. Así puede sugerirte a quién seguir o con quién te relacionas más."}
{"id": "0163c5597e", "mode": "bigtech", "instruction": "¿Para qué sirve un Trie?", "input": "", "output": "Google lo usa para autocompletar tus búsquedas en tiempo real. Cada letra que escribes navega por el Trie."}
{"id": "d02de7e9d1", "mode": "general", "instruction": "¿Cuál es la utilidad de un Trie?", "input": "", "output": "Google lo usa para autocompletar tus búsquedas en tiempo real. Cada letra que escribes navega por el Trie."}
{"id": "7555683938", "mode": "general", "instruction": "¿En qué casos se usa un Trie?", "input": "", "output": "Google lo usa para autocompletar tus búsquedas en tiempo real. Cada letra que escribes navega por el Trie."}
{"id": "031c19baf7", "mode": "bigtech", "instruction": "¿Para qué sirve un Trie con ejemplos de código?", "input": "", "output": "Google lo usa para autocompletar tus búsquedas en tiempo real. Cada letra que escribes navega por el Trie."}
{"id": "a35ca578d6", "mode": "bigtech", "instruction": "¿Para qué sirve un Trie paso a paso?", "input": "", "output": "Google lo usa para autocompletar tus búsquedas en tiempo real. Cada letra que escribes navega por el Trie."}
{"id": "2e60f80f9c", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de backtracking?", "input": "", "output": "Airbnb lo usa para encontrar combinaciones viables de filtros cuando buscas alojamiento. Prueba rutas y retrocede si algo no encaja."}
{"id": "784bfb80af", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de backtracking?", "input": "", "output": "Airbnb lo usa para encontrar combinaciones viables de filtros cuando buscas alojamiento. Prueba rutas y retrocede si algo no encaja."}
{"id": "a34265d40f", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de backtracking?", "input": "", "output": "Airbnb lo usa para encontrar combinaciones viables de filtros cuando buscas alojamiento. Prueba rutas y retrocede si algo no encaja."}
{"id": "2c93755b18", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de backtracking con ejemplos de código?", "input": "", "output": "Airbnb lo usa para encontrar combinaciones viables de filtros cuando buscas alojamiento. Prueba rutas y retrocede si algo no encaja."}
{"id": "57a3ca9840", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de backtracking paso a paso?", "input": "", "output": "Airbnb lo usa para encontrar combinaciones viables de filtros cuando buscas alojamiento. Prueba rutas y retrocede si algo no encaja."}
{"id": "def9066d0b", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Floyd-Warshall?", "input": "", "output": "las aerolíneas lo usan para calcular rutas mínimas entre todas las ciudades a la vez y ajustar conexiones. Optimiza tiempos y costos en redes densas."}
{"id": "602f251201", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de Floyd-Warshall?", "input": "", "output": "las aerolíneas lo usan para calcular rutas mínimas entre todas las ciudades a la vez y ajustar conexiones. Optimiza tiempos y costos en redes densas."}
{"id": "db2a8ef870", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de Floyd-Warshall?", "input": "", "output": "las aerolíneas lo usan para calcular rutas mínimas entre todas las ciudades a la vez y ajustar conexiones. Optimiza tiempos y costos en redes densas."}
{"id": "5db5bf43f4", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Floyd-Warshall con ejemplos de código?", "input": "", "output": "las aerolíneas lo usan para calcular rutas mínimas entre todas las ciudades a la vez y ajustar conexiones. Optimiza tiempos y costos en redes densas."}
{"id": "6bdccfc30a", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Floyd-Warshall paso a paso?", "input": "", "output": "las aerolíneas lo usan para calcular rutas mínimas entre todas las ciudades a la vez y ajustar conexiones. Optimiza tiempos y costos en redes densas."}
{"id": "a0603468a5", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Prim?", "input": "", "output": "las compañías eléctricas lo usan para tender cableado minimizando el costo total sin dejar casas desconectadas. Construye un árbol de menor costo."}
{"id": "1e37aede0b", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de Prim?", "input": "", "output": "las compañías eléctricas lo usan para tender cableado minimizando el costo total sin dejar casas desconectadas. Construye un árbol de menor costo."}
{"id": "acc27989a9", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de Prim?", "input": "", "output": "las compañías eléctricas lo usan para tender cableado minimizando el costo total sin dejar casas desconectadas. Construye un árbol de menor costo."}
{"id": "38ba09cdee", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Prim con ejemplos de código?", "input": "", "output": "las compañías eléctricas lo usan para tender cableado minimizando el costo total sin dejar casas desconectadas. Construye un árbol de menor costo."}
{"id": "ec93fd637f", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Prim paso a paso?", "input": "", "output": "las compañías eléctricas lo usan para tender cableado minimizando el costo total sin dejar casas desconectadas. Construye un árbol de menor costo."}
{"id": "40fa301070", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Kruskal?", "input": "", "output": "las empresas de internet lo aplican para diseñar redes de fibra baratas conectando ciudades con el costo mínimo. Ordena aristas y arma el MST."}
{"id": "270f8882c2", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de Kruskal?", "input": "", "output": "las empresas de internet lo aplican para diseñar redes de fibra baratas conectando ciudades con el costo mínimo. Ordena aristas y arma el MST."}
{"id": "6cb53a97f3", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de Kruskal?", "input": "", "output": "las empresas de internet lo aplican para diseñar redes de fibra baratas conectando ciudades con el costo mínimo. Ordena aristas y arma el MST."}
{"id": "54bce05e8f", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Kruskal con ejemplos de código?", "input": "", "output": "las empresas de internet lo aplican para diseñar redes de fibra baratas conectando ciudades con el costo mínimo. Ordena aristas y arma el MST."}
{"id": "4b5c301e80", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Kruskal paso a paso?", "input": "", "output": "las empresas de internet lo aplican para diseñar redes de fibra baratas conectando ciudades con el costo mínimo. Ordena aristas y arma el MST."}
{"id": "55a20adb36", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo A* (A estrella)?", "input": "", "output": "los videojuegos lo usan para que los NPC encuentren el camino más corto sin atascarse. Combina costo recorrido heurística para moverse rápido."}
{"id": "87604e3498", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo A* (A estrella)?", "input": "", "output": "los videojuegos lo usan para que los NPC encuentren el camino más corto sin atascarse. Combina costo recorrido heurística para moverse rápido."}
{"id": "f3d19a137d", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo A* (A estrella)?", "input": "", "output": "los videojuegos lo usan para que los NPC encuentren el camino más corto sin atascarse. Combina costo recorrido heurística para moverse rápido."}
{"id": "a75c916bb6", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo A* (A estrella) con ejemplos de código?", "input": "", "output": "los videojuegos lo usan para que los NPC encuentren el camino más corto sin atascarse. Combina costo recorrido heurística para moverse rápido."}
{"id": "d0f2e9d90b", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo A* (A estrella) paso a paso?", "input": "", "output": "los videojuegos lo usan para que los NPC encuentren el camino más corto sin atascarse. Combina costo recorrido heurística para moverse rápido."}
{"id": "ae9c7d0966", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Bellman-Ford?", "input": "", "output": "en telecomunicaciones se usa cuando hay enlaces con costos variables o negativos, detecta ciclos malos y aun así encuentra rutas más baratas."}
{"id": "c94a40d2ed", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de Bellman-Ford?", "input": "", "output": "en telecomunicaciones se usa cuando hay enlaces con costos variables o negativos, detecta ciclos malos y aun así encuentra rutas más baratas."}
{"id": "fd66c026f3", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de Bellman-Ford?", "input": "", "output": "en telecomunicaciones se usa cuando hay enlaces con costos variables o negativos, detecta ciclos malos y aun así encuentra rutas más baratas."}
{"id": "80c8354e23", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Bellman-Ford con ejemplos de código?", "input": "", "output": "en telecomunicaciones se usa cuando hay enlaces con costos variables o negativos, detecta ciclos malos y aun así encuentra rutas más baratas."}
{"id": "b990bd6b97", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Bellman-Ford paso a paso?", "input": "", "output": "en telecomunicaciones se usa cuando hay enlaces con costos variables o negativos, detecta ciclos malos y aun así encuentra rutas más baratas."}
{"id": "d504a19e9b", "mode": "bigtech", "instruction": "¿Para qué sirve la programación dinámica (ejemplo knapsack)?", "input": "", "output": "en logística se usa para cargar camiones maximizando valor sin pasarse de peso. Divide en subproblemas y rellena tablas para decidir qué llevar."}
{"id": "951c80b76b", "mode": "general", "instruction": "¿Cuál es la utilidad de la programación dinámica (ejemplo knapsack)?", "input": "", "output": "en logística se usa para cargar camiones maximizando valor sin pasarse de peso. Divide en subproblemas y rellena tablas para decidir qué llevar."}
{"id": "299b2aa4da", "mode": "general", "instruction": "¿En qué casos se usa la programación dinámica (ejemplo knapsack)?", "input": "", "output": "en logística se usa para cargar camiones maximizando valor sin pasarse de peso. Divide en subproblemas y rellena tablas para decidir qué llevar."}
{"id": "398d3cb0ee", "mode": "bigtech", "instruction": "¿Para qué sirve la programación dinámica (ejemplo knapsack) paso a paso?", "input": "", "output": "en logística se usa para cargar camiones maximizando valor sin pasarse de peso. Divide en subproblemas y rellena tablas para decidir qué llevar."}
{"id": "8c3175af97", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Union-Find (DSU)?", "input": "", "output": "en redes sociales se usa para saber rápidamente si dos usuarios están conectados en la misma comunidad. Une conjuntos y comprueba conectividad en casi O(1)."}
{"id": "c1623f37e9", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de Union-Find (DSU)?", "input": "", "output": "en redes sociales se usa para saber rápidamente si dos usuarios están conectados en la misma comunidad. Une conjuntos y comprueba conectividad en casi O(1)."}
{"id": "5371498f52", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de Union-Find (DSU)?", "input": "", "output": "en redes sociales se usa para saber rápidamente si dos usuarios están conectados en la misma comunidad. Une conjuntos y comprueba conectividad en casi O(1)."}
{"id": "191253ea68", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Union-Find (DSU) con ejemplos de código?", "input": "", "output": "en redes sociales se usa para saber rápidamente si dos usuarios están conectados en la misma comunidad. Une conjuntos y comprueba conectividad en casi O(1)."}
{"id": "250102d6a8", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de Union-Find (DSU) paso a paso?", "input": "", "output": "en redes sociales se usa para saber rápidamente si dos usuarios están conectados en la misma comunidad. Une conjuntos y comprueba conectividad en casi O(1)."}
{"id": "8af766d71f", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de ordenamiento rápido (Quicksort)?", "input": "", "output": "bases de datos y tiendas online lo usan para ordenar millones de registros rápido antes de mostrarlos. Parte y conquista con pivotes para ordenar en promedio O(n log n)."}
{"id": "5c0d1ee5cf", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de ordenamiento rápido (Quicksort)?", "input": "", "output": "bases de datos y tiendas online lo usan para ordenar millones de registros rápido antes de mostrarlos. Parte y conquista con pivotes para ordenar en promedio O(n log n)."}
{"id": "edfee4aedb", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de ordenamiento rápido (Quicksort)?", "input": "", "output": "bases de datos y tiendas online lo usan para ordenar millones de registros rápido antes de mostrarlos. Parte y conquista con pivotes para ordenar en promedio O(n log n)."}
{"id": "951df05a8c", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de ordenamiento rápido (Quicksort) con ejemplos de código?", "input": "", "output": "bases de datos y tiendas online lo usan para ordenar millones de registros rápido antes de mostrarlos. Parte y conquista con pivotes para ordenar en promedio O(n log n)."}
{"id": "e321fdee01", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de ordenamiento rápido (Quicksort) paso a paso?", "input": "", "output": "bases de datos y tiendas online lo usan para ordenar millones de registros rápido antes de mostrarlos. Parte y conquista con pivotes para ordenar en promedio O(n log n)."}
{"id": "eb31602f5f", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de ordenamiento por mezcla (Mergesort)?", "input": "", "output": "cuando los datos no caben en RAM, Mergesort permite ordenar en disco divide, ordena trozos y luego mezcla de forma estable. Ideal para archivos enormes."}
{"id": "bbb5490b19", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de ordenamiento por mezcla (Mergesort)?", "input": "", "output": "cuando los datos no caben en RAM, Mergesort permite ordenar en disco divide, ordena trozos y luego mezcla de forma estable. Ideal para archivos enormes."}
{"id": "e3f378d002", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de ordenamiento por mezcla (Mergesort)?", "input": "", "output": "cuando los datos no caben en RAM, Mergesort permite ordenar en disco divide, ordena trozos y luego mezcla de forma estable. Ideal para archivos enormes."}
{"id": "cf24f4e8c0", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de ordenamiento por mezcla (Mergesort) con ejemplos de código?", "input": "", "output": "cuando los datos no caben en RAM, Mergesort permite ordenar en disco divide, ordena trozos y luego mezcla de forma estable. Ideal para archivos enormes."}
{"id": "cbeb7dbba7", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de ordenamiento por mezcla (Mergesort) paso a paso?", "input": "", "output": "cuando los datos no caben en RAM, Mergesort permite ordenar en disco divide, ordena trozos y luego mezcla de forma estable. Ideal para archivos enormes."}
{"id": "41d48222ba", "mode": "bigtech", "instruction": "¿Para qué sirve el método de Monte Carlo?", "input": "", "output": "los bancos lo usan para simular riesgos financieros generando miles de escenarios aleatorios y estimar pérdidas probables. Simulación estadísticas."}
{"id": "5fd4a647b8", "mode": "general", "instruction": "¿Cuál es la utilidad de el método de Monte Carlo?", "input": "", "output": "los bancos lo usan para simular riesgos financieros generando miles de escenarios aleatorios y estimar pérdidas probables. Simulación estadísticas."}
{"id": "3fd40a7bf6", "mode": "general", "instruction": "¿En qué casos se usa el método de Monte Carlo?", "input": "", "output": "los bancos lo usan para simular riesgos financieros generando miles de escenarios aleatorios y estimar pérdidas probables. Simulación estadísticas."}
{"id": "d96ea37b9b", "mode": "bigtech", "instruction": "¿Para qué sirve el método de Monte Carlo con ejemplos de código?", "input": "", "output": "los bancos lo usan para simular riesgos financieros generando miles de escenarios aleatorios y estimar pérdidas probables. Simulación estadísticas."}
{"id": "132052ef16", "mode": "bigtech", "instruction": "¿Para qué sirve el método de Monte Carlo paso a paso?", "input": "", "output": "los bancos lo usan para simular riesgos financieros generando miles de escenarios aleatorios y estimar pérdidas probables. Simulación estadísticas."}
{"id": "dd7543a773", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo PageRank?", "input": "", "output": "Google lo popularizó para ordenar páginas según cuántas otras las referencian. Es un ranking por importancia en el grafo de la web."}
{"id": "ff8f2fb0da", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo PageRank?", "input": "", "output": "Google lo popularizó para ordenar páginas según cuántas otras las referencian. Es un ranking por importancia en el grafo de la web."}
{"id": "a8a247781a", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo PageRank?", "input": "", "output": "Google lo popularizó para ordenar páginas según cuántas otras las referencian. Es un ranking por importancia en el grafo de la web."}
{"id": "d0e9eaff1a", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo PageRank con ejemplos de código?", "input": "", "output": "Google lo popularizó para ordenar páginas según cuántas otras las referencian. Es un ranking por importancia en el grafo de la web."}
{"id": "92ffce18cf", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo PageRank paso a paso?", "input": "", "output": "Google lo popularizó para ordenar páginas según cuántas otras las referencian. Es un ranking por importancia en el grafo de la web."}
{"id": "e8d6f490c0", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de KMP (Knuth–Morris–Pratt)?", "input": "", "output": "editores de texto y buscadores lo usan para encontrar patrones en documentos sin reescanear todo. Reutiliza información de prefijos para buscar más rápido."}
{"id": "8030d6f8fc", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de KMP (Knuth–Morris–Pratt)?", "input": "", "output": "editores de texto y buscadores lo usan para encontrar patrones en documentos sin reescanear todo. Reutiliza información de prefijos para buscar más rápido."}
{"id": "e458758041", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de KMP (Knuth–Morris–Pratt)?", "input": "", "output": "editores de texto y buscadores lo usan para encontrar patrones en documentos sin reescanear todo. Reutiliza información de prefijos para buscar más rápido."}
{"id": "b10619f72d", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de KMP (Knuth–Morris–Pratt) con ejemplos de código?", "input": "", "output": "editores de texto y buscadores lo usan para encontrar patrones en documentos sin reescanear todo. Reutiliza información de prefijos para buscar más rápido."}
{"id": "bb8a48609c", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de KMP (Knuth–Morris–Pratt) paso a paso?", "input": "", "output": "editores de texto y buscadores lo usan para encontrar patrones en documentos sin reescanear todo. Reutiliza información de prefijos para buscar más rápido."}
{"id": "02f660450d", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de ventanas deslizantes?", "input": "", "output": "en streaming de datos se usa para calcular métricas en tiempo real (promedios, máximos) sobre los últimos N elementos sin recalcular todo."}
{"id": "3431eb11a0", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de ventanas deslizantes?", "input": "", "output": "en streaming de datos se usa para calcular métricas en tiempo real (promedios, máximos) sobre los últimos N elementos sin recalcular todo."}
{"id": "765fee829c", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de ventanas deslizantes?", "input": "", "output": "en streaming de datos se usa para calcular métricas en tiempo real (promedios, máximos) sobre los últimos N elementos sin recalcular todo."}
{"id": "bc78464bc3", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de ventanas deslizantes con ejemplos de código?", "input": "", "output": "en streaming de datos se usa para calcular métricas en tiempo real (promedios, máximos) sobre los últimos N elementos sin recalcular todo."}
{"id": "d5612b46a5", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de ventanas deslizantes paso a paso?", "input": "", "output": "en streaming de datos se usa para calcular métricas en tiempo real (promedios, máximos) sobre los últimos N elementos sin recalcular todo."}
{"id": "19879a2621", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de compresión Huffman?", "input": "", "output": "formatos como ZIP o imágenes lo usan para comprimir asignando códigos cortos a símbolos frecuentes. Ahorra espacio sin perder información."}
{"id": "876a3b1026", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de compresión Huffman?", "input": "", "output": "formatos como ZIP o imágenes lo usan para comprimir asignando códigos cortos a símbolos frecuentes. Ahorra espacio sin perder información."}
{"id": "9f610b396f", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de compresión Huffman?", "input": "", "output": "formatos como ZIP o imágenes lo usan para comprimir asignando códigos cortos a símbolos frecuentes. Ahorra espacio sin perder información."}
{"id": "c857f2acb4", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de compresión Huffman con ejemplos de código?", "input": "", "output": "formatos como ZIP o imágenes lo usan para comprimir asignando códigos cortos a símbolos frecuentes. Ahorra espacio sin perder información."}
{"id": "a03de97491", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de compresión Huffman paso a paso?", "input": "", "output": "formatos como ZIP o imágenes lo usan para comprimir asignando códigos cortos a símbolos frecuentes. Ahorra espacio sin perder información."}
{"id": "bd0a7310f9", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de detección de componentes fuertemente conexas (Kosaraju/Tarjan)?", "input": "", "output": "en análisis de dependencias de software se usa para detectar ciclos entre módulos. Encuentra subgrafos donde cada nodo alcanza a los demás."}
{"id": "9e77345b9a", "mode": "general", "instruction": "¿Cuál es la utilidad de el algoritmo de detección de componentes fuertemente conexas (Kosaraju/Tarjan)?", "input": "", "output": "en análisis de dependencias de software se usa para detectar ciclos entre módulos. Encuentra subgrafos donde cada nodo alcanza a los demás."}
{"id": "7282026771", "mode": "general", "instruction": "¿En qué casos se usa el algoritmo de detección de componentes fuertemente conexas (Kosaraju/Tarjan)?", "input": "", "output": "en análisis de dependencias de software se usa para detectar ciclos entre módulos. Encuentra subgrafos donde cada nodo alcanza a los demás."}
{"id": "5760c9bf47", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de detección de componentes fuertemente conexas (Kosaraju/Tarjan) con ejemplos de código?", "input": "", "output": "en análisis de dependencias de software se usa para detectar ciclos entre módulos. Encuentra subgrafos donde cada nodo alcanza a los demás."}
{"id": "3c46524375", "mode": "bigtech", "instruction": "¿Para qué sirve el algoritmo de detección de componentes fuertemente conexas (Kosaraju/Tarjan) paso a paso?", "input": "", "output": "en análisis de dependencias de software se usa para detectar ciclos entre módulos. Encuentra subgrafos donde cada nodo alcanza a los demás."}
{"id": "2bbf91f889", "mode": "general", "instruction": "¿Qué es un algoritmo?", "input": "", "output": "Imagina que vas a preparar un sándwich. Primero tomas el pan, luego agregas jamón, después queso, y finalmente cierras con otro pan. ¡Eso es un algoritmo! Una serie de pasos ordenados para lograr un objetivo. En programación, un algoritmo es simplemente la receta para resolver un problema."}
{"id": "12a53f038a", "mode": "general", "instruction": "Define qué significa un algoritmo?", "input": "", "output": "Imagina que vas a preparar un sándwich. Primero tomas el pan, luego agregas jamón, después queso, y finalmente cierras con otro pan. ¡Eso es un algoritmo! Una serie de pasos ordenados para lograr un objetivo. En programación, un algoritmo es simplemente la receta para resolver un problema."}
{"id": "8678faa155", "mode": "general", "instruction": "Explícame el concepto de un algoritmo?", "input": "", "output": "Imagina que vas a preparar un sándwich. Primero tomas el pan, luego agregas jamón, después queso, y finalmente cierras con otro pan. ¡Eso es un algoritmo! Una serie de pasos ordenados para lograr un objetivo. En programación, un algoritmo es simplemente la receta para resolver un problema."}
{"id": "e52840d4b2", "mode": "general", "instruction": "¿Qué es un algoritmo con ejemplos de código?", "input": "", "output": "Imagina que vas a preparar un sándwich. Primero tomas el pan, luego agregas jamón, después queso, y finalmente cierras con otro pan. ¡Eso es un algoritmo! Una serie de pasos ordenados para lograr un objetivo. En programación, un algoritmo es simplemente la receta para resolver un problema."}
{"id": "8c82eac0df", "mode": "general", "instruction": "¿Qué es un algoritmo paso a paso?", "input": "", "output": "Imagina que vas a preparar un sándwich. Primero tomas el pan, luego agregas jamón, después queso, y finalmente cierras con otro pan. ¡Eso es un algoritmo! Una serie de pasos ordenados para lograr un objetivo. En programación, un algoritmo es simplemente la receta para resolver un problema."}
{"id": "bbfc655044", "mode": "general", "instruction": "¿Qué es una variable?", "input": "", "output": "Piensa en una variable como una cajita con una etiqueta. Puedes ponerle dentro una manzana, un número, un nombre ¡lo que necesites! Luego puedes abrirla, cambiar su contenido, o usar lo que tiene dentro. Es una forma de guardar información para usarla más adelante."}
{"id": "f07a0a6ed8", "mode": "general", "instruction": "Define qué significa una variable?", "input": "", "output": "Piensa en una variable como una cajita con una etiqueta. Puedes ponerle dentro una manzana, un número, un nombre ¡lo que necesites! Luego puedes abrirla, cambiar su contenido, o usar lo que tiene dentro. Es una forma de guardar información para usarla más adelante."}
{"id": "ac94058598", "mode": "general", "instruction": "Explícame el concepto de una variable?", "input": "", "output": "Piensa en una variable como una cajita con una etiqueta. Puedes ponerle dentro una manzana, un número, un nombre ¡lo que necesites! Luego puedes abrirla, cambiar su contenido, o usar lo que tiene dentro. Es una forma de guardar información para usarla más adelante."}
{"id": "17b26f5b30", "mode": "general", "instruction": "¿Qué es una variable con ejemplos de código?", "input": "", "output": "Piensa en una variable como una cajita con una etiqueta. Puedes ponerle dentro una manzana, un número, un nombre ¡lo que necesites! Luego puedes abrirla, cambiar su contenido, o usar lo que tiene dentro. Es una forma de guardar información para usarla más adelante."}
{"id": "e31e02ed7b", "mode": "general", "instruction": "¿Qué es una variable paso a paso?", "input": "", "output": "Piensa en una variable como una cajita con una etiqueta. Puedes ponerle dentro una manzana, un número, un nombre ¡lo que necesites! Luego puedes abrirla, cambiar su contenido, o usar lo que tiene dentro. Es una forma de guardar información para usarla más adelante."}
{"id": "af687c4203", "mode": "general", "instruction": "Explica el concepto de recursividad de forma sencilla", "input": "", "output": "La recursividad es como una muñeca rusa cuando la abres, hay otra igual adentro, y luego otra, y otra... hasta que llegas a la más pequeña que ya no se abre. En programación, una función recursiva se llama a sí misma, pero siempre debe haber una muñeca final que detiene todo. ¡Es como decir repítelo hasta que sea tan simple que ya no se pueda dividir más!"}
{"id": "668dc852c8", "mode": "general", "instruction": "Dame una explicación sobre el concepto de recursividad de forma sencilla", "input": "", "output": "La recursividad es como una muñeca rusa cuando la abres, hay otra igual adentro, y luego otra, y otra... hasta que llegas a la más pequeña que ya no se abre. En programación, una función recursiva se llama a sí misma, pero siempre debe haber una muñeca final que detiene todo. ¡Es como decir repítelo hasta que sea tan simple que ya no se pueda dividir más!"}
{"id": "861607d705", "mode": "general", "instruction": "Ayúdame a entender el concepto de recursividad de forma sencilla", "input": "", "output": "La recursividad es como una muñeca rusa cuando la abres, hay otra igual adentro, y luego otra, y otra... hasta que llegas a la más pequeña que ya no se abre. En programación, una función recursiva se llama a sí misma, pero siempre debe haber una muñeca final que detiene todo. ¡Es como decir repítelo hasta que sea tan simple que ya no se pueda dividir más!"}
{"id": "e1ace35d90", "mode": "general", "instruction": "Explica el concepto de recursividad de forma sencilla con ejemplos de código?", "input": "", "output": "La recursividad es como una muñeca rusa cuando la abres, hay otra igual adentro, y luego otra, y otra... hasta que llegas a la más pequeña que ya no se abre. En programación, una función recursiva se llama a sí misma, pero siempre debe haber una muñeca final que detiene todo. ¡Es como decir repítelo hasta que sea tan simple que ya no se pueda dividir más!"}
{"id": "72535f5cb5", "mode": "general", "instruction": "Explica el concepto de recursividad de forma sencilla paso a paso?", "input": "", "output": "La recursividad es como una muñeca rusa cuando la abres, hay otra igual adentro, y luego otra, y otra... hasta que llegas a la más pequeña que ya no se abre. En programación, una función recursiva se llama a sí misma, pero siempre debe haber una muñeca final que detiene todo. ¡Es como decir repítelo hasta que sea tan simple que ya no se pueda dividir más!"}
{"id": "7b34cb906f", "mode": "general", "instruction": "¿Qué es el factorial y cómo se calcula con recursividad?", "input": "¿Me puedes dar una explicación fácil?", "output": "Imagina que tienes que apilar platos el factorial de 4 (escrito 4!) es como decir 4 platos, debajo uno de 3, luego uno de 2, y al final uno de 1. Cada plato se apoya en el de abajo. Con recursividad, hacemos que la función se apile una y otra vez hasta llegar al 1. Así 4! 4 3 2 1. Cuando llegamos al 1, ¡dejamos de apilar!"}
{"id": "2e8dda1d67", "mode": "general", "instruction": "Define qué significa el factorial y cómo se calcula con recursividad?", "input": "¿Me puedes dar una explicación fácil?", "output": "Imagina que tienes que apilar platos el factorial de 4 (escrito 4!) es como decir 4 platos, debajo uno de 3, luego uno de 2, y al final uno de 1. Cada plato se apoya en el de abajo. Con recursividad, hacemos que la función se apile una y otra vez hasta llegar al 1. Así 4! 4 3 2 1. Cuando llegamos al 1, ¡dejamos de apilar!"}
{"id": "e869f0e194", "mode": "general", "instruction": "Explícame el concepto de el factorial y cómo se calcula con recursividad?", "input": "¿Me puedes dar una explicación fácil?", "output": "Imagina que tienes que apilar platos el factorial de 4 (escrito 4!) es como decir 4 platos, debajo uno de 3, luego uno de 2, y al final uno de 1. Cada plato se apoya en el de abajo. Con recursividad, hacemos que la función se apile una y otra vez hasta llegar al 1. Así 4! 4 3 2 1. Cuando llegamos al 1, ¡dejamos de apilar!"}
{"id": "d397d6cc51", "mode": "general", "instruction": "¿Qué es el factorial y cómo se calcula con recursividad con ejemplos de código?", "input": "¿Me puedes dar una explicación fácil?", "output": "Imagina que tienes que apilar platos el factorial de 4 (escrito 4!) es como decir 4 platos, debajo uno de 3, luego uno de 2, y al final uno de 1. Cada plato se apoya en el de abajo. Con recursividad, hacemos que la función se apile una y otra vez hasta llegar al 1. Así 4! 4 3 2 1. Cuando llegamos al 1, ¡dejamos de apilar!"}
{"id": "3c1025d425", "mode": "general", "instruction": "¿Qué es el factorial y cómo se calcula con recursividad paso a paso?", "input": "¿Me puedes dar una explicación fácil?", "output": "Imagina que tienes que apilar platos el factorial de 4 (escrito 4!) es como decir 4 platos, debajo uno de 3, luego uno de 2, y al final uno de 1. Cada plato se apoya en el de abajo. Con recursividad, hacemos que la función se apile una y otra vez hasta llegar al 1. Así 4! 4 3 2 1. Cuando llegamos al 1, ¡dejamos de apilar!"}
{"id": "719785f8e4", "mode": "general", "instruction": "¿Qué es Fibonacci con recursividad?", "input": "", "output": "La secuencia de Fibonacci es como criar conejos. Empiezas con una pareja. Cada mes, esa pareja produce una nueva, y las nuevas también empezarán a producir después de un tiempo. Así, los conejos se multiplican como 1, 1, 2, 3, 5, 8... En recursividad, cada número se calcula sumando los dos anteriores. ¡Solo recuerda que empieza con 1 y 1!"}
{"id": "e2c2546b34", "mode": "general", "instruction": "Define qué significa Fibonacci con recursividad?", "input": "", "output": "La secuencia de Fibonacci es como criar conejos. Empiezas con una pareja. Cada mes, esa pareja produce una nueva, y las nuevas también empezarán a producir después de un tiempo. Así, los conejos se multiplican como 1, 1, 2, 3, 5, 8... En recursividad, cada número se calcula sumando los dos anteriores. ¡Solo recuerda que empieza con 1 y 1!"}
{"id": "93fcbcd373", "mode": "general", "instruction": "Explícame el concepto de Fibonacci con recursividad?", "input": "", "output": "La secuencia de Fibonacci es como criar conejos. Empiezas con una pareja. Cada mes, esa pareja produce una nueva, y las nuevas también empezarán a producir después de un tiempo. Así, los conejos se multiplican como 1, 1, 2, 3, 5, 8... En recursividad, cada número se calcula sumando los dos anteriores. ¡Solo recuerda que empieza con 1 y 1!"}
{"id": "9c33bfa1ae", "mode": "general", "instruction": "¿Qué es Fibonacci con recursividad con ejemplos de código?", "input": "", "output": "La secuencia de Fibonacci es como criar conejos. Empiezas con una pareja. Cada mes, esa pareja produce una nueva, y las nuevas también empezarán a producir después de un tiempo. Así, los conejos se multiplican como 1, 1, 2, 3, 5, 8... En recursividad, cada número se calcula sumando los dos anteriores. ¡Solo recuerda que empieza con 1 y 1!"}
{"id": "eea8e3e47f", "mode": "general", "instruction": "¿Qué es Fibonacci con recursividad paso a paso?", "input": "", "output": "La secuencia de Fibonacci es como criar conejos. Empiezas con una pareja. Cada mes, esa pareja produce una nueva, y las nuevas también empezarán a producir después de un tiempo. Así, los conejos se multiplican como 1, 1, 2, 3, 5, 8... En recursividad, cada número se calcula sumando los dos anteriores. ¡Solo recuerda que empieza con 1 y 1!"}
{"id": "9228f498bb", "mode": "bigtech", "instruction": "¿Para qué sirve un bucle en programación?", "input": "", "output": "Un bucle es como cuando saltas la cuerda 10 veces. En vez de decirle a alguien salta, salta, salta... diez veces, dices salta 10 veces. En programación, un bucle te permite repetir instrucciones sin tener que escribirlas una por una. ¡Es súper útil para no hacer trabajo repetitivo!"}
{"id": "3e694e28ee", "mode": "general", "instruction": "¿Cuál es la utilidad de un bucle en programación?", "input": "", "output": "Un bucle es como cuando saltas la cuerda 10 veces. En vez de decirle a alguien salta, salta, salta... diez veces, dices salta 10 veces. En programación, un bucle te permite repetir instrucciones sin tener que escribirlas una por una. ¡Es súper útil para no hacer trabajo repetitivo!"}
{"id": "43cf645a43", "mode": "general", "instruction": "¿En qué casos se usa un bucle en programación?", "input": "", "output": "Un bucle es como cuando saltas la cuerda 10 veces. En vez de decirle a alguien salta, salta, salta... diez veces, dices salta 10 veces. En programación, un bucle te permite repetir instrucciones sin tener que escribirlas una por una. ¡Es súper útil para no hacer trabajo repetitivo!"}
{"id": "18d7d0ae6f", "mode": "bigtech", "instruction": "¿Para qué sirve un bucle en programación con ejemplos de código?", "input": "", "output": "Un bucle es como cuando saltas la cuerda 10 veces. En vez de decirle a alguien salta, salta, salta... diez veces, dices salta 10 veces. En programación, un bucle te permite repetir instrucciones sin tener que escribirlas una por una. ¡Es súper útil para no hacer trabajo repetitivo!"}
{"id": "f29c7dbf9c", "mode": "bigtech", "instruction": "¿Para qué sirve un bucle en programación paso a paso?", "input": "", "output": "Un bucle es como cuando saltas la cuerda 10 veces. En vez de decirle a alguien salta, salta, salta... diez veces, dices salta 10 veces. En programación, un bucle te permite repetir instrucciones sin tener que escribirlas una por una. ¡Es súper útil para no hacer trabajo repetitivo!"}
{"id": "f28005fb86", "mode": "general", "instruction": "¿Qué diferencia hay entre un bucle 'for' y uno 'while'?", "input": "", "output": "Piensa en un bucle for como cuando haces una lista de 5 ejercicios y haces cada uno una vez. Sabes cuántas veces vas a repetir algo. En cambio, un while es como lavar platos lavas mientras haya platos sucios. No sabes cuántos hay, solo repites mientras la condición sea cierta."}
{"id": "702b199c90", "mode": "general", "instruction": "¿Qué diferencia hay entre un bucle 'for' y uno 'while' con ejemplos de código?", "input": "", "output": "Piensa en un bucle for como cuando haces una lista de 5 ejercicios y haces cada uno una vez. Sabes cuántas veces vas a repetir algo. En cambio, un while es como lavar platos lavas mientras haya platos sucios. No sabes cuántos hay, solo repites mientras la condición sea cierta."}
{"id": "74fad5ee85", "mode": "general", "instruction": "¿Qué diferencia hay entre un bucle 'for' y uno 'while' paso a paso?", "input": "", "output": "Piensa en un bucle for como cuando haces una lista de 5 ejercicios y haces cada uno una vez. Sabes cuántas veces vas a repetir algo. En cambio, un while es como lavar platos lavas mientras haya platos sucios. No sabes cuántos hay, solo repites mientras la condición sea cierta."}
{"id": "749cf08b82", "mode": "general", "instruction": "¿Qué es un array?", "input": "", "output": "Un array es como un tren. Cada vagón (posición) puede llevar un objeto un número, una palabra, etc. Puedes saber qué hay en cada vagón con solo mirar su número. Así, si el tercer vagón tiene chocolate, solo dices muéstrame el vagón 3, y listo. ¡Muy útil para ordenar cosas!"}
{"id": "ff519ec9f4", "mode": "general", "instruction": "Define qué significa un array?", "input": "", "output": "Un array es como un tren. Cada vagón (posición) puede llevar un objeto un número, una palabra, etc. Puedes saber qué hay en cada vagón con solo mirar su número. Así, si el tercer vagón tiene chocolate, solo dices muéstrame el vagón 3, y listo. ¡Muy útil para ordenar cosas!"}
{"id": "7f666aba1e", "mode": "general", "instruction": "Explícame el concepto de un array?", "input": "", "output": "Un array es como un tren. Cada vagón (posición) puede llevar un objeto un número, una palabra, etc. Puedes saber qué hay en cada vagón con solo mirar su número. Así, si el tercer vagón tiene chocolate, solo dices muéstrame el vagón 3, y listo. ¡Muy útil para ordenar cosas!"}
{"id": "8d45671778", "mode": "general", "instruction": "¿Qué es un array con ejemplos de código?", "input": "", "output": "Un array es como un tren. Cada vagón (posición) puede llevar un objeto un número, una palabra, etc. Puedes saber qué hay en cada vagón con solo mirar su número. Así, si el tercer vagón tiene chocolate, solo dices muéstrame el vagón 3, y listo. ¡Muy útil para ordenar cosas!"}
{"id": "7b2a5b0aaa", "mode": "general", "instruction": "¿Qué es un array paso a paso?", "input": "", "output": "Un array es como un tren. Cada vagón (posición) puede llevar un objeto un número, una palabra, etc. Puedes saber qué hay en cada vagón con solo mirar su número. Así, si el tercer vagón tiene chocolate, solo dices muéstrame el vagón 3, y listo. ¡Muy útil para ordenar cosas!"}
{"id": "19a4071b74", "mode": "general", "instruction": "¿Qué pasa si olvido el caso base en una función recursiva?", "input": "", "output": "¡Uy! Es como meterte a un laberinto sin salida. Si una función recursiva no tiene un caso base (el punto donde se detiene), se va llamando a sí misma una y otra vez, sin fin, hasta que la computadora se cansa. El caso base es la puerta de salida, lo que le dice ¡Ya basta, hemos terminado!"}
{"id": "1e952bf855", "mode": "general", "instruction": "¿Qué pasa si olvido el caso base en una función recursiva con ejemplos de código?", "input": "", "output": "¡Uy! Es como meterte a un laberinto sin salida. Si una función recursiva no tiene un caso base (el punto donde se detiene), se va llamando a sí misma una y otra vez, sin fin, hasta que la computadora se cansa. El caso base es la puerta de salida, lo que le dice ¡Ya basta, hemos terminado!"}
{"id": "11c672f740", "mode": "general", "instruction": "¿Qué pasa si olvido el caso base en una función recursiva paso a paso?", "input": "", "output": "¡Uy! Es como meterte a un laberinto sin salida. Si una función recursiva no tiene un caso base (el punto donde se detiene), se va llamando a sí misma una y otra vez, sin fin, hasta que la computadora se cansa. El caso base es la puerta de salida, lo que le dice ¡Ya basta, hemos terminado!"}
{"id": "d876ccb3fa", "mode": "general", "instruction": "¿Cómo puedo imaginarme el flujo de un programa?", "input": "Me cuesta entender qué hace primero, qué hace después...", "output": "Imagina que eres un chef siguiendo una receta. Tu programa empieza en la primera línea (como el primer paso), y va bajando línea por línea, ejecutando cada instrucción. Si encuentra un si pasa esto, haz aquello, es como un paso condicional en la receta. Si hay un bucle, es como mezcla durante 5 minutos. Paso a paso, tu código cocina una solución deliciosa."}
{"id": "b4ab8092d1", "mode": "general", "instruction": "¿Cómo puedo imaginarme el flujo de un programa con ejemplos de código?", "input": "Me cuesta entender qué hace primero, qué hace después...", "output": "Imagina que eres un chef siguiendo una receta. Tu programa empieza en la primera línea (como el primer paso), y va bajando línea por línea, ejecutando cada instrucción. Si encuentra un si pasa esto, haz aquello, es como un paso condicional en la receta. Si hay un bucle, es como mezcla durante 5 minutos. Paso a paso, tu código cocina una solución deliciosa."}
{"id": "e7d5984e33", "mode": "general", "instruction": "¿Cómo puedo imaginarme el flujo de un programa paso a paso?", "input": "Me cuesta entender qué hace primero, qué hace después...", "output": "Imagina que eres un chef siguiendo una receta. Tu programa empieza en la primera línea (como el primer paso), y va bajando línea por línea, ejecutando cada instrucción. Si encuentra un si pasa esto, haz aquello, es como un paso condicional en la receta. Si hay un bucle, es como mezcla durante 5 minutos. Paso a paso, tu código cocina una solución deliciosa."}
{"id": "5c534ffa73", "mode": "general", "instruction": "Explícame la diferencia entre un bucle for y un while.", "input": "", "output": "piensa en subir escaleras un for es como saber que subirás 10 escalones exactos (cuentas de 1 a 10). Un while es como subir hasta que te canses sigues mientras la condición sea verdadera. El for sabe cuántas vueltas; el while depende de una condición que cambia."}
{"id": "5e57de8fbd", "mode": "general", "instruction": "Explícame la diferencia entre un bucle for y un while. con ejemplos de código?", "input": "", "output": "piensa en subir escaleras un for es como saber que subirás 10 escalones exactos (cuentas de 1 a 10). Un while es como subir hasta que te canses sigues mientras la condición sea verdadera. El for sabe cuántas vueltas; el while depende de una condición que cambia."}
{"id": "9d986dc641", "mode": "general", "instruction": "Explícame la diferencia entre un bucle for y un while. paso a paso?", "input": "", "output": "piensa en subir escaleras un for es como saber que subirás 10 escalones exactos (cuentas de 1 a 10). Un while es como subir hasta que te canses sigues mientras la condición sea verdadera. El for sabe cuántas vueltas; el while depende de una condición que cambia."}
{"id": "fd3d078198", "mode": "general", "instruction": "¿Qué es un diccionario en programación?", "input": "", "output": "imagina un cajón con fichas de palabra - definición. Buscas por la clave y obtienes el valor al instante. Un diccionario (mapa) guarda pares clave-valor y permite acceso rápido sin recorrer todo, como abrir directamente la ficha que necesitas."}
{"id": "b06fa74b8a", "mode": "general", "instruction": "Define qué significa un diccionario en programación?", "input": "", "output": "imagina un cajón con fichas de palabra - definición. Buscas por la clave y obtienes el valor al instante. Un diccionario (mapa) guarda pares clave-valor y permite acceso rápido sin recorrer todo, como abrir directamente la ficha que necesitas."}
{"id": "f356b970da", "mode": "general", "instruction": "Explícame el concepto de un diccionario en programación?", "input": "", "output": "imagina un cajón con fichas de palabra - definición. Buscas por la clave y obtienes el valor al instante. Un diccionario (mapa) guarda pares clave-valor y permite acceso rápido sin recorrer todo, como abrir directamente la ficha que necesitas."}
{"id": "9c9b1702d4", "mode": "general", "instruction": "¿Qué es un diccionario en programación con ejemplos de código?", "input": "", "output": "imagina un cajón con fichas de palabra - definición. Buscas por la clave y obtienes el valor al instante. Un diccionario (mapa) guarda pares clave-valor y permite acceso rápido sin recorrer todo, como abrir directamente la ficha que necesitas."}
{"id": "71334e72bc", "mode": "general", "instruction": "¿Qué es un diccionario en programación paso a paso?", "input": "", "output": "imagina un cajón con fichas de palabra - definición. Buscas por la clave y obtienes el valor al instante. Un diccionario (mapa) guarda pares clave-valor y permite acceso rápido sin recorrer todo, como abrir directamente la ficha que necesitas."}
{"id": "9b7b6dbf5f", "mode": "socratico", "instruction": "No sé cómo romper el bucle while.", "input": "", "output": "Piensa un momento ¿qué condición estás usando para que el bucle siga? ¿Puedes imaginar un momento en que esa condición ya no sea verdadera? ¿Qué tendría que pasar para que eso ocurriera? Tal vez ahí esté la clave."}
{"id": "a6d6d4f7a9", "mode": "socratico", "instruction": "No sé cómo romper el bucle while. con ejemplos de código?", "input": "", "output": "Piensa un momento ¿qué condición estás usando para que el bucle siga? ¿Puedes imaginar un momento en que esa condición ya no sea verdadera? ¿Qué tendría que pasar para que eso ocurriera? Tal vez ahí esté la clave."}
{"id": "86a78d9599", "mode": "socratico", "instruction": "No sé cómo romper el bucle while. paso a paso?", "input": "", "output": "Piensa un momento ¿qué condición estás usando para que el bucle siga? ¿Puedes imaginar un momento en que esa condición ya no sea verdadera? ¿Qué tendría que pasar para que eso ocurriera? Tal vez ahí esté la clave."}
{"id": "f6a00a14e6", "mode": "socratico", "instruction": "¿Cómo empiezo a pensar en recursividad?", "input": "", "output": "Imagina que estás contando hacia atrás desde 5. ¿Qué pasa cuando llegas a 1? Esa podría ser tu base. Ahora pregúntate ¿cómo resolverías el problema de tamaño N usando la solución del tamaño N-1? ¿Puedes visualizarlo?"}
{"id": "f494fba984", "mode": "socratico", "instruction": "¿Cómo empiezo a pensar en recursividad con ejemplos de código?", "input": "", "output": "Imagina que estás contando hacia atrás desde 5. ¿Qué pasa cuando llegas a 1? Esa podría ser tu base. Ahora pregúntate ¿cómo resolverías el problema de tamaño N usando la solución del tamaño N-1? ¿Puedes visualizarlo?"}
{"id": "be95159cf8", "mode": "socratico", "instruction": "¿Cómo empiezo a pensar en recursividad paso a paso?", "input": "", "output": "Imagina que estás contando hacia atrás desde 5. ¿Qué pasa cuando llegas a 1? Esa podría ser tu base. Ahora pregúntate ¿cómo resolverías el problema de tamaño N usando la solución del tamaño N-1? ¿Puedes visualizarlo?"}
{"id": "4a8317f4c7", "mode": "socratico", "instruction": "Mi código entra en un bucle infinito y no sé por qué.", "input": "", "output": "Una buena pista observa si dentro de tu bucle estás cambiando alguna de las variables que forman parte de la condición. ¿Esa condición se está acercando a ser falsa en algún momento? ¿O siempre se mantiene igual?"}
{"id": "8389234f12", "mode": "socratico", "instruction": "Mi código entra en un bucle infinito y no sé por qué. paso a paso?", "input": "", "output": "Una buena pista observa si dentro de tu bucle estás cambiando alguna de las variables que forman parte de la condición. ¿Esa condición se está acercando a ser falsa en algún momento? ¿O siempre se mantiene igual?"}
{"id": "976c8b97d7", "mode": "socratico", "instruction": "No sé cómo comparar elementos en una lista.", "input": "", "output": "Imagina que estás buscando el objeto más pesado en una fila de mochilas. ¿Cómo lo harías a mano? ¿Tal vez comparas una a una con la más pesada hasta ahora? ¿Cómo trasladarías ese pensamiento a código?"}
{"id": "f58bb73f32", "mode": "socratico", "instruction": "No sé cómo comparar elementos en una lista. con ejemplos de código?", "input": "", "output": "Imagina que estás buscando el objeto más pesado en una fila de mochilas. ¿Cómo lo harías a mano? ¿Tal vez comparas una a una con la más pesada hasta ahora? ¿Cómo trasladarías ese pensamiento a código?"}
{"id": "53f4fc94cc", "mode": "socratico", "instruction": "No sé cómo comparar elementos en una lista. paso a paso?", "input": "", "output": "Imagina que estás buscando el objeto más pesado en una fila de mochilas. ¿Cómo lo harías a mano? ¿Tal vez comparas una a una con la más pesada hasta ahora? ¿Cómo trasladarías ese pensamiento a código?"}
{"id": "d994ccc6d1", "mode": "socratico", "instruction": "No entiendo qué hace mal mi función recursiva.", "input": "La función es para calcular el factorial.", "output": "¿Has probado pensar qué pasa si le das como entrada el número 1? ¿Y el 0? ¿Qué debería devolver en esos casos? ¿Estás seguro de que tu función tiene una condición clara para detenerse?"}
{"id": "a9aede6797", "mode": "socratico", "instruction": "No entiendo qué hace mal mi función recursiva. con ejemplos de código?", "input": "La función es para calcular el factorial.", "output": "¿Has probado pensar qué pasa si le das como entrada el número 1? ¿Y el 0? ¿Qué debería devolver en esos casos? ¿Estás seguro de que tu función tiene una condición clara para detenerse?"}
{"id": "213eb9ca5a", "mode": "socratico", "instruction": "No entiendo qué hace mal mi función recursiva. paso a paso?", "input": "La función es para calcular el factorial.", "output": "¿Has probado pensar qué pasa si le das como entrada el número 1? ¿Y el 0? ¿Qué debería devolver en esos casos? ¿Estás seguro de que tu función tiene una condición clara para detenerse?"}
{"id": "3c61d9491e", "mode": "socratico", "instruction": "¿Cómo empiezo a resolver este problema de contar palabras en una frase?", "input": "", "output": "¿Qué pasaría si escribieras la frase en una hoja de papel y pusieras una marca cada vez que ves un espacio? ¿Cuántas palabras contarías así? ¿Puedes replicar ese mismo enfoque en código?"}
{"id": "d95b30f914", "mode": "socratico", "instruction": "¿Cómo empiezo a resolver este problema de contar palabras en una frase con ejemplos de código?", "input": "", "output": "¿Qué pasaría si escribieras la frase en una hoja de papel y pusieras una marca cada vez que ves un espacio? ¿Cuántas palabras contarías así? ¿Puedes replicar ese mismo enfoque en código?"}
{"id": "3840d8488e", "mode": "socratico", "instruction": "¿Cómo empiezo a resolver este problema de contar palabras en una frase paso a paso?", "input": "", "output": "¿Qué pasaría si escribieras la frase en una hoja de papel y pusieras una marca cada vez que ves un espacio? ¿Cuántas palabras contarías así? ¿Puedes replicar ese mismo enfoque en código?"}
{"id": "16020fe735", "mode": "socratico", "instruction": "No se me ocurre cómo ordenar esta lista sin usar funciones predefinidas.", "input": "", "output": "Piensa en cómo ordenarías cartas en tu mano si las vas recibiendo una por una. ¿Buscarías la menor y la pondrías primero? ¿Cómo sabrías cuál es la menor entre todas? ¿Qué harías después?"}
{"id": "d2ac3d71d6", "mode": "socratico", "instruction": "No se me ocurre cómo ordenar esta lista sin usar funciones predefinidas. con ejemplos de código?", "input": "", "output": "Piensa en cómo ordenarías cartas en tu mano si las vas recibiendo una por una. ¿Buscarías la menor y la pondrías primero? ¿Cómo sabrías cuál es la menor entre todas? ¿Qué harías después?"}
{"id": "5ff61738cb", "mode": "socratico", "instruction": "No se me ocurre cómo ordenar esta lista sin usar funciones predefinidas. paso a paso?", "input": "", "output": "Piensa en cómo ordenarías cartas en tu mano si las vas recibiendo una por una. ¿Buscarías la menor y la pondrías primero? ¿Cómo sabrías cuál es la menor entre todas? ¿Qué harías después?"}
{"id": "cc734770e1", "mode": "socratico", "instruction": "No entiendo por qué no entra en el if.", "input": "", "output": "¿Has revisado qué valor exacto tiene la variable justo antes del if? ¿Qué esperas que tenga? ¿Coincide con la condición que escribiste? A veces, solo ver el valor real ya te da una gran pista."}
{"id": "5693981bb3", "mode": "socratico", "instruction": "No entiendo por qué no entra en el if. con ejemplos de código?", "input": "", "output": "¿Has revisado qué valor exacto tiene la variable justo antes del if? ¿Qué esperas que tenga? ¿Coincide con la condición que escribiste? A veces, solo ver el valor real ya te da una gran pista."}
{"id": "74120eb7d4", "mode": "socratico", "instruction": "No entiendo por qué no entra en el if. paso a paso?", "input": "", "output": "¿Has revisado qué valor exacto tiene la variable justo antes del if? ¿Qué esperas que tenga? ¿Coincide con la condición que escribiste? A veces, solo ver el valor real ya te da una gran pista."}
{"id": "34eb6d914d", "mode": "socratico", "instruction": "¿Cómo se me ocurre una solución si no sé ni por dónde empezar?", "input": "", "output": "Imagina que el problema es una caja cerrada. ¿Puedes describir en palabras sencillas lo que se espera que ocurra? ¿Y si lo intentas con un ejemplo pequeño? ¿Qué harías paso a paso para resolverlo sin código? Ahí suele estar el algoritmo escondido."}
{"id": "146cacd19d", "mode": "socratico", "instruction": "¿Cómo se me ocurre una solución si no sé ni por dónde empezar con ejemplos de código?", "input": "", "output": "Imagina que el problema es una caja cerrada. ¿Puedes describir en palabras sencillas lo que se espera que ocurra? ¿Y si lo intentas con un ejemplo pequeño? ¿Qué harías paso a paso para resolverlo sin código? Ahí suele estar el algoritmo escondido."}
{"id": "61202be7ef", "mode": "socratico", "instruction": "¿Cómo se me ocurre una solución si no sé ni por dónde empezar paso a paso?", "input": "", "output": "Imagina que el problema es una caja cerrada. ¿Puedes describir en palabras sencillas lo que se espera que ocurra? ¿Y si lo intentas con un ejemplo pequeño? ¿Qué harías paso a paso para resolverlo sin código? Ahí suele estar el algoritmo escondido."}
{"id": "dce4262113", "mode": "general", "instruction": "Mi código funciona, pero es muy lento con listas grandes.", "input": "", "output": "Buena observación. ¿Cuántas veces se repite tu bucle si tienes 10 elementos? ¿Y si tienes 1,000? ¿Puedes pensar en una manera de evitar repeticiones innecesarias o de aprovechar algo ya calculado? ¡Tu intuición está cerca de mejorar tu algoritmo!"}
{"id": "e2d0f32f90", "mode": "general", "instruction": "Mi código funciona, pero es muy lento con listas grandes. paso a paso?", "input": "", "output": "Buena observación. ¿Cuántas veces se repite tu bucle si tienes 10 elementos? ¿Y si tienes 1,000? ¿Puedes pensar en una manera de evitar repeticiones innecesarias o de aprovechar algo ya calculado? ¡Tu intuición está cerca de mejorar tu algoritmo!"}
{"id": "79869a15ac", "mode": "socratico", "instruction": "No sé por qué mi lista queda vacía después del for.", "input": "", "output": "¿estás reasignando la lista dentro del for en vez de llenarla? ¿Agregas con append o la sustituyes? ¿Qué pasa si imprimes la lista dentro del bucle para ver en qué momento se pierde?"}
{"id": "4e9d3ff5c3", "mode": "socratico", "instruction": "No sé por qué mi lista queda vacía después del for. con ejemplos de código?", "input": "", "output": "¿estás reasignando la lista dentro del for en vez de llenarla? ¿Agregas con append o la sustituyes? ¿Qué pasa si imprimes la lista dentro del bucle para ver en qué momento se pierde?"}
{"id": "a997ad90a1", "mode": "socratico", "instruction": "No sé por qué mi lista queda vacía después del for. paso a paso?", "input": "", "output": "¿estás reasignando la lista dentro del for en vez de llenarla? ¿Agregas con append o la sustituyes? ¿Qué pasa si imprimes la lista dentro del bucle para ver en qué momento se pierde?"}
{"id": "e66f5387fd", "mode": "general", "instruction": "Mi función recursiva explota la pila.", "input": "", "output": "¿tienes un caso base que siempre se alcance? ¿El argumento se acerca al caso base en cada llamada? ¿Podrías probar con un valor mínimo y ver si retorna sin llamar de nuevo?"}
{"id": "fab9bfedde", "mode": "general", "instruction": "Mi función recursiva explota la pila. con ejemplos de código?", "input": "", "output": "¿tienes un caso base que siempre se alcance? ¿El argumento se acerca al caso base en cada llamada? ¿Podrías probar con un valor mínimo y ver si retorna sin llamar de nuevo?"}
{"id": "b48d6e53ce", "mode": "general", "instruction": "Mi función recursiva explota la pila. paso a paso?", "input": "", "output": "¿tienes un caso base que siempre se alcance? ¿El argumento se acerca al caso base en cada llamada? ¿Podrías probar con un valor mínimo y ver si retorna sin llamar de nuevo?"}
{"id": "5aaceebf9c", "mode": "general", "instruction": "¿Cómo optimizar esta solución recursiva de Fibonacci que es extremadamente lenta para n > 40?", "input": "def fibonacci(n): if n <= 1: return n return fibonacci(n - 1) + fibonacci(n - 2) # Para n=40 toma varios segundos print(fibonacci(40))", "output": "El problema es que esta solución tiene complejidad O(2n) porque recalcula los mismos valores múltiples veces. La solución es usar Memoization (programación dinámica top-down). Solución optimizada con memoization def fibonacci_memo(n, memoNone) if memo is None memo if n 1 return n if n not in memo memon fibonacci_memo(n - 1, memo) fibonacci_memo(n - 2, memo) return memon print(fibonacci_memo(40)) Respuesta instantánea Explicación de Memoization Almacenamos resultados ya calculados en un diccionario (memo). Antes de calcular fibonacci(n), verificamos si ya está en memo. Esto garantiza que cada valor se calcula solo una vez. Cambio drástico en complejidad - Original O(2n) tiempo, O(n) espacio (pila) - Optimizada O(n) tiempo, O(n) espacio - Para n40 de 2 mil millones de llamadas a solo 40 llamadas. - fibonacci(100) es ahora posible en milisegundos vs imposible antes."}
{"id": "98d91772cc", "mode": "general", "instruction": "¿Cómo optimizar esta solución recursiva de Fibonacci que es extremadamente lenta para n > 40 con ejemplos de código?", "input": "def fibonacci(n): if n <= 1: return n return fibonacci(n - 1) + fibonacci(n - 2) # Para n=40 toma varios segundos print(fibonacci(40))", "output": "El problema es que esta solución tiene complejidad O(2n) porque recalcula los mismos valores múltiples veces. La solución es usar Memoization (programación dinámica top-down). Solución optimizada con memoization def fibonacci_memo(n, memoNone) if memo is None memo if n 1 return n if n not in memo memon fibonacci_memo(n - 1, memo) fibonacci_memo(n - 2, memo) return memon print(fibonacci_memo(40)) Respuesta instantánea Explicación de Memoization Almacenamos resultados ya calculados en un diccionario (memo). Antes de calcular fibonacci(n), verificamos si ya está en memo. Esto garantiza que cada valor se calcula solo una vez. Cambio drástico en complejidad - Original O(2n) tiempo, O(n) espacio (pila) - Optimizada O(n) tiempo, O(n) espacio - Para n40 de 2 mil millones de llamadas a solo 40 llamadas. - fibonacci(100) es ahora posible en milisegundos vs imposible antes."}
{"id": "9a00ea4a49", "mode": "general", "instruction": "¿Cómo optimizar esta solución recursiva de Fibonacci que es extremadamente lenta para n > 40 paso a paso?", "input": "def fibonacci(n): if n <= 1: return n return fibonacci(n - 1) + fibonacci(n - 2) # Para n=40 toma varios segundos print(fibonacci(40))", "output": "El problema es que esta solución tiene complejidad O(2n) porque recalcula los mismos valores múltiples veces. La solución es usar Memoization (programación dinámica top-down). Solución optimizada con memoization def fibonacci_memo(n, memoNone) if memo is None memo if n 1 return n if n not in memo memon fibonacci_memo(n - 1, memo) fibonacci_memo(n - 2, memo) return memon print(fibonacci_memo(40)) Respuesta instantánea Explicación de Memoization Almacenamos resultados ya calculados en un diccionario (memo). Antes de calcular fibonacci(n), verificamos si ya está en memo. Esto garantiza que cada valor se calcula solo una vez. Cambio drástico en complejidad - Original O(2n) tiempo, O(n) espacio (pila) - Optimizada O(n) tiempo, O(n) espacio - Para n40 de 2 mil millones de llamadas a solo 40 llamadas. - fibonacci(100) es ahora posible en milisegundos vs imposible antes."}
{"id": "c7fa43676a", "mode": "general", "instruction": "La memoization con recursión funciona, pero ¿hay una forma iterativa de resolver Fibonacci con programación dinámica?", "input": "def fibonacci_memo(n, memo=None): if memo is None: memo = {} if n <= 1: return n if n not in memo: memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo) return memo[n]", "output": "Sí, se llama Tabulation (programación dinámica bottom-up). En lugar de recursión, construimos la solución iterativamente desde abajo. Solución con Tabulation def fibonacci_tab(n) if n 1 return n Crear tabla para almacenar resultados dp 0 (n 1) dp0 0 dp1 1 Llenar tabla iterativamente for i in range(2, n 1) dpi dpi - 1 dpi - 2 return dpn print(fibonacci_tab(100)) Muy rápido Optimización de espacio (solo necesitamos 2 valores previos) def fibonacci_optimized(n) if n 1 return n prev2 0 prev1 1 for i in range(2, n 1) current prev1 prev2 prev2 prev1 prev1 current return prev1 Ventajas de Tabulation - Sin límite de recursión (Python tiene límite 1000) - Generalmente más rápido que memoization (sin overhead de llamadas) - Complejidad O(n) tiempo, O(1) espacio (versión optimizada) Cuándo usar cada una - Memoization Cuando no necesitas calcular todos los subproblemas - Tabulation Cuando necesitas todos los valores, más eficiente en espacio"}
{"id": "968c5858d5", "mode": "general", "instruction": "La memoization con recursión funciona, pero ¿hay una forma iterativa de resolver Fibonacci con programación dinámica con ejemplos de código?", "input": "def fibonacci_memo(n, memo=None): if memo is None: memo = {} if n <= 1: return n if n not in memo: memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo) return memo[n]", "output": "Sí, se llama Tabulation (programación dinámica bottom-up). En lugar de recursión, construimos la solución iterativamente desde abajo. Solución con Tabulation def fibonacci_tab(n) if n 1 return n Crear tabla para almacenar resultados dp 0 (n 1) dp0 0 dp1 1 Llenar tabla iterativamente for i in range(2, n 1) dpi dpi - 1 dpi - 2 return dpn print(fibonacci_tab(100)) Muy rápido Optimización de espacio (solo necesitamos 2 valores previos) def fibonacci_optimized(n) if n 1 return n prev2 0 prev1 1 for i in range(2, n 1) current prev1 prev2 prev2 prev1 prev1 current return prev1 Ventajas de Tabulation - Sin límite de recursión (Python tiene límite 1000) - Generalmente más rápido que memoization (sin overhead de llamadas) - Complejidad O(n) tiempo, O(1) espacio (versión optimizada) Cuándo usar cada una - Memoization Cuando no necesitas calcular todos los subproblemas - Tabulation Cuando necesitas todos los valores, más eficiente en espacio"}
{"id": "14fc930828", "mode": "general", "instruction": "La memoization con recursión funciona, pero ¿hay una forma iterativa de resolver Fibonacci con programación dinámica paso a paso?", "input": "def fibonacci_memo(n, memo=None): if memo is None: memo = {} if n <= 1: return n if n not in memo: memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo) return memo[n]", "output": "Sí, se llama Tabulation (programación dinámica bottom-up). En lugar de recursión, construimos la solución iterativamente desde abajo. Solución con Tabulation def fibonacci_tab(n) if n 1 return n Crear tabla para almacenar resultados dp 0 (n 1) dp0 0 dp1 1 Llenar tabla iterativamente for i in range(2, n 1) dpi dpi - 1 dpi - 2 return dpn print(fibonacci_tab(100)) Muy rápido Optimización de espacio (solo necesitamos 2 valores previos) def fibonacci_optimized(n) if n 1 return n prev2 0 prev1 1 for i in range(2, n 1) current prev1 prev2 prev2 prev1 prev1 current return prev1 Ventajas de Tabulation - Sin límite de recursión (Python tiene límite 1000) - Generalmente más rápido que memoization (sin overhead de llamadas) - Complejidad O(n) tiempo, O(1) espacio (versión optimizada) Cuándo usar cada una - Memoization Cuando no necesitas calcular todos los subproblemas - Tabulation Cuando necesitas todos los valores, más eficiente en espacio"}
{"id": "0f3fae67f3", "mode": "general", "instruction": "Este algoritmo recursivo para el problema de la Mochila 0/1 (Knapsack) es muy lento. ¿Cómo optimizarlo con programación dinámica?", "input": "def knapsack_recursive(weights, values, capacity, n): # Caso base: sin items o capacidad 0 if n == 0 or capacity == 0: return 0 # Si el peso del item n-1 es mayor que la capacidad, no se puede incluir if weights[n - 1] > capacity: return knapsack_recursive(weights, values, capacity, n - 1) # Máximo entre incluir o no incluir el item n-1 include = values[n - 1] + knapsack_recursive(weights, values, capacity - weights[n - 1], n - 1) exclude = knapsack_recursive(weights, values, capacity, n - 1) return max(include, exclude) weights = [10, 20, 30] values = [60, 100, 120] print(knapsack_recursive(weights, values, 50, 3))", "output": "La versión recursiva tiene complejidad O(2n) porque explora todas las combinaciones. Usaremos Memoization primero y luego Tabulation. Solución 1 Memoization (Top-Down DP) def knapsack_memo(weights, values, capacity, n, memoNone) if memo is None memo if n 0 or capacity 0 return 0 Clave única para el estado actual key (n, capacity) if key in memo return memokey if weightsn - 1 capacity result knapsack_memo(weights, values, capacity, n - 1, memo) else include valuesn - 1 knapsack_memo(weights, values, capacity - weightsn - 1, n - 1, memo) exclude knapsack_memo(weights, values, capacity, n - 1, memo) result max(include, exclude) memokey result return result Solución 2 Tabulation (Bottom-Up DP) - MÁS EFICIENTE def knapsack_dp(weights, values, capacity) n len(weights) Crear tabla dpiw máximo valor con i items y capacidad w dp 0 for _ in range(capacity 1) for _ in range(n 1) Llenar tabla for i in range(1, n 1) for w in range(1, capacity 1) if weightsi - 1 w Máximo entre incluir o no incluir item i-1 dpiw max(valuesi - 1 dpi - 1w - weightsi - 1, dpi - 1w) else dpiw dpi - 1w return dpncapacity weights 10, 20, 30 values 60, 100, 120 print(knapsack_dp(weights, values, 50)) Output 220 Cambio de complejidad - Recursiva O(2n) tiempo - inviable para n 25 - MemoizationTabulation O(n capacity) tiempo, O(n capacity) espacio - Para n100, capacity1000 de imposible a milisegundos Optimización adicional de espacio Puedes reducir espacio a O(capacity) usando solo dos filas de la tabla dp."}
{"id": "0642818799", "mode": "general", "instruction": "Este algoritmo recursivo para el problema de la Mochila 0/1 (Knapsack) es muy lento. ¿Cómo optimizarlo con programación dinámica con ejemplos de código?", "input": "def knapsack_recursive(weights, values, capacity, n): # Caso base: sin items o capacidad 0 if n == 0 or capacity == 0: return 0 # Si el peso del item n-1 es mayor que la capacidad, no se puede incluir if weights[n - 1] > capacity: return knapsack_recursive(weights, values, capacity, n - 1) # Máximo entre incluir o no incluir el item n-1 include = values[n - 1] + knapsack_recursive(weights, values, capacity - weights[n - 1], n - 1) exclude = knapsack_recursive(weights, values, capacity, n - 1) return max(include, exclude) weights = [10, 20, 30] values = [60, 100, 120] print(knapsack_recursive(weights, values, 50, 3))", "output": "La versión recursiva tiene complejidad O(2n) porque explora todas las combinaciones. Usaremos Memoization primero y luego Tabulation. Solución 1 Memoization (Top-Down DP) def knapsack_memo(weights, values, capacity, n, memoNone) if memo is None memo if n 0 or capacity 0 return 0 Clave única para el estado actual key (n, capacity) if key in memo return memokey if weightsn - 1 capacity result knapsack_memo(weights, values, capacity, n - 1, memo) else include valuesn - 1 knapsack_memo(weights, values, capacity - weightsn - 1, n - 1, memo) exclude knapsack_memo(weights, values, capacity, n - 1, memo) result max(include, exclude) memokey result return result Solución 2 Tabulation (Bottom-Up DP) - MÁS EFICIENTE def knapsack_dp(weights, values, capacity) n len(weights) Crear tabla dpiw máximo valor con i items y capacidad w dp 0 for _ in range(capacity 1) for _ in range(n 1) Llenar tabla for i in range(1, n 1) for w in range(1, capacity 1) if weightsi - 1 w Máximo entre incluir o no incluir item i-1 dpiw max(valuesi - 1 dpi - 1w - weightsi - 1, dpi - 1w) else dpiw dpi - 1w return dpncapacity weights 10, 20, 30 values 60, 100, 120 print(knapsack_dp(weights, values, 50)) Output 220 Cambio de complejidad - Recursiva O(2n) tiempo - inviable para n 25 - MemoizationTabulation O(n capacity) tiempo, O(n capacity) espacio - Para n100, capacity1000 de imposible a milisegundos Optimización adicional de espacio Puedes reducir espacio a O(capacity) usando solo dos filas de la tabla dp."}
{"id": "8955b86112", "mode": "general", "instruction": "Este algoritmo recursivo para el problema de la Mochila 0/1 (Knapsack) es muy lento. ¿Cómo optimizarlo con programación dinámica paso a paso?", "input": "def knapsack_recursive(weights, values, capacity, n): # Caso base: sin items o capacidad 0 if n == 0 or capacity == 0: return 0 # Si el peso del item n-1 es mayor que la capacidad, no se puede incluir if weights[n - 1] > capacity: return knapsack_recursive(weights, values, capacity, n - 1) # Máximo entre incluir o no incluir el item n-1 include = values[n - 1] + knapsack_recursive(weights, values, capacity - weights[n - 1], n - 1) exclude = knapsack_recursive(weights, values, capacity, n - 1) return max(include, exclude) weights = [10, 20, 30] values = [60, 100, 120] print(knapsack_recursive(weights, values, 50, 3))", "output": "La versión recursiva tiene complejidad O(2n) porque explora todas las combinaciones. Usaremos Memoization primero y luego Tabulation. Solución 1 Memoization (Top-Down DP) def knapsack_memo(weights, values, capacity, n, memoNone) if memo is None memo if n 0 or capacity 0 return 0 Clave única para el estado actual key (n, capacity) if key in memo return memokey if weightsn - 1 capacity result knapsack_memo(weights, values, capacity, n - 1, memo) else include valuesn - 1 knapsack_memo(weights, values, capacity - weightsn - 1, n - 1, memo) exclude knapsack_memo(weights, values, capacity, n - 1, memo) result max(include, exclude) memokey result return result Solución 2 Tabulation (Bottom-Up DP) - MÁS EFICIENTE def knapsack_dp(weights, values, capacity) n len(weights) Crear tabla dpiw máximo valor con i items y capacidad w dp 0 for _ in range(capacity 1) for _ in range(n 1) Llenar tabla for i in range(1, n 1) for w in range(1, capacity 1) if weightsi - 1 w Máximo entre incluir o no incluir item i-1 dpiw max(valuesi - 1 dpi - 1w - weightsi - 1, dpi - 1w) else dpiw dpi - 1w return dpncapacity weights 10, 20, 30 values 60, 100, 120 print(knapsack_dp(weights, values, 50)) Output 220 Cambio de complejidad - Recursiva O(2n) tiempo - inviable para n 25 - MemoizationTabulation O(n capacity) tiempo, O(n capacity) espacio - Para n100, capacity1000 de imposible a milisegundos Optimización adicional de espacio Puedes reducir espacio a O(capacity) usando solo dos filas de la tabla dp."}
{"id": "d41c4409b3", "mode": "general", "instruction": "¿Cómo resolver el problema de Longest Common Subsequence (LCS) eficientemente? La solución recursiva es demasiado lenta.", "input": "def lcs_recursive(X, Y, m, n): if m == 0 or n == 0: return 0 if X[m - 1] == Y[n - 1]: return 1 + lcs_recursive(X, Y, m - 1, n - 1) else: return max(lcs_recursive(X, Y, m - 1, n), lcs_recursive(X, Y, m, n - 1)) X = \"AGGTAB\" Y = \"GXTXAYB\" print(lcs_recursive(X, Y, len(X), len(Y)))", "output": "La solución recursiva tiene complejidad exponencial O(2(mn)) por recalcular subproblemas. Usaremos Programación Dinámica con Tabulation. Solución optimizada con Tabulation def lcs_dp(X, Y) m len(X) n len(Y) Crear tabla dp donde dpij LCS de X0.. i-1 y Y0.. j-1 dp 0 for _ in range(n 1) for _ in range(m 1) Llenar tabla bottom-up for i in range(1, m 1) for j in range(1, n 1) if Xi - 1 Yj - 1 Caracteres coinciden agregar 1 al LCS anterior dpij 1 dpi - 1j - 1 else No coinciden tomar el máximo de excluir uno u otro dpij max(dpi - 1j, dpij - 1) return dpmn Para obtener la secuencia real def lcs_with_string(X, Y) m, n len(X), len(Y) dp 0 (n 1) for _ in range(m 1) Llenar tabla for i in range(1, m 1) for j in range(1, n 1) if Xi - 1 Yj - 1 dpij 1 dpi - 1j - 1 else dpij max(dpi - 1j, dpij - 1) Reconstruir la secuencia lcs i, j m, n while i 0 and j 0 if Xi - 1 Yj - 1 lcs. append(Xi - 1) i - 1 j - 1 elif dpi - 1j dpij - 1 i - 1 else j - 1 return. join(reversed(lcs)) X AGGTAB Y GXTXAYB print(fLongitud lcs_dp(X, Y)) Output 4 print(fLCS lcs_with_string(X, Y)) Output GTAB Mejora de complejidad - Recursiva O(2(mn)) - inviable para strings 20 caracteres - DP O(m n) tiempo, O(m n) espacio - Para strings de 1000 caracteres de imposible a milisegundos"}
{"id": "4061c04ad6", "mode": "general", "instruction": "¿Cómo resolver el problema de Longest Common Subsequence (LCS) eficientemente? La solución recursiva es demasiado lenta. con ejemplos de código?", "input": "def lcs_recursive(X, Y, m, n): if m == 0 or n == 0: return 0 if X[m - 1] == Y[n - 1]: return 1 + lcs_recursive(X, Y, m - 1, n - 1) else: return max(lcs_recursive(X, Y, m - 1, n), lcs_recursive(X, Y, m, n - 1)) X = \"AGGTAB\" Y = \"GXTXAYB\" print(lcs_recursive(X, Y, len(X), len(Y)))", "output": "La solución recursiva tiene complejidad exponencial O(2(mn)) por recalcular subproblemas. Usaremos Programación Dinámica con Tabulation. Solución optimizada con Tabulation def lcs_dp(X, Y) m len(X) n len(Y) Crear tabla dp donde dpij LCS de X0.. i-1 y Y0.. j-1 dp 0 for _ in range(n 1) for _ in range(m 1) Llenar tabla bottom-up for i in range(1, m 1) for j in range(1, n 1) if Xi - 1 Yj - 1 Caracteres coinciden agregar 1 al LCS anterior dpij 1 dpi - 1j - 1 else No coinciden tomar el máximo de excluir uno u otro dpij max(dpi - 1j, dpij - 1) return dpmn Para obtener la secuencia real def lcs_with_string(X, Y) m, n len(X), len(Y) dp 0 (n 1) for _ in range(m 1) Llenar tabla for i in range(1, m 1) for j in range(1, n 1) if Xi - 1 Yj - 1 dpij 1 dpi - 1j - 1 else dpij max(dpi - 1j, dpij - 1) Reconstruir la secuencia lcs i, j m, n while i 0 and j 0 if Xi - 1 Yj - 1 lcs. append(Xi - 1) i - 1 j - 1 elif dpi - 1j dpij - 1 i - 1 else j - 1 return. join(reversed(lcs)) X AGGTAB Y GXTXAYB print(fLongitud lcs_dp(X, Y)) Output 4 print(fLCS lcs_with_string(X, Y)) Output GTAB Mejora de complejidad - Recursiva O(2(mn)) - inviable para strings 20 caracteres - DP O(m n) tiempo, O(m n) espacio - Para strings de 1000 caracteres de imposible a milisegundos"}
{"id": "ac7ca20240", "mode": "general", "instruction": "¿Cómo resolver el problema de Longest Common Subsequence (LCS) eficientemente? La solución recursiva es demasiado lenta. paso a paso?", "input": "def lcs_recursive(X, Y, m, n): if m == 0 or n == 0: return 0 if X[m - 1] == Y[n - 1]: return 1 + lcs_recursive(X, Y, m - 1, n - 1) else: return max(lcs_recursive(X, Y, m - 1, n), lcs_recursive(X, Y, m, n - 1)) X = \"AGGTAB\" Y = \"GXTXAYB\" print(lcs_recursive(X, Y, len(X), len(Y)))", "output": "La solución recursiva tiene complejidad exponencial O(2(mn)) por recalcular subproblemas. Usaremos Programación Dinámica con Tabulation. Solución optimizada con Tabulation def lcs_dp(X, Y) m len(X) n len(Y) Crear tabla dp donde dpij LCS de X0.. i-1 y Y0.. j-1 dp 0 for _ in range(n 1) for _ in range(m 1) Llenar tabla bottom-up for i in range(1, m 1) for j in range(1, n 1) if Xi - 1 Yj - 1 Caracteres coinciden agregar 1 al LCS anterior dpij 1 dpi - 1j - 1 else No coinciden tomar el máximo de excluir uno u otro dpij max(dpi - 1j, dpij - 1) return dpmn Para obtener la secuencia real def lcs_with_string(X, Y) m, n len(X), len(Y) dp 0 (n 1) for _ in range(m 1) Llenar tabla for i in range(1, m 1) for j in range(1, n 1) if Xi - 1 Yj - 1 dpij 1 dpi - 1j - 1 else dpij max(dpi - 1j, dpij - 1) Reconstruir la secuencia lcs i, j m, n while i 0 and j 0 if Xi - 1 Yj - 1 lcs. append(Xi - 1) i - 1 j - 1 elif dpi - 1j dpij - 1 i - 1 else j - 1 return. join(reversed(lcs)) X AGGTAB Y GXTXAYB print(fLongitud lcs_dp(X, Y)) Output 4 print(fLCS lcs_with_string(X, Y)) Output GTAB Mejora de complejidad - Recursiva O(2(mn)) - inviable para strings 20 caracteres - DP O(m n) tiempo, O(m n) espacio - Para strings de 1000 caracteres de imposible a milisegundos"}
{"id": "a4e0cd21cf", "mode": "general", "instruction": "¿Cómo optimizar este algoritmo recursivo para el problema de Coin Change (mínimo número de monedas)?", "input": "def coin_change_recursive(coins, amount): if amount == 0: return 0 if amount < 0: return float('inf') min_coins = float('inf') for coin in coins: result = coin_change_recursive(coins, amount - coin) if result!= float('inf'): min_coins = min(min_coins, result + 1) return min_coins coins = [1, 2, 5] print(coin_change_recursive(coins, 11))", "output": "Este problema tiene complejidad O(amountn) en su versión recursiva debido a subproblemas repetidos. Usaremos Programación Dinámica. Solución 1 Memoization (Top-Down) def coin_change_memo(coins, amount, memoNone) if memo is None memo if amount 0 return 0 if amount 0 return float(inf) if amount in memo return memoamount min_coins float(inf) for coin in coins result coin_change_memo(coins, amount - coin, memo) if result! float(inf) min_coins min(min_coins, result 1) memoamount min_coins return min_coins Solución 2 Tabulation (Bottom-Up) - MÁS EFICIENTE def coin_change_dp(coins, amount) dpi mínimo número de monedas para cantidad i dp float(inf) (amount 1) dp0 0 0 monedas para cantidad 0 Para cada cantidad de 1 a amount for i in range(1, amount 1) Probar cada moneda for coin in coins if coin i dpi min(dpi, dpi - coin 1) Si dpamount sigue siendo infinito, no hay solución return dpamount if dpamount! float(inf) else -1 Ejemplo con reconstrucción de solución def coin_change_with_coins(coins, amount) dp float(inf) (amount 1) parent -1 (amount 1) dp0 0 for i in range(1, amount 1) for coin in coins if coin i and dpi - coin 1 dpi dpi dpi - coin 1 parenti coin if dpamount float(inf) return -1, Reconstruir monedas usadas used_coins current amount while current 0 used_coins. append(parentcurrent) current - parentcurrent return dpamount, used_coins coins 1, 2, 5 count, used coin_change_with_coins(coins, 11) print(fMínimo count monedas) Output 3 print(fMonedas used) Output 5, 5, 1 o similar Mejora de complejidad - Recursiva O(amountn) - extremadamente lenta - DP O(amount n) donde n número de monedas - Para amount1000, coins10 de imposible a instantáneo"}
{"id": "e7f25019c8", "mode": "general", "instruction": "¿Cómo optimizar este algoritmo recursivo para el problema de Coin Change (mínimo número de monedas) con ejemplos de código?", "input": "def coin_change_recursive(coins, amount): if amount == 0: return 0 if amount < 0: return float('inf') min_coins = float('inf') for coin in coins: result = coin_change_recursive(coins, amount - coin) if result!= float('inf'): min_coins = min(min_coins, result + 1) return min_coins coins = [1, 2, 5] print(coin_change_recursive(coins, 11))", "output": "Este problema tiene complejidad O(amountn) en su versión recursiva debido a subproblemas repetidos. Usaremos Programación Dinámica. Solución 1 Memoization (Top-Down) def coin_change_memo(coins, amount, memoNone) if memo is None memo if amount 0 return 0 if amount 0 return float(inf) if amount in memo return memoamount min_coins float(inf) for coin in coins result coin_change_memo(coins, amount - coin, memo) if result! float(inf) min_coins min(min_coins, result 1) memoamount min_coins return min_coins Solución 2 Tabulation (Bottom-Up) - MÁS EFICIENTE def coin_change_dp(coins, amount) dpi mínimo número de monedas para cantidad i dp float(inf) (amount 1) dp0 0 0 monedas para cantidad 0 Para cada cantidad de 1 a amount for i in range(1, amount 1) Probar cada moneda for coin in coins if coin i dpi min(dpi, dpi - coin 1) Si dpamount sigue siendo infinito, no hay solución return dpamount if dpamount! float(inf) else -1 Ejemplo con reconstrucción de solución def coin_change_with_coins(coins, amount) dp float(inf) (amount 1) parent -1 (amount 1) dp0 0 for i in range(1, amount 1) for coin in coins if coin i and dpi - coin 1 dpi dpi dpi - coin 1 parenti coin if dpamount float(inf) return -1, Reconstruir monedas usadas used_coins current amount while current 0 used_coins. append(parentcurrent) current - parentcurrent return dpamount, used_coins coins 1, 2, 5 count, used coin_change_with_coins(coins, 11) print(fMínimo count monedas) Output 3 print(fMonedas used) Output 5, 5, 1 o similar Mejora de complejidad - Recursiva O(amountn) - extremadamente lenta - DP O(amount n) donde n número de monedas - Para amount1000, coins10 de imposible a instantáneo"}
{"id": "67bd402f3e", "mode": "general", "instruction": "¿Cómo optimizar este algoritmo recursivo para el problema de Coin Change (mínimo número de monedas) paso a paso?", "input": "def coin_change_recursive(coins, amount): if amount == 0: return 0 if amount < 0: return float('inf') min_coins = float('inf') for coin in coins: result = coin_change_recursive(coins, amount - coin) if result!= float('inf'): min_coins = min(min_coins, result + 1) return min_coins coins = [1, 2, 5] print(coin_change_recursive(coins, 11))", "output": "Este problema tiene complejidad O(amountn) en su versión recursiva debido a subproblemas repetidos. Usaremos Programación Dinámica. Solución 1 Memoization (Top-Down) def coin_change_memo(coins, amount, memoNone) if memo is None memo if amount 0 return 0 if amount 0 return float(inf) if amount in memo return memoamount min_coins float(inf) for coin in coins result coin_change_memo(coins, amount - coin, memo) if result! float(inf) min_coins min(min_coins, result 1) memoamount min_coins return min_coins Solución 2 Tabulation (Bottom-Up) - MÁS EFICIENTE def coin_change_dp(coins, amount) dpi mínimo número de monedas para cantidad i dp float(inf) (amount 1) dp0 0 0 monedas para cantidad 0 Para cada cantidad de 1 a amount for i in range(1, amount 1) Probar cada moneda for coin in coins if coin i dpi min(dpi, dpi - coin 1) Si dpamount sigue siendo infinito, no hay solución return dpamount if dpamount! float(inf) else -1 Ejemplo con reconstrucción de solución def coin_change_with_coins(coins, amount) dp float(inf) (amount 1) parent -1 (amount 1) dp0 0 for i in range(1, amount 1) for coin in coins if coin i and dpi - coin 1 dpi dpi dpi - coin 1 parenti coin if dpamount float(inf) return -1, Reconstruir monedas usadas used_coins current amount while current 0 used_coins. append(parentcurrent) current - parentcurrent return dpamount, used_coins coins 1, 2, 5 count, used coin_change_with_coins(coins, 11) print(fMínimo count monedas) Output 3 print(fMonedas used) Output 5, 5, 1 o similar Mejora de complejidad - Recursiva O(amountn) - extremadamente lenta - DP O(amount n) donde n número de monedas - Para amount1000, coins10 de imposible a instantáneo"}
{"id": "1daa4af1b8", "mode": "general", "instruction": "¿Cómo resolver el problema de Climbing Stairs con programación dinámica? La recursión es lenta para n grande.", "input": "def climb_stairs_recursive(n): if n <= 2: return n return climb_stairs_recursive(n - 1) + climb_stairs_recursive(n - 2) # Problema: ¿De cuántas formas puedes subir n escalones si puedes subir 1 o 2 a la vez? print(climb_stairs_recursive(35)) # Muy lento", "output": "Este problema es idéntico a Fibonacci en estructura, con complejidad O(2n) recursiva. Optimizaremos con Programación Dinámica. Solución 1 Tabulation (más eficiente) def climb_stairs_dp(n) if n 2 return n dpi número de formas de llegar al escalón i dp 0 (n 1) dp1 1 1 forma de llegar al escalón 1 dp2 2 2 formas de llegar al escalón 2 (11 o 2) for i in range(3, n 1) Puedes llegar desde i-1 o i-2 dpi dpi - 1 dpi - 2 return dpn Solución 2 Optimizada en espacio O(1) def climb_stairs_optimized(n) if n 2 return n prev2 1 formas de llegar a escalón 1 prev1 2 formas de llegar a escalón 2 for i in range(3, n 1) current prev1 prev2 prev2 prev1 prev1 current return prev1 Extensión si puedes subir 1, 2 o 3 escalones def climb_stairs_k_steps(n, k) n escalones totales, k máximo de escalones por paso if n 0 return 1 if n 0 return 0 dp 0 (n 1) dp0 1 for i in range(1, n 1) for step in range(1, min(i, k) 1) dpi dpi - step return dpn print(climb_stairs_dp(35)) Instantáneo print(climb_stairs_optimized(100)) Muy rápido print(climb_stairs_k_steps(10, 3)) Con hasta 3 escalones por paso Análisis de complejidad - Recursiva O(2n) tiempo, O(n) espacio (pila) - DP Tabulation O(n) tiempo, O(n) espacio - DP Optimizada O(n) tiempo, O(1) espacio - Para n100 de imposible con recursión a microsegundos con DP Patrón importante Cualquier problema donde la solución depende de subproblemas previos fijos (ej dpi dpi-1 dpi-2) es candidato perfecto para DP."}
{"id": "20ae1ef13d", "mode": "general", "instruction": "¿Cómo resolver el problema de Climbing Stairs con programación dinámica? La recursión es lenta para n grande. con ejemplos de código?", "input": "def climb_stairs_recursive(n): if n <= 2: return n return climb_stairs_recursive(n - 1) + climb_stairs_recursive(n - 2) # Problema: ¿De cuántas formas puedes subir n escalones si puedes subir 1 o 2 a la vez? print(climb_stairs_recursive(35)) # Muy lento", "output": "Este problema es idéntico a Fibonacci en estructura, con complejidad O(2n) recursiva. Optimizaremos con Programación Dinámica. Solución 1 Tabulation (más eficiente) def climb_stairs_dp(n) if n 2 return n dpi número de formas de llegar al escalón i dp 0 (n 1) dp1 1 1 forma de llegar al escalón 1 dp2 2 2 formas de llegar al escalón 2 (11 o 2) for i in range(3, n 1) Puedes llegar desde i-1 o i-2 dpi dpi - 1 dpi - 2 return dpn Solución 2 Optimizada en espacio O(1) def climb_stairs_optimized(n) if n 2 return n prev2 1 formas de llegar a escalón 1 prev1 2 formas de llegar a escalón 2 for i in range(3, n 1) current prev1 prev2 prev2 prev1 prev1 current return prev1 Extensión si puedes subir 1, 2 o 3 escalones def climb_stairs_k_steps(n, k) n escalones totales, k máximo de escalones por paso if n 0 return 1 if n 0 return 0 dp 0 (n 1) dp0 1 for i in range(1, n 1) for step in range(1, min(i, k) 1) dpi dpi - step return dpn print(climb_stairs_dp(35)) Instantáneo print(climb_stairs_optimized(100)) Muy rápido print(climb_stairs_k_steps(10, 3)) Con hasta 3 escalones por paso Análisis de complejidad - Recursiva O(2n) tiempo, O(n) espacio (pila) - DP Tabulation O(n) tiempo, O(n) espacio - DP Optimizada O(n) tiempo, O(1) espacio - Para n100 de imposible con recursión a microsegundos con DP Patrón importante Cualquier problema donde la solución depende de subproblemas previos fijos (ej dpi dpi-1 dpi-2) es candidato perfecto para DP."}
{"id": "cf01a4e166", "mode": "general", "instruction": "¿Cómo resolver el problema de Climbing Stairs con programación dinámica? La recursión es lenta para n grande. paso a paso?", "input": "def climb_stairs_recursive(n): if n <= 2: return n return climb_stairs_recursive(n - 1) + climb_stairs_recursive(n - 2) # Problema: ¿De cuántas formas puedes subir n escalones si puedes subir 1 o 2 a la vez? print(climb_stairs_recursive(35)) # Muy lento", "output": "Este problema es idéntico a Fibonacci en estructura, con complejidad O(2n) recursiva. Optimizaremos con Programación Dinámica. Solución 1 Tabulation (más eficiente) def climb_stairs_dp(n) if n 2 return n dpi número de formas de llegar al escalón i dp 0 (n 1) dp1 1 1 forma de llegar al escalón 1 dp2 2 2 formas de llegar al escalón 2 (11 o 2) for i in range(3, n 1) Puedes llegar desde i-1 o i-2 dpi dpi - 1 dpi - 2 return dpn Solución 2 Optimizada en espacio O(1) def climb_stairs_optimized(n) if n 2 return n prev2 1 formas de llegar a escalón 1 prev1 2 formas de llegar a escalón 2 for i in range(3, n 1) current prev1 prev2 prev2 prev1 prev1 current return prev1 Extensión si puedes subir 1, 2 o 3 escalones def climb_stairs_k_steps(n, k) n escalones totales, k máximo de escalones por paso if n 0 return 1 if n 0 return 0 dp 0 (n 1) dp0 1 for i in range(1, n 1) for step in range(1, min(i, k) 1) dpi dpi - step return dpn print(climb_stairs_dp(35)) Instantáneo print(climb_stairs_optimized(100)) Muy rápido print(climb_stairs_k_steps(10, 3)) Con hasta 3 escalones por paso Análisis de complejidad - Recursiva O(2n) tiempo, O(n) espacio (pila) - DP Tabulation O(n) tiempo, O(n) espacio - DP Optimizada O(n) tiempo, O(1) espacio - Para n100 de imposible con recursión a microsegundos con DP Patrón importante Cualquier problema donde la solución depende de subproblemas previos fijos (ej dpi dpi-1 dpi-2) es candidato perfecto para DP."}
{"id": "a036824a6d", "mode": "general", "instruction": "Explica el algoritmo Greedy para Activity Selection. ¿Por qué funciona la estrategia voraz aquí?", "input": "# Problema: Seleccionar máximo número de actividades no solapadas activities = [ (1, 4), # (inicio, fin) (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16) ] # ¿Cómo seleccionar el máximo número de actividades?", "output": "El algoritmo Greedy (voraz) funciona aquí porque tiene la propiedad de elección voraz óptima seleccionar siempre la actividad que termina primero es óptimo. Implementación del algoritmo Greedy def activity_selection(activities) Ordenar por tiempo de finalización (clave del greedy) activities_sorted sorted(activities, keylambda x x1) selected activities_sorted0 Siempre seleccionar la primera last_finish_time activities_sorted01 for i in range(1, len(activities_sorted)) start, finish activities_sortedi Si la actividad comienza después de que termine la última seleccionada if start last_finish_time selected. append(activities_sortedi) last_finish_time finish return selected Versión con índices originales def activity_selection_with_indices(activities) Agregar índices originales indexed (i, start, finish) for i, (start, finish) in enumerate(activities) indexed_sorted sorted(indexed, keylambda x x2) Ordenar por fin selected indexed_sorted0 last_finish indexed_sorted02 for item in indexed_sorted1 idx, start, finish item if start last_finish selected. append(item) last_finish finish return (idx, start, finish) for idx, start, finish in selected activities (1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16) result activity_selection(activities) print(fActividades seleccionadas result) print(fTotal len(result) actividades) ¿Por qué funciona Greedy aquí? 1. Propiedad de elección voraz Siempre existe una solución óptima que incluye la actividad que termina primero. 2. Subestructura óptima Después de seleccionar una actividad, el problema restante es independiente. 3. Prueba informal Si seleccionas una actividad que termina más tarde, ocupas más tiempo y reduces opciones futuras. Complejidad - Tiempo O(n log n) debido al ordenamiento - Espacio O(n) para almacenar actividades seleccionadas Comparación con DP Este problema PODRÍA resolverse con DP en O(n²), pero Greedy es más eficiente O(n log n) y más simple."}
{"id": "d45a950c84", "mode": "general", "instruction": "Dame una explicación sobre el algoritmo Greedy para Activity Selection. ¿Por qué funciona la estrategia voraz aquí?", "input": "# Problema: Seleccionar máximo número de actividades no solapadas activities = [ (1, 4), # (inicio, fin) (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16) ] # ¿Cómo seleccionar el máximo número de actividades?", "output": "El algoritmo Greedy (voraz) funciona aquí porque tiene la propiedad de elección voraz óptima seleccionar siempre la actividad que termina primero es óptimo. Implementación del algoritmo Greedy def activity_selection(activities) Ordenar por tiempo de finalización (clave del greedy) activities_sorted sorted(activities, keylambda x x1) selected activities_sorted0 Siempre seleccionar la primera last_finish_time activities_sorted01 for i in range(1, len(activities_sorted)) start, finish activities_sortedi Si la actividad comienza después de que termine la última seleccionada if start last_finish_time selected. append(activities_sortedi) last_finish_time finish return selected Versión con índices originales def activity_selection_with_indices(activities) Agregar índices originales indexed (i, start, finish) for i, (start, finish) in enumerate(activities) indexed_sorted sorted(indexed, keylambda x x2) Ordenar por fin selected indexed_sorted0 last_finish indexed_sorted02 for item in indexed_sorted1 idx, start, finish item if start last_finish selected. append(item) last_finish finish return (idx, start, finish) for idx, start, finish in selected activities (1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16) result activity_selection(activities) print(fActividades seleccionadas result) print(fTotal len(result) actividades) ¿Por qué funciona Greedy aquí? 1. Propiedad de elección voraz Siempre existe una solución óptima que incluye la actividad que termina primero. 2. Subestructura óptima Después de seleccionar una actividad, el problema restante es independiente. 3. Prueba informal Si seleccionas una actividad que termina más tarde, ocupas más tiempo y reduces opciones futuras. Complejidad - Tiempo O(n log n) debido al ordenamiento - Espacio O(n) para almacenar actividades seleccionadas Comparación con DP Este problema PODRÍA resolverse con DP en O(n²), pero Greedy es más eficiente O(n log n) y más simple."}
{"id": "bf9ef25fd9", "mode": "general", "instruction": "Ayúdame a entender el algoritmo Greedy para Activity Selection. ¿Por qué funciona la estrategia voraz aquí?", "input": "# Problema: Seleccionar máximo número de actividades no solapadas activities = [ (1, 4), # (inicio, fin) (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16) ] # ¿Cómo seleccionar el máximo número de actividades?", "output": "El algoritmo Greedy (voraz) funciona aquí porque tiene la propiedad de elección voraz óptima seleccionar siempre la actividad que termina primero es óptimo. Implementación del algoritmo Greedy def activity_selection(activities) Ordenar por tiempo de finalización (clave del greedy) activities_sorted sorted(activities, keylambda x x1) selected activities_sorted0 Siempre seleccionar la primera last_finish_time activities_sorted01 for i in range(1, len(activities_sorted)) start, finish activities_sortedi Si la actividad comienza después de que termine la última seleccionada if start last_finish_time selected. append(activities_sortedi) last_finish_time finish return selected Versión con índices originales def activity_selection_with_indices(activities) Agregar índices originales indexed (i, start, finish) for i, (start, finish) in enumerate(activities) indexed_sorted sorted(indexed, keylambda x x2) Ordenar por fin selected indexed_sorted0 last_finish indexed_sorted02 for item in indexed_sorted1 idx, start, finish item if start last_finish selected. append(item) last_finish finish return (idx, start, finish) for idx, start, finish in selected activities (1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16) result activity_selection(activities) print(fActividades seleccionadas result) print(fTotal len(result) actividades) ¿Por qué funciona Greedy aquí? 1. Propiedad de elección voraz Siempre existe una solución óptima que incluye la actividad que termina primero. 2. Subestructura óptima Después de seleccionar una actividad, el problema restante es independiente. 3. Prueba informal Si seleccionas una actividad que termina más tarde, ocupas más tiempo y reduces opciones futuras. Complejidad - Tiempo O(n log n) debido al ordenamiento - Espacio O(n) para almacenar actividades seleccionadas Comparación con DP Este problema PODRÍA resolverse con DP en O(n²), pero Greedy es más eficiente O(n log n) y más simple."}
{"id": "126d0be129", "mode": "general", "instruction": "Explica el algoritmo Greedy para Activity Selection. ¿Por qué funciona la estrategia voraz aquí con ejemplos de código?", "input": "# Problema: Seleccionar máximo número de actividades no solapadas activities = [ (1, 4), # (inicio, fin) (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16) ] # ¿Cómo seleccionar el máximo número de actividades?", "output": "El algoritmo Greedy (voraz) funciona aquí porque tiene la propiedad de elección voraz óptima seleccionar siempre la actividad que termina primero es óptimo. Implementación del algoritmo Greedy def activity_selection(activities) Ordenar por tiempo de finalización (clave del greedy) activities_sorted sorted(activities, keylambda x x1) selected activities_sorted0 Siempre seleccionar la primera last_finish_time activities_sorted01 for i in range(1, len(activities_sorted)) start, finish activities_sortedi Si la actividad comienza después de que termine la última seleccionada if start last_finish_time selected. append(activities_sortedi) last_finish_time finish return selected Versión con índices originales def activity_selection_with_indices(activities) Agregar índices originales indexed (i, start, finish) for i, (start, finish) in enumerate(activities) indexed_sorted sorted(indexed, keylambda x x2) Ordenar por fin selected indexed_sorted0 last_finish indexed_sorted02 for item in indexed_sorted1 idx, start, finish item if start last_finish selected. append(item) last_finish finish return (idx, start, finish) for idx, start, finish in selected activities (1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16) result activity_selection(activities) print(fActividades seleccionadas result) print(fTotal len(result) actividades) ¿Por qué funciona Greedy aquí? 1. Propiedad de elección voraz Siempre existe una solución óptima que incluye la actividad que termina primero. 2. Subestructura óptima Después de seleccionar una actividad, el problema restante es independiente. 3. Prueba informal Si seleccionas una actividad que termina más tarde, ocupas más tiempo y reduces opciones futuras. Complejidad - Tiempo O(n log n) debido al ordenamiento - Espacio O(n) para almacenar actividades seleccionadas Comparación con DP Este problema PODRÍA resolverse con DP en O(n²), pero Greedy es más eficiente O(n log n) y más simple."}
{"id": "7e017ca6fb", "mode": "general", "instruction": "Explica el algoritmo Greedy para Activity Selection. ¿Por qué funciona la estrategia voraz aquí paso a paso?", "input": "# Problema: Seleccionar máximo número de actividades no solapadas activities = [ (1, 4), # (inicio, fin) (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16) ] # ¿Cómo seleccionar el máximo número de actividades?", "output": "El algoritmo Greedy (voraz) funciona aquí porque tiene la propiedad de elección voraz óptima seleccionar siempre la actividad que termina primero es óptimo. Implementación del algoritmo Greedy def activity_selection(activities) Ordenar por tiempo de finalización (clave del greedy) activities_sorted sorted(activities, keylambda x x1) selected activities_sorted0 Siempre seleccionar la primera last_finish_time activities_sorted01 for i in range(1, len(activities_sorted)) start, finish activities_sortedi Si la actividad comienza después de que termine la última seleccionada if start last_finish_time selected. append(activities_sortedi) last_finish_time finish return selected Versión con índices originales def activity_selection_with_indices(activities) Agregar índices originales indexed (i, start, finish) for i, (start, finish) in enumerate(activities) indexed_sorted sorted(indexed, keylambda x x2) Ordenar por fin selected indexed_sorted0 last_finish indexed_sorted02 for item in indexed_sorted1 idx, start, finish item if start last_finish selected. append(item) last_finish finish return (idx, start, finish) for idx, start, finish in selected activities (1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16) result activity_selection(activities) print(fActividades seleccionadas result) print(fTotal len(result) actividades) ¿Por qué funciona Greedy aquí? 1. Propiedad de elección voraz Siempre existe una solución óptima que incluye la actividad que termina primero. 2. Subestructura óptima Después de seleccionar una actividad, el problema restante es independiente. 3. Prueba informal Si seleccionas una actividad que termina más tarde, ocupas más tiempo y reduces opciones futuras. Complejidad - Tiempo O(n log n) debido al ordenamiento - Espacio O(n) para almacenar actividades seleccionadas Comparación con DP Este problema PODRÍA resolverse con DP en O(n²), pero Greedy es más eficiente O(n log n) y más simple."}
{"id": "6133f20e20", "mode": "general", "instruction": "¿En qué se diferencia el Knapsack Fraccionario (Fractional Knapsack) del 0/1? ¿Por qué Greedy funciona aquí?", "input": "# Problema: Knapsack donde puedes tomar fracciones de items items = [ (60, 10), # (valor, peso) (100, 20), (120, 30) ] capacity = 50 # En 0/1 Knapsack necesitábamos DP, ¿por qué aquí podemos usar Greedy?", "output": "La diferencia clave en Fractional Knapsack puedes tomar fracciones de items, lo que permite una estrategia voraz basada en valor por unidad de peso. Implementación Greedy para Fractional Knapsack def fractional_knapsack(items, capacity) Calcular valor por peso y ordenar descendentemente items_with_ratio for value, weight in items items_with_ratio. append((value, weight, value weight)) Ordenar por ratio descendente (greedy choice) items_sorted sorted(items_with_ratio, keylambda x x2, reverseTrue) total_value 0 remaining_capacity capacity taken Para mostrar qué se tomó for value, weight, ratio in items_sorted if remaining_capacity weight Tomar el item completo total_value value remaining_capacity - weight taken. append((value, weight, 1.0)) 100 del item else Tomar fracción del item fraction remaining_capacity weight total_value value fraction taken. append((value, weight, fraction)) remaining_capacity 0 break return total_value, taken Versión detallada con explicación def fractional_knapsack_detailed(items, capacity) print(Items disponibles) items_data for i, (value, weight) in enumerate(items) ratio value weight items_data. append((i, value, weight, ratio)) print(fItem i valorvalue, pesoweight, ratioratio.2f) items_sorted sorted(items_data, keylambda x x3, reverseTrue) print(fnOrden greedy (por ratio) x0 for x in items_sorted) total_value 0 remaining capacity print(fnCapacidad inicial capacity) for idx, value, weight, ratio in items_sorted if remaining weight print(fTomar 100 del item idx (valorvalue, pesoweight)) total_value value remaining - weight elif remaining 0 fraction remaining weight partial_value value fraction print(fTomar fraction100.1f del item idx (valorpartial_value.2f)) total_value partial_value remaining 0 return total_value items (60, 10), (100, 20), (120, 30) value, details fractional_knapsack(items, 50) print(fnValor máximo value) print(fDetalles details) ¿Por qué Greedy funciona aquí pero no en 01 Knapsack? 1. Fractional Knapsack - Propiedad Puedes tomar fracciones - Estrategia Ordenar por valorpeso y tomar lo mejor primero - Complejidad O(n log n) - Greedy da solución óptima SIEMPRE 2. 01 Knapsack - Restricción Todo o nada por item - Greedy NO funciona (contraejemplo items(10,5), (60,20), (100,30), capacity50) - Necesita DP O(n capacity) - Greedy puede dar soluciones subóptimas Complejidad - Tiempo O(n log n) por el ordenamiento - Espacio O(n) Este es un ejemplo perfecto de cómo cambiar ligeramente las restricciones del problema puede cambiar la estrategia óptima de DP a Greedy."}
{"id": "922ca0404b", "mode": "general", "instruction": "¿En qué se diferencia el Knapsack Fraccionario (Fractional Knapsack) del 0/1? ¿Por qué Greedy funciona aquí con ejemplos de código?", "input": "# Problema: Knapsack donde puedes tomar fracciones de items items = [ (60, 10), # (valor, peso) (100, 20), (120, 30) ] capacity = 50 # En 0/1 Knapsack necesitábamos DP, ¿por qué aquí podemos usar Greedy?", "output": "La diferencia clave en Fractional Knapsack puedes tomar fracciones de items, lo que permite una estrategia voraz basada en valor por unidad de peso. Implementación Greedy para Fractional Knapsack def fractional_knapsack(items, capacity) Calcular valor por peso y ordenar descendentemente items_with_ratio for value, weight in items items_with_ratio. append((value, weight, value weight)) Ordenar por ratio descendente (greedy choice) items_sorted sorted(items_with_ratio, keylambda x x2, reverseTrue) total_value 0 remaining_capacity capacity taken Para mostrar qué se tomó for value, weight, ratio in items_sorted if remaining_capacity weight Tomar el item completo total_value value remaining_capacity - weight taken. append((value, weight, 1.0)) 100 del item else Tomar fracción del item fraction remaining_capacity weight total_value value fraction taken. append((value, weight, fraction)) remaining_capacity 0 break return total_value, taken Versión detallada con explicación def fractional_knapsack_detailed(items, capacity) print(Items disponibles) items_data for i, (value, weight) in enumerate(items) ratio value weight items_data. append((i, value, weight, ratio)) print(fItem i valorvalue, pesoweight, ratioratio.2f) items_sorted sorted(items_data, keylambda x x3, reverseTrue) print(fnOrden greedy (por ratio) x0 for x in items_sorted) total_value 0 remaining capacity print(fnCapacidad inicial capacity) for idx, value, weight, ratio in items_sorted if remaining weight print(fTomar 100 del item idx (valorvalue, pesoweight)) total_value value remaining - weight elif remaining 0 fraction remaining weight partial_value value fraction print(fTomar fraction100.1f del item idx (valorpartial_value.2f)) total_value partial_value remaining 0 return total_value items (60, 10), (100, 20), (120, 30) value, details fractional_knapsack(items, 50) print(fnValor máximo value) print(fDetalles details) ¿Por qué Greedy funciona aquí pero no en 01 Knapsack? 1. Fractional Knapsack - Propiedad Puedes tomar fracciones - Estrategia Ordenar por valorpeso y tomar lo mejor primero - Complejidad O(n log n) - Greedy da solución óptima SIEMPRE 2. 01 Knapsack - Restricción Todo o nada por item - Greedy NO funciona (contraejemplo items(10,5), (60,20), (100,30), capacity50) - Necesita DP O(n capacity) - Greedy puede dar soluciones subóptimas Complejidad - Tiempo O(n log n) por el ordenamiento - Espacio O(n) Este es un ejemplo perfecto de cómo cambiar ligeramente las restricciones del problema puede cambiar la estrategia óptima de DP a Greedy."}
{"id": "c73d56b3d2", "mode": "general", "instruction": "¿En qué se diferencia el Knapsack Fraccionario (Fractional Knapsack) del 0/1? ¿Por qué Greedy funciona aquí paso a paso?", "input": "# Problema: Knapsack donde puedes tomar fracciones de items items = [ (60, 10), # (valor, peso) (100, 20), (120, 30) ] capacity = 50 # En 0/1 Knapsack necesitábamos DP, ¿por qué aquí podemos usar Greedy?", "output": "La diferencia clave en Fractional Knapsack puedes tomar fracciones de items, lo que permite una estrategia voraz basada en valor por unidad de peso. Implementación Greedy para Fractional Knapsack def fractional_knapsack(items, capacity) Calcular valor por peso y ordenar descendentemente items_with_ratio for value, weight in items items_with_ratio. append((value, weight, value weight)) Ordenar por ratio descendente (greedy choice) items_sorted sorted(items_with_ratio, keylambda x x2, reverseTrue) total_value 0 remaining_capacity capacity taken Para mostrar qué se tomó for value, weight, ratio in items_sorted if remaining_capacity weight Tomar el item completo total_value value remaining_capacity - weight taken. append((value, weight, 1.0)) 100 del item else Tomar fracción del item fraction remaining_capacity weight total_value value fraction taken. append((value, weight, fraction)) remaining_capacity 0 break return total_value, taken Versión detallada con explicación def fractional_knapsack_detailed(items, capacity) print(Items disponibles) items_data for i, (value, weight) in enumerate(items) ratio value weight items_data. append((i, value, weight, ratio)) print(fItem i valorvalue, pesoweight, ratioratio.2f) items_sorted sorted(items_data, keylambda x x3, reverseTrue) print(fnOrden greedy (por ratio) x0 for x in items_sorted) total_value 0 remaining capacity print(fnCapacidad inicial capacity) for idx, value, weight, ratio in items_sorted if remaining weight print(fTomar 100 del item idx (valorvalue, pesoweight)) total_value value remaining - weight elif remaining 0 fraction remaining weight partial_value value fraction print(fTomar fraction100.1f del item idx (valorpartial_value.2f)) total_value partial_value remaining 0 return total_value items (60, 10), (100, 20), (120, 30) value, details fractional_knapsack(items, 50) print(fnValor máximo value) print(fDetalles details) ¿Por qué Greedy funciona aquí pero no en 01 Knapsack? 1. Fractional Knapsack - Propiedad Puedes tomar fracciones - Estrategia Ordenar por valorpeso y tomar lo mejor primero - Complejidad O(n log n) - Greedy da solución óptima SIEMPRE 2. 01 Knapsack - Restricción Todo o nada por item - Greedy NO funciona (contraejemplo items(10,5), (60,20), (100,30), capacity50) - Necesita DP O(n capacity) - Greedy puede dar soluciones subóptimas Complejidad - Tiempo O(n log n) por el ordenamiento - Espacio O(n) Este es un ejemplo perfecto de cómo cambiar ligeramente las restricciones del problema puede cambiar la estrategia óptima de DP a Greedy."}
{"id": "a1efd84124", "mode": "general", "instruction": "¿Cómo funciona el algoritmo Greedy de Huffman Coding? Explica la estrategia voraz para compresión de datos.", "input": "# Problema: Asignar códigos binarios a caracteres para minimizar longitud total characters = ['a', 'b', 'c', 'd', 'e', 'f'] frequencies = [5, 9, 12, 13, 16, 45] # ¿Cómo asignar códigos eficientemente?", "output": "Huffman Coding usa una estrategia greedy para crear códigos de longitud variable óptimos caracteres frecuentes reciben códigos cortos. Implementación del algoritmo de Huffman import heapq from collections import defaultdict class Node def __init__(self, char, freq, leftNone, rightNone) self. char char self. freq freq self. left left self. right right def __lt__(self, other) return self. freq other. freq def huffman_coding(characters, frequencies) Crear heap con nodos individuales (estrategia greedy min-heap) heap for char, freq in zip(characters, frequencies) heapq. heappush(heap, Node(char, freq)) Construir árbol de Huffman (combinar nodos de menor frecuencia) while len(heap) 1 Tomar dos nodos con menor frecuencia (greedy choice) left heapq. heappop(heap) right heapq. heappop(heap) Crear nodo padre con frecuencia combinada merged Node(None, left. freq right. freq, left, right) heapq. heappush(heap, merged) El último nodo es la raíz root heap0 Generar códigos recorriendo el árbol codes def generate_codes(node, current_code) if node is None return Nodo hoja asignar código if node. char is not None codesnode. char current_code if current_code else 0 return Recorrer izquierda (agregar 0) y derecha (agregar 1) generate_codes(node. left, current_code 0) generate_codes(node. right, current_code 1) generate_codes(root, ) return codes Función completa con análisis def huffman_analysis(characters, frequencies) codes huffman_coding(characters, frequencies) print(Códigos de Huffman) total_bits 0 for char, freq in zip(characters, frequencies) code codeschar bits len(code) freq total_bits bits print(fchar code (freqfreq, bitslen(code), totalbits)) Comparar con código de longitud fija import math fixed_length math. ceil(math. log2(len(characters))) fixed_total sum(frequencies) fixed_length print(fnBits con Huffman total_bits) print(fBits con código fijo (fixed_length bitschar) fixed_total) print(fCompresión (1 - total_bitsfixed_total) 100.1f) return codes characters a, b, c, d, e, f frequencies 5, 9, 12, 13, 16, 45 codes huffman_analysis(characters, frequencies) Estrategia Greedy 1. Siempre combinar los dos nodos con menor frecuencia 2. Esto garantiza que caracteres frecuentes estén más cerca de la raíz 3. Caracteres cerca de la raíz tienen códigos más cortos ¿Por qué es óptimo? - Propiedad greedy Combinar nodos de menor frecuencia minimiza el costo total - Subestructura óptima Un árbol óptimo contiene subárboles óptimos - Complejidad O(n log n) por operaciones de heap Resultado típico - f (freq45) código corto como 0 - a (freq5) código largo como 1100 - Ahorro significativo vs código de longitud fija"}
{"id": "3fadf6592e", "mode": "general", "instruction": "Explícame cómo trabaja el algoritmo Greedy de Huffman Coding? Explica la estrategia voraz para compresión de datos.", "input": "# Problema: Asignar códigos binarios a caracteres para minimizar longitud total characters = ['a', 'b', 'c', 'd', 'e', 'f'] frequencies = [5, 9, 12, 13, 16, 45] # ¿Cómo asignar códigos eficientemente?", "output": "Huffman Coding usa una estrategia greedy para crear códigos de longitud variable óptimos caracteres frecuentes reciben códigos cortos. Implementación del algoritmo de Huffman import heapq from collections import defaultdict class Node def __init__(self, char, freq, leftNone, rightNone) self. char char self. freq freq self. left left self. right right def __lt__(self, other) return self. freq other. freq def huffman_coding(characters, frequencies) Crear heap con nodos individuales (estrategia greedy min-heap) heap for char, freq in zip(characters, frequencies) heapq. heappush(heap, Node(char, freq)) Construir árbol de Huffman (combinar nodos de menor frecuencia) while len(heap) 1 Tomar dos nodos con menor frecuencia (greedy choice) left heapq. heappop(heap) right heapq. heappop(heap) Crear nodo padre con frecuencia combinada merged Node(None, left. freq right. freq, left, right) heapq. heappush(heap, merged) El último nodo es la raíz root heap0 Generar códigos recorriendo el árbol codes def generate_codes(node, current_code) if node is None return Nodo hoja asignar código if node. char is not None codesnode. char current_code if current_code else 0 return Recorrer izquierda (agregar 0) y derecha (agregar 1) generate_codes(node. left, current_code 0) generate_codes(node. right, current_code 1) generate_codes(root, ) return codes Función completa con análisis def huffman_analysis(characters, frequencies) codes huffman_coding(characters, frequencies) print(Códigos de Huffman) total_bits 0 for char, freq in zip(characters, frequencies) code codeschar bits len(code) freq total_bits bits print(fchar code (freqfreq, bitslen(code), totalbits)) Comparar con código de longitud fija import math fixed_length math. ceil(math. log2(len(characters))) fixed_total sum(frequencies) fixed_length print(fnBits con Huffman total_bits) print(fBits con código fijo (fixed_length bitschar) fixed_total) print(fCompresión (1 - total_bitsfixed_total) 100.1f) return codes characters a, b, c, d, e, f frequencies 5, 9, 12, 13, 16, 45 codes huffman_analysis(characters, frequencies) Estrategia Greedy 1. Siempre combinar los dos nodos con menor frecuencia 2. Esto garantiza que caracteres frecuentes estén más cerca de la raíz 3. Caracteres cerca de la raíz tienen códigos más cortos ¿Por qué es óptimo? - Propiedad greedy Combinar nodos de menor frecuencia minimiza el costo total - Subestructura óptima Un árbol óptimo contiene subárboles óptimos - Complejidad O(n log n) por operaciones de heap Resultado típico - f (freq45) código corto como 0 - a (freq5) código largo como 1100 - Ahorro significativo vs código de longitud fija"}
{"id": "3f09721d0b", "mode": "general", "instruction": "¿Cuál es el funcionamiento de el algoritmo Greedy de Huffman Coding? Explica la estrategia voraz para compresión de datos.", "input": "# Problema: Asignar códigos binarios a caracteres para minimizar longitud total characters = ['a', 'b', 'c', 'd', 'e', 'f'] frequencies = [5, 9, 12, 13, 16, 45] # ¿Cómo asignar códigos eficientemente?", "output": "Huffman Coding usa una estrategia greedy para crear códigos de longitud variable óptimos caracteres frecuentes reciben códigos cortos. Implementación del algoritmo de Huffman import heapq from collections import defaultdict class Node def __init__(self, char, freq, leftNone, rightNone) self. char char self. freq freq self. left left self. right right def __lt__(self, other) return self. freq other. freq def huffman_coding(characters, frequencies) Crear heap con nodos individuales (estrategia greedy min-heap) heap for char, freq in zip(characters, frequencies) heapq. heappush(heap, Node(char, freq)) Construir árbol de Huffman (combinar nodos de menor frecuencia) while len(heap) 1 Tomar dos nodos con menor frecuencia (greedy choice) left heapq. heappop(heap) right heapq. heappop(heap) Crear nodo padre con frecuencia combinada merged Node(None, left. freq right. freq, left, right) heapq. heappush(heap, merged) El último nodo es la raíz root heap0 Generar códigos recorriendo el árbol codes def generate_codes(node, current_code) if node is None return Nodo hoja asignar código if node. char is not None codesnode. char current_code if current_code else 0 return Recorrer izquierda (agregar 0) y derecha (agregar 1) generate_codes(node. left, current_code 0) generate_codes(node. right, current_code 1) generate_codes(root, ) return codes Función completa con análisis def huffman_analysis(characters, frequencies) codes huffman_coding(characters, frequencies) print(Códigos de Huffman) total_bits 0 for char, freq in zip(characters, frequencies) code codeschar bits len(code) freq total_bits bits print(fchar code (freqfreq, bitslen(code), totalbits)) Comparar con código de longitud fija import math fixed_length math. ceil(math. log2(len(characters))) fixed_total sum(frequencies) fixed_length print(fnBits con Huffman total_bits) print(fBits con código fijo (fixed_length bitschar) fixed_total) print(fCompresión (1 - total_bitsfixed_total) 100.1f) return codes characters a, b, c, d, e, f frequencies 5, 9, 12, 13, 16, 45 codes huffman_analysis(characters, frequencies) Estrategia Greedy 1. Siempre combinar los dos nodos con menor frecuencia 2. Esto garantiza que caracteres frecuentes estén más cerca de la raíz 3. Caracteres cerca de la raíz tienen códigos más cortos ¿Por qué es óptimo? - Propiedad greedy Combinar nodos de menor frecuencia minimiza el costo total - Subestructura óptima Un árbol óptimo contiene subárboles óptimos - Complejidad O(n log n) por operaciones de heap Resultado típico - f (freq45) código corto como 0 - a (freq5) código largo como 1100 - Ahorro significativo vs código de longitud fija"}
{"id": "f3250308c1", "mode": "general", "instruction": "¿Cómo funciona el algoritmo Greedy de Huffman Coding? Explica la estrategia voraz para compresión de datos. con ejemplos de código?", "input": "# Problema: Asignar códigos binarios a caracteres para minimizar longitud total characters = ['a', 'b', 'c', 'd', 'e', 'f'] frequencies = [5, 9, 12, 13, 16, 45] # ¿Cómo asignar códigos eficientemente?", "output": "Huffman Coding usa una estrategia greedy para crear códigos de longitud variable óptimos caracteres frecuentes reciben códigos cortos. Implementación del algoritmo de Huffman import heapq from collections import defaultdict class Node def __init__(self, char, freq, leftNone, rightNone) self. char char self. freq freq self. left left self. right right def __lt__(self, other) return self. freq other. freq def huffman_coding(characters, frequencies) Crear heap con nodos individuales (estrategia greedy min-heap) heap for char, freq in zip(characters, frequencies) heapq. heappush(heap, Node(char, freq)) Construir árbol de Huffman (combinar nodos de menor frecuencia) while len(heap) 1 Tomar dos nodos con menor frecuencia (greedy choice) left heapq. heappop(heap) right heapq. heappop(heap) Crear nodo padre con frecuencia combinada merged Node(None, left. freq right. freq, left, right) heapq. heappush(heap, merged) El último nodo es la raíz root heap0 Generar códigos recorriendo el árbol codes def generate_codes(node, current_code) if node is None return Nodo hoja asignar código if node. char is not None codesnode. char current_code if current_code else 0 return Recorrer izquierda (agregar 0) y derecha (agregar 1) generate_codes(node. left, current_code 0) generate_codes(node. right, current_code 1) generate_codes(root, ) return codes Función completa con análisis def huffman_analysis(characters, frequencies) codes huffman_coding(characters, frequencies) print(Códigos de Huffman) total_bits 0 for char, freq in zip(characters, frequencies) code codeschar bits len(code) freq total_bits bits print(fchar code (freqfreq, bitslen(code), totalbits)) Comparar con código de longitud fija import math fixed_length math. ceil(math. log2(len(characters))) fixed_total sum(frequencies) fixed_length print(fnBits con Huffman total_bits) print(fBits con código fijo (fixed_length bitschar) fixed_total) print(fCompresión (1 - total_bitsfixed_total) 100.1f) return codes characters a, b, c, d, e, f frequencies 5, 9, 12, 13, 16, 45 codes huffman_analysis(characters, frequencies) Estrategia Greedy 1. Siempre combinar los dos nodos con menor frecuencia 2. Esto garantiza que caracteres frecuentes estén más cerca de la raíz 3. Caracteres cerca de la raíz tienen códigos más cortos ¿Por qué es óptimo? - Propiedad greedy Combinar nodos de menor frecuencia minimiza el costo total - Subestructura óptima Un árbol óptimo contiene subárboles óptimos - Complejidad O(n log n) por operaciones de heap Resultado típico - f (freq45) código corto como 0 - a (freq5) código largo como 1100 - Ahorro significativo vs código de longitud fija"}
{"id": "fd6b7a3137", "mode": "general", "instruction": "¿Cómo funciona el algoritmo Greedy de Huffman Coding? Explica la estrategia voraz para compresión de datos. paso a paso?", "input": "# Problema: Asignar códigos binarios a caracteres para minimizar longitud total characters = ['a', 'b', 'c', 'd', 'e', 'f'] frequencies = [5, 9, 12, 13, 16, 45] # ¿Cómo asignar códigos eficientemente?", "output": "Huffman Coding usa una estrategia greedy para crear códigos de longitud variable óptimos caracteres frecuentes reciben códigos cortos. Implementación del algoritmo de Huffman import heapq from collections import defaultdict class Node def __init__(self, char, freq, leftNone, rightNone) self. char char self. freq freq self. left left self. right right def __lt__(self, other) return self. freq other. freq def huffman_coding(characters, frequencies) Crear heap con nodos individuales (estrategia greedy min-heap) heap for char, freq in zip(characters, frequencies) heapq. heappush(heap, Node(char, freq)) Construir árbol de Huffman (combinar nodos de menor frecuencia) while len(heap) 1 Tomar dos nodos con menor frecuencia (greedy choice) left heapq. heappop(heap) right heapq. heappop(heap) Crear nodo padre con frecuencia combinada merged Node(None, left. freq right. freq, left, right) heapq. heappush(heap, merged) El último nodo es la raíz root heap0 Generar códigos recorriendo el árbol codes def generate_codes(node, current_code) if node is None return Nodo hoja asignar código if node. char is not None codesnode. char current_code if current_code else 0 return Recorrer izquierda (agregar 0) y derecha (agregar 1) generate_codes(node. left, current_code 0) generate_codes(node. right, current_code 1) generate_codes(root, ) return codes Función completa con análisis def huffman_analysis(characters, frequencies) codes huffman_coding(characters, frequencies) print(Códigos de Huffman) total_bits 0 for char, freq in zip(characters, frequencies) code codeschar bits len(code) freq total_bits bits print(fchar code (freqfreq, bitslen(code), totalbits)) Comparar con código de longitud fija import math fixed_length math. ceil(math. log2(len(characters))) fixed_total sum(frequencies) fixed_length print(fnBits con Huffman total_bits) print(fBits con código fijo (fixed_length bitschar) fixed_total) print(fCompresión (1 - total_bitsfixed_total) 100.1f) return codes characters a, b, c, d, e, f frequencies 5, 9, 12, 13, 16, 45 codes huffman_analysis(characters, frequencies) Estrategia Greedy 1. Siempre combinar los dos nodos con menor frecuencia 2. Esto garantiza que caracteres frecuentes estén más cerca de la raíz 3. Caracteres cerca de la raíz tienen códigos más cortos ¿Por qué es óptimo? - Propiedad greedy Combinar nodos de menor frecuencia minimiza el costo total - Subestructura óptima Un árbol óptimo contiene subárboles óptimos - Complejidad O(n log n) por operaciones de heap Resultado típico - f (freq45) código corto como 0 - a (freq5) código largo como 1100 - Ahorro significativo vs código de longitud fija"}
{"id": "1c57f33635", "mode": "general", "instruction": "¿Cómo resolver el problema de Edit Distance (Levenshtein Distance) eficientemente?", "input": "def edit_distance_recursive(str1, str2, m, n): # Caso base: cadena vacía if m == 0: return n if n == 0: return m # Si últimos caracteres son iguales, ignorar if str1[m - 1] == str2[n - 1]: return edit_distance_recursive(str1, str2, m - 1, n - 1) # Probar todas las operaciones: insert, delete, replace return 1 + min( edit_distance_recursive(str1, str2, m, n - 1), # Insert edit_distance_recursive(str1, str2, m - 1, n), # Delete edit_distance_recursive(str1, str2, m - 1, n - 1) # Replace ) str1 = \"sunday\" str2 = \"saturday\" print(edit_distance_recursive(str1, str2, len(str1), len(str2)))", "output": "La solución recursiva tiene complejidad O(3max(m, n)) por probar 3 opciones en cada paso. Usaremos Programación Dinámica. Solución optimizada con Tabulation def edit_distance_dp(str1, str2) m len(str1) n len(str2) dpij edit distance entre str10.. i-1 y str20.. j-1 dp 0 for _ in range(n 1) for _ in range(m 1) Casos base convertir cadena vacía for i in range(m 1) dpi0 i Necesitas i deletes for j in range(n 1) dp0j j Necesitas j inserts Llenar tabla for i in range(1, m 1) for j in range(1, n 1) if str1i - 1 str2j - 1 Caracteres iguales no cuesta nada dpij dpi - 1j - 1 else Tomar mínimo de tres operaciones dpij 1 min( dpij - 1, Insert dpi - 1j, Delete dpi - 1j - 1 Replace ) return dpmn Versión con reconstrucción de operaciones def edit_distance_with_operations(str1, str2) m, n len(str1), len(str2) dp 0 (n 1) for _ in range(m 1) Llenar casos base for i in range(m 1) dpi0 i for j in range(n 1) dp0j j Llenar tabla for i in range(1, m 1) for j in range(1, n 1) if str1i - 1 str2j - 1 dpij dpi - 1j - 1 else dpij 1 min(dpij - 1, dpi - 1j, dpi - 1j - 1) Reconstruir secuencia de operaciones operations i, j m, n while i 0 or j 0 if i 0 operations. append(fInsert str2j-1 at position i) j - 1 elif j 0 operations. append(fDelete str1i-1 at position i-1) i - 1 elif str1i - 1 str2j - 1 i - 1 j - 1 else Encontrar qué operación fue usada costs dpij - 1 (insert, j - 1), dpi - 1j (delete, i - 1), dpi - 1j - 1 (replace, i - 1) min_cost min(costs. keys()) operation, pos costsmin_cost if operation insert operations. append(fInsert str2j-1 at position i) j - 1 elif operation delete operations. append(fDelete str1i-1 at position i-1) i - 1 else replace operations. append(fReplace str1i-1 with str2j-1 at position i-1) i - 1 j - 1 return dpmn, list(reversed(operations)) str1 sunday str2 saturday distance, ops edit_distance_with_operations(str1, str2) print(fEdit Distance distance) print(Operaciones) for op in ops print(f op) Análisis de complejidad - Recursiva O(3max(m, n)) - prácticamente imposible para strings 15 - DP O(m n) tiempo, O(m n) espacio - Para strings de 1000 caracteres de imposible a milisegundos Aplicaciones - Correctores ortográficos - Diff de archivos - Análisis de ADN - Fuzzy string matching"}
{"id": "5ad1eb3bfd", "mode": "general", "instruction": "¿Cómo resolver el problema de Edit Distance (Levenshtein Distance) eficientemente con ejemplos de código?", "input": "def edit_distance_recursive(str1, str2, m, n): # Caso base: cadena vacía if m == 0: return n if n == 0: return m # Si últimos caracteres son iguales, ignorar if str1[m - 1] == str2[n - 1]: return edit_distance_recursive(str1, str2, m - 1, n - 1) # Probar todas las operaciones: insert, delete, replace return 1 + min( edit_distance_recursive(str1, str2, m, n - 1), # Insert edit_distance_recursive(str1, str2, m - 1, n), # Delete edit_distance_recursive(str1, str2, m - 1, n - 1) # Replace ) str1 = \"sunday\" str2 = \"saturday\" print(edit_distance_recursive(str1, str2, len(str1), len(str2)))", "output": "La solución recursiva tiene complejidad O(3max(m, n)) por probar 3 opciones en cada paso. Usaremos Programación Dinámica. Solución optimizada con Tabulation def edit_distance_dp(str1, str2) m len(str1) n len(str2) dpij edit distance entre str10.. i-1 y str20.. j-1 dp 0 for _ in range(n 1) for _ in range(m 1) Casos base convertir cadena vacía for i in range(m 1) dpi0 i Necesitas i deletes for j in range(n 1) dp0j j Necesitas j inserts Llenar tabla for i in range(1, m 1) for j in range(1, n 1) if str1i - 1 str2j - 1 Caracteres iguales no cuesta nada dpij dpi - 1j - 1 else Tomar mínimo de tres operaciones dpij 1 min( dpij - 1, Insert dpi - 1j, Delete dpi - 1j - 1 Replace ) return dpmn Versión con reconstrucción de operaciones def edit_distance_with_operations(str1, str2) m, n len(str1), len(str2) dp 0 (n 1) for _ in range(m 1) Llenar casos base for i in range(m 1) dpi0 i for j in range(n 1) dp0j j Llenar tabla for i in range(1, m 1) for j in range(1, n 1) if str1i - 1 str2j - 1 dpij dpi - 1j - 1 else dpij 1 min(dpij - 1, dpi - 1j, dpi - 1j - 1) Reconstruir secuencia de operaciones operations i, j m, n while i 0 or j 0 if i 0 operations. append(fInsert str2j-1 at position i) j - 1 elif j 0 operations. append(fDelete str1i-1 at position i-1) i - 1 elif str1i - 1 str2j - 1 i - 1 j - 1 else Encontrar qué operación fue usada costs dpij - 1 (insert, j - 1), dpi - 1j (delete, i - 1), dpi - 1j - 1 (replace, i - 1) min_cost min(costs. keys()) operation, pos costsmin_cost if operation insert operations. append(fInsert str2j-1 at position i) j - 1 elif operation delete operations. append(fDelete str1i-1 at position i-1) i - 1 else replace operations. append(fReplace str1i-1 with str2j-1 at position i-1) i - 1 j - 1 return dpmn, list(reversed(operations)) str1 sunday str2 saturday distance, ops edit_distance_with_operations(str1, str2) print(fEdit Distance distance) print(Operaciones) for op in ops print(f op) Análisis de complejidad - Recursiva O(3max(m, n)) - prácticamente imposible para strings 15 - DP O(m n) tiempo, O(m n) espacio - Para strings de 1000 caracteres de imposible a milisegundos Aplicaciones - Correctores ortográficos - Diff de archivos - Análisis de ADN - Fuzzy string matching"}
{"id": "03ebba565f", "mode": "general", "instruction": "¿Cómo resolver el problema de Edit Distance (Levenshtein Distance) eficientemente paso a paso?", "input": "def edit_distance_recursive(str1, str2, m, n): # Caso base: cadena vacía if m == 0: return n if n == 0: return m # Si últimos caracteres son iguales, ignorar if str1[m - 1] == str2[n - 1]: return edit_distance_recursive(str1, str2, m - 1, n - 1) # Probar todas las operaciones: insert, delete, replace return 1 + min( edit_distance_recursive(str1, str2, m, n - 1), # Insert edit_distance_recursive(str1, str2, m - 1, n), # Delete edit_distance_recursive(str1, str2, m - 1, n - 1) # Replace ) str1 = \"sunday\" str2 = \"saturday\" print(edit_distance_recursive(str1, str2, len(str1), len(str2)))", "output": "La solución recursiva tiene complejidad O(3max(m, n)) por probar 3 opciones en cada paso. Usaremos Programación Dinámica. Solución optimizada con Tabulation def edit_distance_dp(str1, str2) m len(str1) n len(str2) dpij edit distance entre str10.. i-1 y str20.. j-1 dp 0 for _ in range(n 1) for _ in range(m 1) Casos base convertir cadena vacía for i in range(m 1) dpi0 i Necesitas i deletes for j in range(n 1) dp0j j Necesitas j inserts Llenar tabla for i in range(1, m 1) for j in range(1, n 1) if str1i - 1 str2j - 1 Caracteres iguales no cuesta nada dpij dpi - 1j - 1 else Tomar mínimo de tres operaciones dpij 1 min( dpij - 1, Insert dpi - 1j, Delete dpi - 1j - 1 Replace ) return dpmn Versión con reconstrucción de operaciones def edit_distance_with_operations(str1, str2) m, n len(str1), len(str2) dp 0 (n 1) for _ in range(m 1) Llenar casos base for i in range(m 1) dpi0 i for j in range(n 1) dp0j j Llenar tabla for i in range(1, m 1) for j in range(1, n 1) if str1i - 1 str2j - 1 dpij dpi - 1j - 1 else dpij 1 min(dpij - 1, dpi - 1j, dpi - 1j - 1) Reconstruir secuencia de operaciones operations i, j m, n while i 0 or j 0 if i 0 operations. append(fInsert str2j-1 at position i) j - 1 elif j 0 operations. append(fDelete str1i-1 at position i-1) i - 1 elif str1i - 1 str2j - 1 i - 1 j - 1 else Encontrar qué operación fue usada costs dpij - 1 (insert, j - 1), dpi - 1j (delete, i - 1), dpi - 1j - 1 (replace, i - 1) min_cost min(costs. keys()) operation, pos costsmin_cost if operation insert operations. append(fInsert str2j-1 at position i) j - 1 elif operation delete operations. append(fDelete str1i-1 at position i-1) i - 1 else replace operations. append(fReplace str1i-1 with str2j-1 at position i-1) i - 1 j - 1 return dpmn, list(reversed(operations)) str1 sunday str2 saturday distance, ops edit_distance_with_operations(str1, str2) print(fEdit Distance distance) print(Operaciones) for op in ops print(f op) Análisis de complejidad - Recursiva O(3max(m, n)) - prácticamente imposible para strings 15 - DP O(m n) tiempo, O(m n) espacio - Para strings de 1000 caracteres de imposible a milisegundos Aplicaciones - Correctores ortográficos - Diff de archivos - Análisis de ADN - Fuzzy string matching"}
{"id": "9f0a3a9b1f", "mode": "general", "instruction": "¿Cómo optimizar la multiplicación de cadenas de matrices (Matrix Chain) sin probar todas las combinaciones?", "input": "dims = [30, 35, 15, 5, 10, 20, 25] # 6 matrices, tamaños compatibles", "output": "usa programación dinámica para elegir dónde parentizar y minimizar multiplicaciones. Construye una tabla dpij con el costo mínimo de multiplicar de i a j, probando todos los cortes k entre i y j. Complejidad O(n3) tiempo, O(n2) espacio. Así evitas la explosión exponencial de probar todas las parentizaciones."}
{"id": "ffebf518e6", "mode": "general", "instruction": "¿Cómo optimizar la multiplicación de cadenas de matrices (Matrix Chain) sin probar todas las combinaciones con ejemplos de código?", "input": "dims = [30, 35, 15, 5, 10, 20, 25] # 6 matrices, tamaños compatibles", "output": "usa programación dinámica para elegir dónde parentizar y minimizar multiplicaciones. Construye una tabla dpij con el costo mínimo de multiplicar de i a j, probando todos los cortes k entre i y j. Complejidad O(n3) tiempo, O(n2) espacio. Así evitas la explosión exponencial de probar todas las parentizaciones."}
{"id": "a9d2908be2", "mode": "general", "instruction": "¿Cómo optimizar la multiplicación de cadenas de matrices (Matrix Chain) sin probar todas las combinaciones paso a paso?", "input": "dims = [30, 35, 15, 5, 10, 20, 25] # 6 matrices, tamaños compatibles", "output": "usa programación dinámica para elegir dónde parentizar y minimizar multiplicaciones. Construye una tabla dpij con el costo mínimo de multiplicar de i a j, probando todos los cortes k entre i y j. Complejidad O(n3) tiempo, O(n2) espacio. Así evitas la explosión exponencial de probar todas las parentizaciones."}
{"id": "37e36114a2", "mode": "general", "instruction": "¿Cómo calcular la Longest Increasing Subsequence (LIS) en O(n log n)?", "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]", "output": "combina DP con búsqueda binaria (patience sorting). Mantén un arreglo tails donde tailslen es el menor final posible de una subsecuencia creciente de longitud len1. Para cada número, busca su posición con bisect_left y reemplaza. La longitud final de tails es la LIS. Complejidad O(n log n), espacio O(n)."}
{"id": "40af3170f3", "mode": "general", "instruction": "¿Cómo calcular la Longest Increasing Subsequence (LIS) en O(n log n) con ejemplos de código?", "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]", "output": "combina DP con búsqueda binaria (patience sorting). Mantén un arreglo tails donde tailslen es el menor final posible de una subsecuencia creciente de longitud len1. Para cada número, busca su posición con bisect_left y reemplaza. La longitud final de tails es la LIS. Complejidad O(n log n), espacio O(n)."}
{"id": "e22970fcfc", "mode": "general", "instruction": "¿Cómo calcular la Longest Increasing Subsequence (LIS) en O(n log n) paso a paso?", "input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]", "output": "combina DP con búsqueda binaria (patience sorting). Mantén un arreglo tails donde tailslen es el menor final posible de una subsecuencia creciente de longitud len1. Para cada número, busca su posición con bisect_left y reemplaza. La longitud final de tails es la LIS. Complejidad O(n log n), espacio O(n)."}
{"id": "ffbb0613e7", "mode": "general", "instruction": "¿Cómo puedo hacer este código más 'Pythonic' usando enumerate?", "input": "frutas = ['manzana', 'banana', 'uvas'] for i in range(len(frutas)): fruta = frutas[i] print(\"Índice:\", i, \"Fruta:\", fruta)", "output": "Estás usando un patrón muy común en CJava, pero en Python es innecesario acceder al índice manualmente para obtener el elemento. Usa enumerate(). Versión Pythonic python for i, fruta in enumerate(frutas) print(fÍndice i Fruta fruta) ¿Por qué es mejor? Es más limpio y eficiente porque enumerate retorna un iterador que te da el índice y el valor en tuplas, evitando el acceso costoso y repetitivo frutasi."}
{"id": "cb22a72e75", "mode": "general", "instruction": "¿Cómo puedo hacer este código más 'Pythonic' usando enumerate paso a paso?", "input": "frutas = ['manzana', 'banana', 'uvas'] for i in range(len(frutas)): fruta = frutas[i] print(\"Índice:\", i, \"Fruta:\", fruta)", "output": "Estás usando un patrón muy común en CJava, pero en Python es innecesario acceder al índice manualmente para obtener el elemento. Usa enumerate(). Versión Pythonic python for i, fruta in enumerate(frutas) print(fÍndice i Fruta fruta) ¿Por qué es mejor? Es más limpio y eficiente porque enumerate retorna un iterador que te da el índice y el valor en tuplas, evitando el acceso costoso y repetitivo frutasi."}
{"id": "e63f609673", "mode": "general", "instruction": "¿Cómo puedo hacer este código más 'Pythonic' para crear listas nuevas?", "input": "numeros = [1, 2, 3, 4, 5] cuadrados = [] for n in numeros: cuadrados. append(n * n)", "output": "Este patrón de crear lista vacía bucle append es el candidato perfecto para una List Comprehension. Versión Pythonic python cuadrados n n for n in numeros ¿Por qué es mejor? No solo es una línea en lugar de tres; internamente es más veloz porque la creación de la lista se optimiza a nivel de C, evitando las llamadas repetidas al método. append()."}
{"id": "d1e4f83751", "mode": "general", "instruction": "¿Cómo puedo hacer este código más 'Pythonic' para crear listas nuevas paso a paso?", "input": "numeros = [1, 2, 3, 4, 5] cuadrados = [] for n in numeros: cuadrados. append(n * n)", "output": "Este patrón de crear lista vacía bucle append es el candidato perfecto para una List Comprehension. Versión Pythonic python cuadrados n n for n in numeros ¿Por qué es mejor? No solo es una línea en lugar de tres; internamente es más veloz porque la creación de la lista se optimiza a nivel de C, evitando las llamadas repetidas al método. append()."}
{"id": "3d6dd00379", "mode": "general", "instruction": "¿Cómo puedo hacer este código más 'Pythonic' usando f-strings?", "input": "nombre = \"Ana\" edad = 25 print(\"Hola, mi nombre es \" + nombre + \" y tengo \" + str(edad) + \" años.\")", "output": "La concatenación con es propensa a errores (se te olvida un espacio o un str()) y es lenta porque crea múltiples strings intermedios. Usa f-strings (Python 3.6). Versión Pythonic python print(fHola, mi nombre es nombre y tengo edad años.) ¿Por qué es mejor? Es la forma más legible y performante de formatear texto en Python hoy en día."}
{"id": "f35b4e3daf", "mode": "general", "instruction": "¿Cómo puedo hacer este código más 'Pythonic' usando f-strings paso a paso?", "input": "nombre = \"Ana\" edad = 25 print(\"Hola, mi nombre es \" + nombre + \" y tengo \" + str(edad) + \" años.\")", "output": "La concatenación con es propensa a errores (se te olvida un espacio o un str()) y es lenta porque crea múltiples strings intermedios. Usa f-strings (Python 3.6). Versión Pythonic python print(fHola, mi nombre es nombre y tengo edad años.) ¿Por qué es mejor? Es la forma más legible y performante de formatear texto en Python hoy en día."}
{"id": "a5d1174b30", "mode": "general", "instruction": "¿Cómo puedo hacer este código más 'Pythonic' usando zip?", "input": "nombres = ['Ana', 'Luis', 'Marta'] edades = [25, 30, 22] for i in range(len(nombres)): print(nombres[i] + \" tiene \" + str(edades[i]))", "output": "Cuando necesites iterar dos o más listas en paralelo, evita usar índices. Usa zip(), que actúa como una cremallera uniendo elementos de la misma posición. Versión Pythonic python for nombre, edad in zip(nombres, edades) print(fnombre tiene edad) ¿Por qué es mejor? Elimina la necesidad de gestionar i, evita errores de índice fuera de rango (zip se detiene en la lista más corta) y es mucho más legible."}
{"id": "d033d4fdf6", "mode": "general", "instruction": "¿Cómo puedo hacer este código más 'Pythonic' usando zip paso a paso?", "input": "nombres = ['Ana', 'Luis', 'Marta'] edades = [25, 30, 22] for i in range(len(nombres)): print(nombres[i] + \" tiene \" + str(edades[i]))", "output": "Cuando necesites iterar dos o más listas en paralelo, evita usar índices. Usa zip(), que actúa como una cremallera uniendo elementos de la misma posición. Versión Pythonic python for nombre, edad in zip(nombres, edades) print(fnombre tiene edad) ¿Por qué es mejor? Elimina la necesidad de gestionar i, evita errores de índice fuera de rango (zip se detiene en la lista más corta) y es mucho más legible."}
{"id": "f55a7f37cf", "mode": "general", "instruction": "¿Cómo puedo hacer este código más 'Pythonic' para filtrar elementos?", "input": "numeros = [10, 5, 20, 3, 8] mayores_diez = [] for n in numeros: if n > 10: mayores_diez. append(n)", "output": "Nuevamente, las List Comprehensions brillan aquí, ya que admiten filtrado condicional. Versión Pythonic python mayores_diez n for n in numeros if n 10 ¿Por qué es mejor? Expresa la intención (quiero una lista de números tal que sean mayores a 10) de forma declarativa, en lugar de describir el procedimiento paso a paso."}
{"id": "6f6f745947", "mode": "general", "instruction": "¿Cómo puedo hacer este código más 'Pythonic' para filtrar elementos paso a paso?", "input": "numeros = [10, 5, 20, 3, 8] mayores_diez = [] for n in numeros: if n > 10: mayores_diez. append(n)", "output": "Nuevamente, las List Comprehensions brillan aquí, ya que admiten filtrado condicional. Versión Pythonic python mayores_diez n for n in numeros if n 10 ¿Por qué es mejor? Expresa la intención (quiero una lista de números tal que sean mayores a 10) de forma declarativa, en lugar de describir el procedimiento paso a paso."}
{"id": "2590ffb349", "mode": "general", "instruction": "¿Cómo puedo simplificar este intercambio de variables?", "input": "temp = a a = b b = temp", "output": "El clásico intercambio con variable temporal es necesario en muchos lenguajes, pero Python soporta Tuple Unpacking (desempaquetado de tuplas). Versión Pythonic python a, b b, a ¿Por qué es mejor? Es atómico, elegante y elimina la necesidad de una variable temp que ensucia el namespace."}
{"id": "345ed0c2bd", "mode": "general", "instruction": "¿Cómo puedo simplificar este intercambio de variables con ejemplos de código?", "input": "temp = a a = b b = temp", "output": "El clásico intercambio con variable temporal es necesario en muchos lenguajes, pero Python soporta Tuple Unpacking (desempaquetado de tuplas). Versión Pythonic python a, b b, a ¿Por qué es mejor? Es atómico, elegante y elimina la necesidad de una variable temp que ensucia el namespace."}
{"id": "cc4c40970b", "mode": "general", "instruction": "¿Cómo puedo simplificar este intercambio de variables paso a paso?", "input": "temp = a a = b b = temp", "output": "El clásico intercambio con variable temporal es necesario en muchos lenguajes, pero Python soporta Tuple Unpacking (desempaquetado de tuplas). Versión Pythonic python a, b b, a ¿Por qué es mejor? Es atómico, elegante y elimina la necesidad de una variable temp que ensucia el namespace."}
{"id": "bcaedab22f", "mode": "general", "instruction": "¿Cómo mejorar la creación de un diccionario a partir de dos listas?", "input": "keys = ['a', 'b', 'c'] values = [1, 2, 3] mi_dict = {} for i in range(len(keys)): mi_dict[keys[i]] = values[i]", "output": "Puedes combinar el constructor dict() con zip() para hacer esto en una sola línea. Versión Pythonic python mi_dict dict(zip(keys, values)) ¿Por qué es mejor? Es extremadamente rápido y directo. zip genera pares (tuplas) y dict sabe exactamente cómo convertir una secuencia de pares clave-valor en un diccionario."}
{"id": "5294d37c25", "mode": "general", "instruction": "¿Cómo mejorar la creación de un diccionario a partir de dos listas con ejemplos de código?", "input": "keys = ['a', 'b', 'c'] values = [1, 2, 3] mi_dict = {} for i in range(len(keys)): mi_dict[keys[i]] = values[i]", "output": "Puedes combinar el constructor dict() con zip() para hacer esto en una sola línea. Versión Pythonic python mi_dict dict(zip(keys, values)) ¿Por qué es mejor? Es extremadamente rápido y directo. zip genera pares (tuplas) y dict sabe exactamente cómo convertir una secuencia de pares clave-valor en un diccionario."}
{"id": "a1a89a65cf", "mode": "general", "instruction": "¿Cómo mejorar la creación de un diccionario a partir de dos listas paso a paso?", "input": "keys = ['a', 'b', 'c'] values = [1, 2, 3] mi_dict = {} for i in range(len(keys)): mi_dict[keys[i]] = values[i]", "output": "Puedes combinar el constructor dict() con zip() para hacer esto en una sola línea. Versión Pythonic python mi_dict dict(zip(keys, values)) ¿Por qué es mejor? Es extremadamente rápido y directo. zip genera pares (tuplas) y dict sabe exactamente cómo convertir una secuencia de pares clave-valor en un diccionario."}
{"id": "0f6ebc329c", "mode": "general", "instruction": "¿Cómo hacer más 'Pythonic' la lectura de archivos?", "input": "f = open('datos. txt', 'r') contenido = f. read() print(contenido) f. close()", "output": "Si tu programa falla antes de llegar a f. close(), el archivo queda abierto (fuga de recursos). Usa un Context Manager (with). Versión Pythonic python with open(datos. txt, r) as f contenido f. read() print(contenido) El archivo se cierra aquí automáticamente, pase lo que pase. ¿Por qué es mejor? Garantiza que los recursos se liberen correctamente incluso si ocurren excepciones dentro del bloque."}
{"id": "37ff0e632e", "mode": "general", "instruction": "¿Cómo hacer más 'Pythonic' la lectura de archivos con ejemplos de código?", "input": "f = open('datos. txt', 'r') contenido = f. read() print(contenido) f. close()", "output": "Si tu programa falla antes de llegar a f. close(), el archivo queda abierto (fuga de recursos). Usa un Context Manager (with). Versión Pythonic python with open(datos. txt, r) as f contenido f. read() print(contenido) El archivo se cierra aquí automáticamente, pase lo que pase. ¿Por qué es mejor? Garantiza que los recursos se liberen correctamente incluso si ocurren excepciones dentro del bloque."}
{"id": "6fa599cf34", "mode": "general", "instruction": "¿Cómo hacer más 'Pythonic' la lectura de archivos paso a paso?", "input": "f = open('datos. txt', 'r') contenido = f. read() print(contenido) f. close()", "output": "Si tu programa falla antes de llegar a f. close(), el archivo queda abierto (fuga de recursos). Usa un Context Manager (with). Versión Pythonic python with open(datos. txt, r) as f contenido f. read() print(contenido) El archivo se cierra aquí automáticamente, pase lo que pase. ¿Por qué es mejor? Garantiza que los recursos se liberen correctamente incluso si ocurren excepciones dentro del bloque."}
{"id": "c1cf66fc48", "mode": "general", "instruction": "¿Cómo puedo evitar if/else anidados para verificar condiciones simples?", "input": "edad = 20 if edad >= 18: status = \"Adulto\" else: status = \"Menor\"", "output": "Para asignaciones simples condicionales, usa el Operador Ternario de Python. Versión Pythonic python status Adulto if edad 18 else Menor ¿Por qué es mejor? Mantiene la asignación en una sola línea lógica, facilitando la lectura cuando la lógica no es compleja."}
{"id": "892e9b3440", "mode": "general", "instruction": "¿Cómo puedo evitar if/else anidados para verificar condiciones simples con ejemplos de código?", "input": "edad = 20 if edad >= 18: status = \"Adulto\" else: status = \"Menor\"", "output": "Para asignaciones simples condicionales, usa el Operador Ternario de Python. Versión Pythonic python status Adulto if edad 18 else Menor ¿Por qué es mejor? Mantiene la asignación en una sola línea lógica, facilitando la lectura cuando la lógica no es compleja."}
{"id": "c5df6cda1d", "mode": "general", "instruction": "¿Cómo puedo evitar if/else anidados para verificar condiciones simples paso a paso?", "input": "edad = 20 if edad >= 18: status = \"Adulto\" else: status = \"Menor\"", "output": "Para asignaciones simples condicionales, usa el Operador Ternario de Python. Versión Pythonic python status Adulto if edad 18 else Menor ¿Por qué es mejor? Mantiene la asignación en una sola línea lógica, facilitando la lectura cuando la lógica no es compleja."}
{"id": "25dffdd38f", "mode": "general", "instruction": "¿Cómo iterar sobre un diccionario de forma elegante?", "input": "mi_dict = {'a': 1, 'b': 2} for key in mi_dict: val = mi_dict[key] print(key, val)", "output": "Aunque iterar sobre el diccionario te da las claves por defecto, acceder al valor con mi_dictkey es redundante. Usa. items(). Versión Pythonic python for key, val in mi_dict. items() print(fkey val) ¿Por qué es mejor? Obtienes clave y valor simultáneamente, haciendo el código más claro y evitando búsquedas adicionales en la tabla hash."}
{"id": "095d8040a0", "mode": "general", "instruction": "¿Cómo iterar sobre un diccionario de forma elegante con ejemplos de código?", "input": "mi_dict = {'a': 1, 'b': 2} for key in mi_dict: val = mi_dict[key] print(key, val)", "output": "Aunque iterar sobre el diccionario te da las claves por defecto, acceder al valor con mi_dictkey es redundante. Usa. items(). Versión Pythonic python for key, val in mi_dict. items() print(fkey val) ¿Por qué es mejor? Obtienes clave y valor simultáneamente, haciendo el código más claro y evitando búsquedas adicionales en la tabla hash."}
{"id": "218278f8d7", "mode": "general", "instruction": "¿Cómo iterar sobre un diccionario de forma elegante paso a paso?", "input": "mi_dict = {'a': 1, 'b': 2} for key in mi_dict: val = mi_dict[key] print(key, val)", "output": "Aunque iterar sobre el diccionario te da las claves por defecto, acceder al valor con mi_dictkey es redundante. Usa. items(). Versión Pythonic python for key, val in mi_dict. items() print(fkey val) ¿Por qué es mejor? Obtienes clave y valor simultáneamente, haciendo el código más claro y evitando búsquedas adicionales en la tabla hash."}
{"id": "7793d059b6", "mode": "general", "instruction": "¿Cuándo conviene usar el operador walrus (:=) para simplificar código?", "input": "line = input() while line!= '': print(line) line = input()", "output": "el walrus evita duplicar lecturas o cálculos. Puedes escribir python while (line input()) print(line) Lees y evalúas en la misma expresión, manteniendo el bucle compacto y legible."}
{"id": "571fb05b49", "mode": "general", "instruction": "¿Cuándo conviene usar el operador walrus (:=) para simplificar código paso a paso?", "input": "line = input() while line!= '': print(line) line = input()", "output": "el walrus evita duplicar lecturas o cálculos. Puedes escribir python while (line input()) print(line) Lees y evalúas en la misma expresión, manteniendo el bucle compacto y legible."}
{"id": "9320c94423", "mode": "general", "instruction": "¿Por qué es mejor usar pathlib y context manager al leer archivos?", "input": "f = open('data. txt'); data = f. read(); f. close()", "output": "pathlib hace el código más declarativo y el context manager asegura cierre aunque falle algo. python from pathlib import Path path Path(data. txt) with path. open() as f data f. read() Menos fugas de recursos y paths manejables multiplataforma."}
{"id": "94a4b55637", "mode": "general", "instruction": "¿Por qué es mejor usar pathlib y context manager al leer archivos con ejemplos de código?", "input": "f = open('data. txt'); data = f. read(); f. close()", "output": "pathlib hace el código más declarativo y el context manager asegura cierre aunque falle algo. python from pathlib import Path path Path(data. txt) with path. open() as f data f. read() Menos fugas de recursos y paths manejables multiplataforma."}
{"id": "cbd0bd5577", "mode": "general", "instruction": "¿Por qué es mejor usar pathlib y context manager al leer archivos paso a paso?", "input": "f = open('data. txt'); data = f. read(); f. close()", "output": "pathlib hace el código más declarativo y el context manager asegura cierre aunque falle algo. python from pathlib import Path path Path(data. txt) with path. open() as f data f. read() Menos fugas de recursos y paths manejables multiplataforma."}
{"id": "70fc372483", "mode": "general", "instruction": "Analiza la complejidad temporal y espacial de esta implementación de QuickSort.", "input": "def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)", "output": "Esta implementación de QuickSort tiene las siguientes características de complejidad Complejidad Temporal - Mejor caso O(n log n) cuando el pivote divide el arreglo en partes aproximadamente iguales. - Caso promedio O(n log n) con una buena selección de pivote. - Peor caso O(n²) cuando el pivote siempre es el elemento más pequeño o más grande. Complejidad Espacial O(n) debido a la creación de tres nuevas listas (left, middle, right) en cada llamada recursiva. Además, la profundidad de la recursión añade O(log n) en el mejor caso y O(n) en el peor caso. Esta implementación sacrifica eficiencia espacial por legibilidad, ya que crea copias de los datos en lugar de hacer ordenamiento in-place."}
{"id": "d407992135", "mode": "general", "instruction": "Analiza la complejidad temporal y espacial de esta implementación de QuickSort. con ejemplos de código?", "input": "def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)", "output": "Esta implementación de QuickSort tiene las siguientes características de complejidad Complejidad Temporal - Mejor caso O(n log n) cuando el pivote divide el arreglo en partes aproximadamente iguales. - Caso promedio O(n log n) con una buena selección de pivote. - Peor caso O(n²) cuando el pivote siempre es el elemento más pequeño o más grande. Complejidad Espacial O(n) debido a la creación de tres nuevas listas (left, middle, right) en cada llamada recursiva. Además, la profundidad de la recursión añade O(log n) en el mejor caso y O(n) en el peor caso. Esta implementación sacrifica eficiencia espacial por legibilidad, ya que crea copias de los datos en lugar de hacer ordenamiento in-place."}
{"id": "88d0f8a16d", "mode": "general", "instruction": "Analiza la complejidad temporal y espacial de esta implementación de QuickSort. paso a paso?", "input": "def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)", "output": "Esta implementación de QuickSort tiene las siguientes características de complejidad Complejidad Temporal - Mejor caso O(n log n) cuando el pivote divide el arreglo en partes aproximadamente iguales. - Caso promedio O(n log n) con una buena selección de pivote. - Peor caso O(n²) cuando el pivote siempre es el elemento más pequeño o más grande. Complejidad Espacial O(n) debido a la creación de tres nuevas listas (left, middle, right) en cada llamada recursiva. Además, la profundidad de la recursión añade O(log n) en el mejor caso y O(n) en el peor caso. Esta implementación sacrifica eficiencia espacial por legibilidad, ya que crea copias de los datos en lugar de hacer ordenamiento in-place."}
{"id": "a1a51167f3", "mode": "general", "instruction": "Compara la eficiencia de MergeSort y QuickSort. ¿Cuándo usarías cada uno?", "input": "def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[: mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result. append(left[i]) i += 1 else: result. append(right[j]) j += 1 result. extend(left[i:]) result. extend(right[j:]) return result", "output": "Comparación de complejidades MergeSort - Temporal O(n log n) en todos los casos (mejor, promedio y peor). - Espacial O(n) debido a los arreglos temporales durante el merge. - Ventaja Estable y predecible, garantiza O(n log n). QuickSort - Temporal O(n log n) promedio, O(n²) peor caso. - Espacial O(log n) con implementación in-place. - Ventaja Más rápido en la práctica por mejor localidad de caché. ¿Cuándo usar cada uno? - MergeSort Cuando necesitas estabilidad, trabajas con datos enlazados, o requieres garantía de O(n log n). - QuickSort Para arreglos en memoria con acceso aleatorio rápido, cuando el espacio es limitado y puedes tolerar O(n²) en casos raros."}
{"id": "7cc5e021b0", "mode": "general", "instruction": "Compara la eficiencia de MergeSort y QuickSort. ¿Cuándo usarías cada uno con ejemplos de código?", "input": "def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[: mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result. append(left[i]) i += 1 else: result. append(right[j]) j += 1 result. extend(left[i:]) result. extend(right[j:]) return result", "output": "Comparación de complejidades MergeSort - Temporal O(n log n) en todos los casos (mejor, promedio y peor). - Espacial O(n) debido a los arreglos temporales durante el merge. - Ventaja Estable y predecible, garantiza O(n log n). QuickSort - Temporal O(n log n) promedio, O(n²) peor caso. - Espacial O(log n) con implementación in-place. - Ventaja Más rápido en la práctica por mejor localidad de caché. ¿Cuándo usar cada uno? - MergeSort Cuando necesitas estabilidad, trabajas con datos enlazados, o requieres garantía de O(n log n). - QuickSort Para arreglos en memoria con acceso aleatorio rápido, cuando el espacio es limitado y puedes tolerar O(n²) en casos raros."}
{"id": "c1faf06125", "mode": "general", "instruction": "Compara la eficiencia de MergeSort y QuickSort. ¿Cuándo usarías cada uno paso a paso?", "input": "def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[: mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result. append(left[i]) i += 1 else: result. append(right[j]) j += 1 result. extend(left[i:]) result. extend(right[j:]) return result", "output": "Comparación de complejidades MergeSort - Temporal O(n log n) en todos los casos (mejor, promedio y peor). - Espacial O(n) debido a los arreglos temporales durante el merge. - Ventaja Estable y predecible, garantiza O(n log n). QuickSort - Temporal O(n log n) promedio, O(n²) peor caso. - Espacial O(log n) con implementación in-place. - Ventaja Más rápido en la práctica por mejor localidad de caché. ¿Cuándo usar cada uno? - MergeSort Cuando necesitas estabilidad, trabajas con datos enlazados, o requieres garantía de O(n log n). - QuickSort Para arreglos en memoria con acceso aleatorio rápido, cuando el espacio es limitado y puedes tolerar O(n²) en casos raros."}
{"id": "a177a6f6e6", "mode": "general", "instruction": "¿Es correcta esta implementación de búsqueda binaria? Analiza su complejidad.", "input": "def binary_search(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1", "output": "La implementación es correcta y representa la versión iterativa estándar de búsqueda binaria. Análisis de complejidad Complejidad Temporal O(log n) - En cada iteración, el espacio de búsqueda se reduce a la mitad. - Si tenemos n elementos, necesitamos como máximo log₂(n) comparaciones. - Ejemplo para 1024 elementos, máximo 10 iteraciones (2¹⁰ 1024). Complejidad Espacial O(1) - Solo usa variables auxiliares (left, right, mid). - No hay llamadas recursivas ni estructuras adicionales. Precondición importante El arreglo debe estar ordenado. Si no lo está, la búsqueda binaria no garantiza encontrar el elemento incluso si existe."}
{"id": "535ef85573", "mode": "general", "instruction": "¿Es correcta esta implementación de búsqueda binaria? Analiza su complejidad. con ejemplos de código?", "input": "def binary_search(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1", "output": "La implementación es correcta y representa la versión iterativa estándar de búsqueda binaria. Análisis de complejidad Complejidad Temporal O(log n) - En cada iteración, el espacio de búsqueda se reduce a la mitad. - Si tenemos n elementos, necesitamos como máximo log₂(n) comparaciones. - Ejemplo para 1024 elementos, máximo 10 iteraciones (2¹⁰ 1024). Complejidad Espacial O(1) - Solo usa variables auxiliares (left, right, mid). - No hay llamadas recursivas ni estructuras adicionales. Precondición importante El arreglo debe estar ordenado. Si no lo está, la búsqueda binaria no garantiza encontrar el elemento incluso si existe."}
{"id": "54963b4993", "mode": "general", "instruction": "¿Es correcta esta implementación de búsqueda binaria? Analiza su complejidad. paso a paso?", "input": "def binary_search(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1", "output": "La implementación es correcta y representa la versión iterativa estándar de búsqueda binaria. Análisis de complejidad Complejidad Temporal O(log n) - En cada iteración, el espacio de búsqueda se reduce a la mitad. - Si tenemos n elementos, necesitamos como máximo log₂(n) comparaciones. - Ejemplo para 1024 elementos, máximo 10 iteraciones (2¹⁰ 1024). Complejidad Espacial O(1) - Solo usa variables auxiliares (left, right, mid). - No hay llamadas recursivas ni estructuras adicionales. Precondición importante El arreglo debe estar ordenado. Si no lo está, la búsqueda binaria no garantiza encontrar el elemento incluso si existe."}
{"id": "bae672a4e7", "mode": "general", "instruction": "Identifica el problema de complejidad en este código y sugiere una mejora.", "input": "def find_duplicates(arr): duplicates = [] for i in range(len(arr)): for j in range(i + 1, len(arr)): if arr[i] == arr[j] and arr[i] not in duplicates: duplicates. append(arr[i]) return duplicates", "output": "Problema identificado Complejidad cuadrática con búsqueda lineal adicional. Complejidad actual - Temporal O(n²) debido al bucle anidado, más O(n) por la operación in en cada iteración, resultando en O(n³) en el peor caso. - Espacial O(n) para almacenar duplicados. Mejora propuesta usando un conjunto def find_duplicates(arr) seen set() duplicates set() for num in arr if num in seen duplicates. add(num) else seen. add(num) return list(duplicates) Complejidad mejorada - Temporal O(n) - un solo recorrido con operaciones de conjunto O(1). - Espacial O(n) para los dos conjuntos. La mejora reduce drásticamente el tiempo de O(n³) a O(n), sacrificando mínimamente espacio adicional."}
{"id": "d915a49d56", "mode": "general", "instruction": "Identifica el problema de complejidad en este código y sugiere una mejora. paso a paso?", "input": "def find_duplicates(arr): duplicates = [] for i in range(len(arr)): for j in range(i + 1, len(arr)): if arr[i] == arr[j] and arr[i] not in duplicates: duplicates. append(arr[i]) return duplicates", "output": "Problema identificado Complejidad cuadrática con búsqueda lineal adicional. Complejidad actual - Temporal O(n²) debido al bucle anidado, más O(n) por la operación in en cada iteración, resultando en O(n³) en el peor caso. - Espacial O(n) para almacenar duplicados. Mejora propuesta usando un conjunto def find_duplicates(arr) seen set() duplicates set() for num in arr if num in seen duplicates. add(num) else seen. add(num) return list(duplicates) Complejidad mejorada - Temporal O(n) - un solo recorrido con operaciones de conjunto O(1). - Espacial O(n) para los dos conjuntos. La mejora reduce drásticamente el tiempo de O(n³) a O(n), sacrificando mínimamente espacio adicional."}
{"id": "ea41cd75df", "mode": "general", "instruction": "Analiza la complejidad de este algoritmo BFS para grafos.", "input": "from collections import deque def bfs(graph, start): visited = set() queue = deque([start]) visited. add(start) result = [] while queue: node = queue. popleft() result. append(node) for neighbor in graph[node]: if neighbor not in visited: visited. add(neighbor) queue. append(neighbor) return result", "output": "Esta es una implementación correcta de BFS (Breadth-First Search). Análisis de complejidad Complejidad Temporal O(V E) - V número de vértices (nodos) - E número de aristas (edges) - Cada nodo se visita exactamente una vez O(V) - Cada arista se examina exactamente una vez O(E) - Las operaciones con set (add, in) son O(1) promedio Complejidad Espacial O(V) - visited almacena hasta V nodos - queue en el peor caso puede contener O(V) nodos - result almacena V nodos Características importantes - BFS garantiza encontrar el camino más corto en grafos no ponderados. - La cola (deque) asegura procesamiento FIFO. - El conjunto visited previene ciclos infinitos."}
{"id": "0f5bf4f40b", "mode": "general", "instruction": "Analiza la complejidad de este algoritmo BFS para grafos. con ejemplos de código?", "input": "from collections import deque def bfs(graph, start): visited = set() queue = deque([start]) visited. add(start) result = [] while queue: node = queue. popleft() result. append(node) for neighbor in graph[node]: if neighbor not in visited: visited. add(neighbor) queue. append(neighbor) return result", "output": "Esta es una implementación correcta de BFS (Breadth-First Search). Análisis de complejidad Complejidad Temporal O(V E) - V número de vértices (nodos) - E número de aristas (edges) - Cada nodo se visita exactamente una vez O(V) - Cada arista se examina exactamente una vez O(E) - Las operaciones con set (add, in) son O(1) promedio Complejidad Espacial O(V) - visited almacena hasta V nodos - queue en el peor caso puede contener O(V) nodos - result almacena V nodos Características importantes - BFS garantiza encontrar el camino más corto en grafos no ponderados. - La cola (deque) asegura procesamiento FIFO. - El conjunto visited previene ciclos infinitos."}
{"id": "7af6d4ab4d", "mode": "general", "instruction": "Analiza la complejidad de este algoritmo BFS para grafos. paso a paso?", "input": "from collections import deque def bfs(graph, start): visited = set() queue = deque([start]) visited. add(start) result = [] while queue: node = queue. popleft() result. append(node) for neighbor in graph[node]: if neighbor not in visited: visited. add(neighbor) queue. append(neighbor) return result", "output": "Esta es una implementación correcta de BFS (Breadth-First Search). Análisis de complejidad Complejidad Temporal O(V E) - V número de vértices (nodos) - E número de aristas (edges) - Cada nodo se visita exactamente una vez O(V) - Cada arista se examina exactamente una vez O(E) - Las operaciones con set (add, in) son O(1) promedio Complejidad Espacial O(V) - visited almacena hasta V nodos - queue en el peor caso puede contener O(V) nodos - result almacena V nodos Características importantes - BFS garantiza encontrar el camino más corto en grafos no ponderados. - La cola (deque) asegura procesamiento FIFO. - El conjunto visited previene ciclos infinitos."}
{"id": "7b551c01e0", "mode": "general", "instruction": "Compara BFS y DFS. ¿Cuál usarías para encontrar el camino más corto?", "input": "def dfs(graph, start, visited=None): if visited is None: visited = set() visited. add(start) result = [start] for neighbor in graph[start]: if neighbor not in visited: result. extend(dfs(graph, neighbor, visited)) return result", "output": "Análisis de DFS (Depth-First Search) Complejidad Temporal O(V E) - Similar a BFS, visita cada vértice y arista una vez. Complejidad Espacial O(V) - visited O(V) - Pila de recursión O(V) en el peor caso (grafo lineal) Comparación BFS vs DFS BFS - Usa cola (FIFO) - Explora por niveles - Garantiza camino más corto en grafos no ponderados - Mejor para encontrar distancias mínimas DFS - Usa pila (recursión o explícita) - Explora en profundidad primero - NO garantiza camino más corto - Mejor para detección de ciclos, ordenamiento topológico, componentes conectados Respuesta Para encontrar el camino más corto en un grafo no ponderado, SIEMPRE usa BFS. BFS explora todos los nodos a distancia k antes de explorar nodos a distancia k1, garantizando el camino mínimo."}
{"id": "aeed651764", "mode": "general", "instruction": "Compara BFS y DFS. ¿Cuál usarías para encontrar el camino más corto con ejemplos de código?", "input": "def dfs(graph, start, visited=None): if visited is None: visited = set() visited. add(start) result = [start] for neighbor in graph[start]: if neighbor not in visited: result. extend(dfs(graph, neighbor, visited)) return result", "output": "Análisis de DFS (Depth-First Search) Complejidad Temporal O(V E) - Similar a BFS, visita cada vértice y arista una vez. Complejidad Espacial O(V) - visited O(V) - Pila de recursión O(V) en el peor caso (grafo lineal) Comparación BFS vs DFS BFS - Usa cola (FIFO) - Explora por niveles - Garantiza camino más corto en grafos no ponderados - Mejor para encontrar distancias mínimas DFS - Usa pila (recursión o explícita) - Explora en profundidad primero - NO garantiza camino más corto - Mejor para detección de ciclos, ordenamiento topológico, componentes conectados Respuesta Para encontrar el camino más corto en un grafo no ponderado, SIEMPRE usa BFS. BFS explora todos los nodos a distancia k antes de explorar nodos a distancia k1, garantizando el camino mínimo."}
{"id": "d210ed1889", "mode": "general", "instruction": "Compara BFS y DFS. ¿Cuál usarías para encontrar el camino más corto paso a paso?", "input": "def dfs(graph, start, visited=None): if visited is None: visited = set() visited. add(start) result = [start] for neighbor in graph[start]: if neighbor not in visited: result. extend(dfs(graph, neighbor, visited)) return result", "output": "Análisis de DFS (Depth-First Search) Complejidad Temporal O(V E) - Similar a BFS, visita cada vértice y arista una vez. Complejidad Espacial O(V) - visited O(V) - Pila de recursión O(V) en el peor caso (grafo lineal) Comparación BFS vs DFS BFS - Usa cola (FIFO) - Explora por niveles - Garantiza camino más corto en grafos no ponderados - Mejor para encontrar distancias mínimas DFS - Usa pila (recursión o explícita) - Explora en profundidad primero - NO garantiza camino más corto - Mejor para detección de ciclos, ordenamiento topológico, componentes conectados Respuesta Para encontrar el camino más corto en un grafo no ponderado, SIEMPRE usa BFS. BFS explora todos los nodos a distancia k antes de explorar nodos a distancia k1, garantizando el camino mínimo."}
{"id": "ac550d5671", "mode": "general", "instruction": "¿Cuál es la complejidad de este algoritmo? Explica el razonamiento.", "input": "def mystery_function(n): result = 0 i = 1 while i < n: result += i i *= 2 return result", "output": "Análisis de complejidad Complejidad Temporal O(log n) Razonamiento - La variable i comienza en 1 y se duplica en cada iteración (i 2). - Secuencia de valores de i 1, 2, 4, 8, 16,..., hasta que i n - Esto es una progresión geométrica con razón 2. - Número de iteraciones k, donde 2k n, por tanto k log₂(n) Ejemplo - n 100 iteraciones 7 (27 128) - n 1000 iteraciones 10 (210 1024) Complejidad Espacial O(1) - Solo usa variables auxiliares constantes (result, i). Este patrón de duplicación (i 2) siempre indica complejidad logarítmica, similar a búsqueda binaria donde el espacio de búsqueda se divide (o multiplica) por 2."}
{"id": "acde2baae7", "mode": "general", "instruction": "Dame una explicación sobre ¿Cuál es la complejidad de este algoritmo? el razonamiento.", "input": "def mystery_function(n): result = 0 i = 1 while i < n: result += i i *= 2 return result", "output": "Análisis de complejidad Complejidad Temporal O(log n) Razonamiento - La variable i comienza en 1 y se duplica en cada iteración (i 2). - Secuencia de valores de i 1, 2, 4, 8, 16,..., hasta que i n - Esto es una progresión geométrica con razón 2. - Número de iteraciones k, donde 2k n, por tanto k log₂(n) Ejemplo - n 100 iteraciones 7 (27 128) - n 1000 iteraciones 10 (210 1024) Complejidad Espacial O(1) - Solo usa variables auxiliares constantes (result, i). Este patrón de duplicación (i 2) siempre indica complejidad logarítmica, similar a búsqueda binaria donde el espacio de búsqueda se divide (o multiplica) por 2."}
{"id": "78e8f237c3", "mode": "general", "instruction": "Ayúdame a entender ¿Cuál es la complejidad de este algoritmo? el razonamiento.", "input": "def mystery_function(n): result = 0 i = 1 while i < n: result += i i *= 2 return result", "output": "Análisis de complejidad Complejidad Temporal O(log n) Razonamiento - La variable i comienza en 1 y se duplica en cada iteración (i 2). - Secuencia de valores de i 1, 2, 4, 8, 16,..., hasta que i n - Esto es una progresión geométrica con razón 2. - Número de iteraciones k, donde 2k n, por tanto k log₂(n) Ejemplo - n 100 iteraciones 7 (27 128) - n 1000 iteraciones 10 (210 1024) Complejidad Espacial O(1) - Solo usa variables auxiliares constantes (result, i). Este patrón de duplicación (i 2) siempre indica complejidad logarítmica, similar a búsqueda binaria donde el espacio de búsqueda se divide (o multiplica) por 2."}
{"id": "1c917b6daf", "mode": "general", "instruction": "¿Cuál es la complejidad de este algoritmo? Explica el razonamiento. con ejemplos de código?", "input": "def mystery_function(n): result = 0 i = 1 while i < n: result += i i *= 2 return result", "output": "Análisis de complejidad Complejidad Temporal O(log n) Razonamiento - La variable i comienza en 1 y se duplica en cada iteración (i 2). - Secuencia de valores de i 1, 2, 4, 8, 16,..., hasta que i n - Esto es una progresión geométrica con razón 2. - Número de iteraciones k, donde 2k n, por tanto k log₂(n) Ejemplo - n 100 iteraciones 7 (27 128) - n 1000 iteraciones 10 (210 1024) Complejidad Espacial O(1) - Solo usa variables auxiliares constantes (result, i). Este patrón de duplicación (i 2) siempre indica complejidad logarítmica, similar a búsqueda binaria donde el espacio de búsqueda se divide (o multiplica) por 2."}
{"id": "96506b713d", "mode": "general", "instruction": "¿Cuál es la complejidad de este algoritmo? Explica el razonamiento. paso a paso?", "input": "def mystery_function(n): result = 0 i = 1 while i < n: result += i i *= 2 return result", "output": "Análisis de complejidad Complejidad Temporal O(log n) Razonamiento - La variable i comienza en 1 y se duplica en cada iteración (i 2). - Secuencia de valores de i 1, 2, 4, 8, 16,..., hasta que i n - Esto es una progresión geométrica con razón 2. - Número de iteraciones k, donde 2k n, por tanto k log₂(n) Ejemplo - n 100 iteraciones 7 (27 128) - n 1000 iteraciones 10 (210 1024) Complejidad Espacial O(1) - Solo usa variables auxiliares constantes (result, i). Este patrón de duplicación (i 2) siempre indica complejidad logarítmica, similar a búsqueda binaria donde el espacio de búsqueda se divide (o multiplica) por 2."}
{"id": "2d2e3adf6e", "mode": "general", "instruction": "Optimiza este código para verificar si un número es primo.", "input": "def is_prime(n): if n < 2: return False for i in range(2, n): if n % i == 0: return False return True", "output": "Análisis del código actual Complejidad Temporal O(n) - Verifica divisibilidad desde 2 hasta n-1, ejecutando n-2 iteraciones. Optimización propuesta import math def is_prime_optimized(n) if n 2 return False if n 2 return True if n 2 0 return False for i in range(3, int(math. sqrt(n)) 1, 2) if n i 0 return False return True Complejidad Temporal optimizada O(n) Mejoras aplicadas 1. Solo verifica hasta n porque si n tiene un divisor mayor que n, también tiene uno menor que n. 2. Verifica solo números impares (incremento de 2) después de descartar pares. 3. Caso especial para n2. Ejemplo de mejora - Para n1000000, versión original 999998 iteraciones - Versión optimizada 500 iteraciones - Reducción de O(n) a O(n) es significativa para números grandes."}
{"id": "6cd423970c", "mode": "general", "instruction": "Optimiza este código para verificar si un número es primo. paso a paso?", "input": "def is_prime(n): if n < 2: return False for i in range(2, n): if n % i == 0: return False return True", "output": "Análisis del código actual Complejidad Temporal O(n) - Verifica divisibilidad desde 2 hasta n-1, ejecutando n-2 iteraciones. Optimización propuesta import math def is_prime_optimized(n) if n 2 return False if n 2 return True if n 2 0 return False for i in range(3, int(math. sqrt(n)) 1, 2) if n i 0 return False return True Complejidad Temporal optimizada O(n) Mejoras aplicadas 1. Solo verifica hasta n porque si n tiene un divisor mayor que n, también tiene uno menor que n. 2. Verifica solo números impares (incremento de 2) después de descartar pares. 3. Caso especial para n2. Ejemplo de mejora - Para n1000000, versión original 999998 iteraciones - Versión optimizada 500 iteraciones - Reducción de O(n) a O(n) es significativa para números grandes."}
{"id": "29702fdc09", "mode": "general", "instruction": "¿Por qué este código tiene complejidad O(2^n)? Explica y propón una solución con programación dinámica.", "input": "def fibonacci(n): if n <= 1: return n return fibonacci(n-1) + fibonacci(n-2)", "output": "Explicación de O(2n) Esta implementación recursiva naive recalcula los mismos valores múltiples veces. Para fib(5) - fib(5) llama a fib(4) y fib(3) - fib(4) llama a fib(3) y fib(2) - fib(3) se calcula 2 veces - fib(2) se calcula 3 veces - El árbol de recursión crece exponencialmente Complejidad actual - Temporal O(2n) - cada llamada genera aproximadamente 2 llamadas más - Espacial O(n) - profundidad máxima de la pila de recursión Solución con Programación Dinámica (Memoización) def fibonacci_dp(n, memo) if n 1 return n if n not in memo memon fibonacci_dp(n-1, memo) fibonacci_dp(n-2, memo) return memon Complejidad optimizada - Temporal O(n) - cada valor se calcula solo una vez - Espacial O(n) - almacena n valores en memo O(n) pila Reducción dramática de O(2n) a O(n). Para n40, la diferencia es de miles de millones de operaciones a solo 40."}
{"id": "eb315a30d9", "mode": "general", "instruction": "Dame una explicación sobre ¿Por qué este código tiene complejidad O(2^n)? y propón una solución con programación dinámica.", "input": "def fibonacci(n): if n <= 1: return n return fibonacci(n-1) + fibonacci(n-2)", "output": "Explicación de O(2n) Esta implementación recursiva naive recalcula los mismos valores múltiples veces. Para fib(5) - fib(5) llama a fib(4) y fib(3) - fib(4) llama a fib(3) y fib(2) - fib(3) se calcula 2 veces - fib(2) se calcula 3 veces - El árbol de recursión crece exponencialmente Complejidad actual - Temporal O(2n) - cada llamada genera aproximadamente 2 llamadas más - Espacial O(n) - profundidad máxima de la pila de recursión Solución con Programación Dinámica (Memoización) def fibonacci_dp(n, memo) if n 1 return n if n not in memo memon fibonacci_dp(n-1, memo) fibonacci_dp(n-2, memo) return memon Complejidad optimizada - Temporal O(n) - cada valor se calcula solo una vez - Espacial O(n) - almacena n valores en memo O(n) pila Reducción dramática de O(2n) a O(n). Para n40, la diferencia es de miles de millones de operaciones a solo 40."}
{"id": "d3b82b7c77", "mode": "general", "instruction": "Ayúdame a entender ¿Por qué este código tiene complejidad O(2^n)? y propón una solución con programación dinámica.", "input": "def fibonacci(n): if n <= 1: return n return fibonacci(n-1) + fibonacci(n-2)", "output": "Explicación de O(2n) Esta implementación recursiva naive recalcula los mismos valores múltiples veces. Para fib(5) - fib(5) llama a fib(4) y fib(3) - fib(4) llama a fib(3) y fib(2) - fib(3) se calcula 2 veces - fib(2) se calcula 3 veces - El árbol de recursión crece exponencialmente Complejidad actual - Temporal O(2n) - cada llamada genera aproximadamente 2 llamadas más - Espacial O(n) - profundidad máxima de la pila de recursión Solución con Programación Dinámica (Memoización) def fibonacci_dp(n, memo) if n 1 return n if n not in memo memon fibonacci_dp(n-1, memo) fibonacci_dp(n-2, memo) return memon Complejidad optimizada - Temporal O(n) - cada valor se calcula solo una vez - Espacial O(n) - almacena n valores en memo O(n) pila Reducción dramática de O(2n) a O(n). Para n40, la diferencia es de miles de millones de operaciones a solo 40."}
{"id": "3b3e735ac0", "mode": "general", "instruction": "¿Por qué este código tiene complejidad O(2^n)? Explica y propón una solución con programación dinámica. paso a paso?", "input": "def fibonacci(n): if n <= 1: return n return fibonacci(n-1) + fibonacci(n-2)", "output": "Explicación de O(2n) Esta implementación recursiva naive recalcula los mismos valores múltiples veces. Para fib(5) - fib(5) llama a fib(4) y fib(3) - fib(4) llama a fib(3) y fib(2) - fib(3) se calcula 2 veces - fib(2) se calcula 3 veces - El árbol de recursión crece exponencialmente Complejidad actual - Temporal O(2n) - cada llamada genera aproximadamente 2 llamadas más - Espacial O(n) - profundidad máxima de la pila de recursión Solución con Programación Dinámica (Memoización) def fibonacci_dp(n, memo) if n 1 return n if n not in memo memon fibonacci_dp(n-1, memo) fibonacci_dp(n-2, memo) return memon Complejidad optimizada - Temporal O(n) - cada valor se calcula solo una vez - Espacial O(n) - almacena n valores en memo O(n) pila Reducción dramática de O(2n) a O(n). Para n40, la diferencia es de miles de millones de operaciones a solo 40."}
{"id": "103928f6c7", "mode": "general", "instruction": "Analiza la complejidad de esta búsqueda en una matriz ordenada.", "input": "def search_matrix(matrix, target): if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False", "output": "Este es un algoritmo elegante para buscar en una matriz ordenada por filas y columnas. Estrategia Comienza en la esquina superior derecha. - Si el valor actual target se mueve a la izquierda (col - 1) - Si el valor actual target se mueve hacia abajo (row 1) - Esto elimina una fila o columna completa en cada paso Complejidad Temporal O(m n) - m número de filas - n número de columnas - En el peor caso, recorre desde (0, n-1) hasta (m-1, 0) - Máximo m n - 1 pasos Complejidad Espacial O(1) - Solo usa variables auxiliares (row, col) Alternativa Aplicar búsqueda binaria dos veces sería O(log m log n), pero este enfoque es más simple de implementar. Si la matriz está completamente ordenada (como un arreglo 1D), podríamos usar búsqueda binaria pura en O(log(mn))."}
{"id": "8493120269", "mode": "general", "instruction": "Analiza la complejidad de esta búsqueda en una matriz ordenada. con ejemplos de código?", "input": "def search_matrix(matrix, target): if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False", "output": "Este es un algoritmo elegante para buscar en una matriz ordenada por filas y columnas. Estrategia Comienza en la esquina superior derecha. - Si el valor actual target se mueve a la izquierda (col - 1) - Si el valor actual target se mueve hacia abajo (row 1) - Esto elimina una fila o columna completa en cada paso Complejidad Temporal O(m n) - m número de filas - n número de columnas - En el peor caso, recorre desde (0, n-1) hasta (m-1, 0) - Máximo m n - 1 pasos Complejidad Espacial O(1) - Solo usa variables auxiliares (row, col) Alternativa Aplicar búsqueda binaria dos veces sería O(log m log n), pero este enfoque es más simple de implementar. Si la matriz está completamente ordenada (como un arreglo 1D), podríamos usar búsqueda binaria pura en O(log(mn))."}
{"id": "bba9b24580", "mode": "general", "instruction": "Analiza la complejidad de esta búsqueda en una matriz ordenada. paso a paso?", "input": "def search_matrix(matrix, target): if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False", "output": "Este es un algoritmo elegante para buscar en una matriz ordenada por filas y columnas. Estrategia Comienza en la esquina superior derecha. - Si el valor actual target se mueve a la izquierda (col - 1) - Si el valor actual target se mueve hacia abajo (row 1) - Esto elimina una fila o columna completa en cada paso Complejidad Temporal O(m n) - m número de filas - n número de columnas - En el peor caso, recorre desde (0, n-1) hasta (m-1, 0) - Máximo m n - 1 pasos Complejidad Espacial O(1) - Solo usa variables auxiliares (row, col) Alternativa Aplicar búsqueda binaria dos veces sería O(log m log n), pero este enfoque es más simple de implementar. Si la matriz está completamente ordenada (como un arreglo 1D), podríamos usar búsqueda binaria pura en O(log(mn))."}
{"id": "5d8f926a78", "mode": "general", "instruction": "Compara la complejidad de Dijkstra con lista de prioridad vs implementación ingenua.", "input": "Grafo con V nodos, E aristas ponderadas no negativas", "output": "con lista de prioridad (heap) Dijkstra es O((VE) log V); con implementación ingenua buscando el mínimo en O(V) cada vez, termina en O(V2 E). Para grafos densos V2 y para esparsos el heap es claramente superior."}
{"id": "6d072ea12b", "mode": "general", "instruction": "Compara la complejidad de Dijkstra con lista de prioridad vs implementación ingenua. con ejemplos de código?", "input": "Grafo con V nodos, E aristas ponderadas no negativas", "output": "con lista de prioridad (heap) Dijkstra es O((VE) log V); con implementación ingenua buscando el mínimo en O(V) cada vez, termina en O(V2 E). Para grafos densos V2 y para esparsos el heap es claramente superior."}
{"id": "2bcfbb7803", "mode": "general", "instruction": "Compara la complejidad de Dijkstra con lista de prioridad vs implementación ingenua. paso a paso?", "input": "Grafo con V nodos, E aristas ponderadas no negativas", "output": "con lista de prioridad (heap) Dijkstra es O((VE) log V); con implementación ingenua buscando el mínimo en O(V) cada vez, termina en O(V2 E). Para grafos densos V2 y para esparsos el heap es claramente superior."}
{"id": "35b152b825", "mode": "general", "instruction": "¿Cuándo usar Bellman-Ford en vez de Dijkstra?", "input": "Red con pesos negativos por promociones de costo", "output": "Bellman-Ford maneja pesos negativos y detecta ciclos negativos en O(VE). Dijkstra falla con pesos negativos. Si tus pesos son no negativos, Dijkstra es más rápido; si hay negativos o necesitas saber si existe ciclo negativo, usa Bellman-Ford."}
{"id": "f84b957763", "mode": "general", "instruction": "¿Cuándo usar Bellman-Ford en vez de Dijkstra con ejemplos de código?", "input": "Red con pesos negativos por promociones de costo", "output": "Bellman-Ford maneja pesos negativos y detecta ciclos negativos en O(VE). Dijkstra falla con pesos negativos. Si tus pesos son no negativos, Dijkstra es más rápido; si hay negativos o necesitas saber si existe ciclo negativo, usa Bellman-Ford."}
{"id": "c4d35d221c", "mode": "general", "instruction": "¿Cuándo usar Bellman-Ford en vez de Dijkstra paso a paso?", "input": "Red con pesos negativos por promociones de costo", "output": "Bellman-Ford maneja pesos negativos y detecta ciclos negativos en O(VE). Dijkstra falla con pesos negativos. Si tus pesos son no negativos, Dijkstra es más rápido; si hay negativos o necesitas saber si existe ciclo negativo, usa Bellman-Ford."}
{"id": "7b0426d6d3", "mode": "general", "instruction": "Revisa este método para ver el tope de una Pila (Stack) y dime si es seguro.", "input": "class Stack: def __init__(self): self. items = [] def peek(self): # Retorna el último elemento sin eliminarlo return self. items[-1]", "output": "Cuidado aquí. El código es sintácticamente correcto, pero tiene un error de lógica común no maneja el caso de una pila vacía. Si self. items está vacío, acceder a -1 lanzará un IndexError. Código corregido python def peek(self) if not self. items return None O levantar una excepción personalizada return self. items-1"}
{"id": "8734d2ada2", "mode": "general", "instruction": "Revisa este método para ver el tope de una Pila (Stack) y dime si es seguro. con ejemplos de código?", "input": "class Stack: def __init__(self): self. items = [] def peek(self): # Retorna el último elemento sin eliminarlo return self. items[-1]", "output": "Cuidado aquí. El código es sintácticamente correcto, pero tiene un error de lógica común no maneja el caso de una pila vacía. Si self. items está vacío, acceder a -1 lanzará un IndexError. Código corregido python def peek(self) if not self. items return None O levantar una excepción personalizada return self. items-1"}
{"id": "6f568b2943", "mode": "general", "instruction": "Revisa este método para ver el tope de una Pila (Stack) y dime si es seguro. paso a paso?", "input": "class Stack: def __init__(self): self. items = [] def peek(self): # Retorna el último elemento sin eliminarlo return self. items[-1]", "output": "Cuidado aquí. El código es sintácticamente correcto, pero tiene un error de lógica común no maneja el caso de una pila vacía. Si self. items está vacío, acceder a -1 lanzará un IndexError. Código corregido python def peek(self) if not self. items return None O levantar una excepción personalizada return self. items-1"}
{"id": "60bdf6b555", "mode": "general", "instruction": "Analiza la complejidad temporal de esta implementación de Cola (Queue).", "input": "class Queue: def __init__(self): self. items = [] def enqueue(self, item): self. items. append(item) def dequeue(self): return self. items. pop(0)", "output": "Funcional, pero ineficiente. En una lista de Python, hacer. pop(0) obliga a desplazar todos los elementos restantes una posición a la izquierda. Esto convierte la operación en O(n) (lineal) en lugar de O(1) (constante), que es lo deseado en una Cola. Solución Usa collections. deque. python from collections import deque... self. items deque()... return self. items. popleft()"}
{"id": "46f2893f4e", "mode": "general", "instruction": "Analiza la complejidad temporal de esta implementación de Cola (Queue). con ejemplos de código?", "input": "class Queue: def __init__(self): self. items = [] def enqueue(self, item): self. items. append(item) def dequeue(self): return self. items. pop(0)", "output": "Funcional, pero ineficiente. En una lista de Python, hacer. pop(0) obliga a desplazar todos los elementos restantes una posición a la izquierda. Esto convierte la operación en O(n) (lineal) en lugar de O(1) (constante), que es lo deseado en una Cola. Solución Usa collections. deque. python from collections import deque... self. items deque()... return self. items. popleft()"}
{"id": "8fe2ab3fab", "mode": "general", "instruction": "Analiza la complejidad temporal de esta implementación de Cola (Queue). paso a paso?", "input": "class Queue: def __init__(self): self. items = [] def enqueue(self, item): self. items. append(item) def dequeue(self): return self. items. pop(0)", "output": "Funcional, pero ineficiente. En una lista de Python, hacer. pop(0) obliga a desplazar todos los elementos restantes una posición a la izquierda. Esto convierte la operación en O(n) (lineal) en lugar de O(1) (constante), que es lo deseado en una Cola. Solución Usa collections. deque. python from collections import deque... self. items deque()... return self. items. popleft()"}
{"id": "d89784ad96", "mode": "general", "instruction": "Estoy intentando recorrer una Lista Enlazada pero mi programa se cuelga.", "input": "def print_list(self): current = self. head while current: print(current. data) # Fin del bucle", "output": "Has creado un Infinite Loop (Bucle Infinito). Dentro del while, nunca actualizas la variable current. Siempre apunta al head, por lo que la condición while current siempre es verdadera. Corrección Debes avanzar el puntero. python while current print(current. data) current current. next ¡Importante!"}
{"id": "768bc83ed9", "mode": "general", "instruction": "Estoy intentando recorrer una Lista Enlazada pero mi programa se cuelga. con ejemplos de código?", "input": "def print_list(self): current = self. head while current: print(current. data) # Fin del bucle", "output": "Has creado un Infinite Loop (Bucle Infinito). Dentro del while, nunca actualizas la variable current. Siempre apunta al head, por lo que la condición while current siempre es verdadera. Corrección Debes avanzar el puntero. python while current print(current. data) current current. next ¡Importante!"}
{"id": "65f062e1a2", "mode": "general", "instruction": "Estoy intentando recorrer una Lista Enlazada pero mi programa se cuelga. paso a paso?", "input": "def print_list(self): current = self. head while current: print(current. data) # Fin del bucle", "output": "Has creado un Infinite Loop (Bucle Infinito). Dentro del while, nunca actualizas la variable current. Siempre apunta al head, por lo que la condición while current siempre es verdadera. Corrección Debes avanzar el puntero. python while current print(current. data) current current. next ¡Importante!"}
{"id": "3ba6fb4b97", "mode": "general", "instruction": "Explícame la diferencia conceptual entre una Pila y una Cola con una analogía del mundo real.", "input": "¿Cuándo debería usar una Stack y cuándo una Queue?", "output": "Piensa en el orden de procesamiento 1. Pila (Stack) Es LIFO (Last-In, First-Out). Analogía Una torre de platos sucios. Lavas primero el último que pusiste encima. Úsala para Deshacer (Undo) en editores de texto o para manejar llamadas de funciones (recursion). 2. Cola (Queue) Es FIFO (First-In, First-Out). Analogía Una fila en el supermercado. El primero que llega es el primero en ser atendido. Úsala para gestionar tareas de impresión o peticiones a un servidor."}
{"id": "1712ff6bc8", "mode": "general", "instruction": "Explícame la diferencia conceptual entre una Pila y una Cola con una analogía del mundo real. con ejemplos de código?", "input": "¿Cuándo debería usar una Stack y cuándo una Queue?", "output": "Piensa en el orden de procesamiento 1. Pila (Stack) Es LIFO (Last-In, First-Out). Analogía Una torre de platos sucios. Lavas primero el último que pusiste encima. Úsala para Deshacer (Undo) en editores de texto o para manejar llamadas de funciones (recursion). 2. Cola (Queue) Es FIFO (First-In, First-Out). Analogía Una fila en el supermercado. El primero que llega es el primero en ser atendido. Úsala para gestionar tareas de impresión o peticiones a un servidor."}
{"id": "cc059b87a8", "mode": "general", "instruction": "Explícame la diferencia conceptual entre una Pila y una Cola con una analogía del mundo real. paso a paso?", "input": "¿Cuándo debería usar una Stack y cuándo una Queue?", "output": "Piensa en el orden de procesamiento 1. Pila (Stack) Es LIFO (Last-In, First-Out). Analogía Una torre de platos sucios. Lavas primero el último que pusiste encima. Úsala para Deshacer (Undo) en editores de texto o para manejar llamadas de funciones (recursion). 2. Cola (Queue) Es FIFO (First-In, First-Out). Analogía Una fila en el supermercado. El primero que llega es el primero en ser atendido. Úsala para gestionar tareas de impresión o peticiones a un servidor."}
{"id": "c27915bf58", "mode": "general", "instruction": "Encuentra el error al insertar un nodo en medio de una Lista Enlazada.", "input": "def insert_after(self, prev_node, new_data): new_node = Node(new_data) # Paso 1: Conectar el previo al nuevo prev_node. next = new_node # Paso 2: Conectar el nuevo al siguiente new_node. next = prev_node. next", "output": "¡Error de referencia perdida! Al ejecutar el Paso 1 (prev_node. next new_node), rompes el enlace con el resto de la lista. En el Paso 2, prev_node. next ya es new_node, así que estás haciendo que new_node se apunte a sí mismo (ciclo). Orden correcto Primero conecta el nuevo nodo al resto de la lista, y luego conecta el previo al nuevo. python new_node. next prev_node. next prev_node. next new_node"}
{"id": "6cdef0bada", "mode": "general", "instruction": "Encuentra el error al insertar un nodo en medio de una Lista Enlazada. con ejemplos de código?", "input": "def insert_after(self, prev_node, new_data): new_node = Node(new_data) # Paso 1: Conectar el previo al nuevo prev_node. next = new_node # Paso 2: Conectar el nuevo al siguiente new_node. next = prev_node. next", "output": "¡Error de referencia perdida! Al ejecutar el Paso 1 (prev_node. next new_node), rompes el enlace con el resto de la lista. En el Paso 2, prev_node. next ya es new_node, así que estás haciendo que new_node se apunte a sí mismo (ciclo). Orden correcto Primero conecta el nuevo nodo al resto de la lista, y luego conecta el previo al nuevo. python new_node. next prev_node. next prev_node. next new_node"}
{"id": "84d78f593c", "mode": "general", "instruction": "Encuentra el error al insertar un nodo en medio de una Lista Enlazada. paso a paso?", "input": "def insert_after(self, prev_node, new_data): new_node = Node(new_data) # Paso 1: Conectar el previo al nuevo prev_node. next = new_node # Paso 2: Conectar el nuevo al siguiente new_node. next = prev_node. next", "output": "¡Error de referencia perdida! Al ejecutar el Paso 1 (prev_node. next new_node), rompes el enlace con el resto de la lista. En el Paso 2, prev_node. next ya es new_node, así que estás haciendo que new_node se apunte a sí mismo (ciclo). Orden correcto Primero conecta el nuevo nodo al resto de la lista, y luego conecta el previo al nuevo. python new_node. next prev_node. next prev_node. next new_node"}
{"id": "001d8a5925", "mode": "general", "instruction": "Tengo un error 'IndexError: list index out of range' en este bucle simple.", "input": "my_list = [10, 20, 30] for i in range(len(my_list) + 1): print(my_list[i])", "output": "Es un error clásico de Off-by-one (error por uno). range(len(my_list) 1) genera índices desde 0 hasta 3 (para una lista de longitud 3). El índice 3 no existe (los válidos son 0, 1, 2). Corrección Usa range(len(my_list)) o simplemente itera sobre los elementos for item in my_list."}
{"id": "55aa41b2fa", "mode": "general", "instruction": "Tengo un error 'IndexError: list index out of range' en este bucle simple. con ejemplos de código?", "input": "my_list = [10, 20, 30] for i in range(len(my_list) + 1): print(my_list[i])", "output": "Es un error clásico de Off-by-one (error por uno). range(len(my_list) 1) genera índices desde 0 hasta 3 (para una lista de longitud 3). El índice 3 no existe (los válidos son 0, 1, 2). Corrección Usa range(len(my_list)) o simplemente itera sobre los elementos for item in my_list."}
{"id": "f812cc6ad7", "mode": "general", "instruction": "Tengo un error 'IndexError: list index out of range' en este bucle simple. paso a paso?", "input": "my_list = [10, 20, 30] for i in range(len(my_list) + 1): print(my_list[i])", "output": "Es un error clásico de Off-by-one (error por uno). range(len(my_list) 1) genera índices desde 0 hasta 3 (para una lista de longitud 3). El índice 3 no existe (los válidos son 0, 1, 2). Corrección Usa range(len(my_list)) o simplemente itera sobre los elementos for item in my_list."}
{"id": "3459572252", "mode": "general", "instruction": "¿Qué estructura de datos es más eficiente para buscar un elemento por su índice: Array o Lista Enlazada?", "input": "Necesito acceder frecuentemente al elemento en la posición N (ej: data[500]).", "output": "Definitivamente un Array (o lista en Python). Array Acceso aleatorio directo O(1). El ordenador sabe exactamente dónde está la memoria calculando inicio (tamaño indice). Lista Enlazada Acceso secuencial O(n). Tienes que recorrer 500 nodos uno por uno desde la cabecera para llegar al elemento deseado."}
{"id": "b9fe8beeb0", "mode": "general", "instruction": "Define qué significa tructura de datos es más eficiente para buscar un elemento por su índice: Array o Lista Enlazada?", "input": "Necesito acceder frecuentemente al elemento en la posición N (ej: data[500]).", "output": "Definitivamente un Array (o lista en Python). Array Acceso aleatorio directo O(1). El ordenador sabe exactamente dónde está la memoria calculando inicio (tamaño indice). Lista Enlazada Acceso secuencial O(n). Tienes que recorrer 500 nodos uno por uno desde la cabecera para llegar al elemento deseado."}
{"id": "0835474c32", "mode": "general", "instruction": "Explícame el concepto de tructura de datos es más eficiente para buscar un elemento por su índice: Array o Lista Enlazada?", "input": "Necesito acceder frecuentemente al elemento en la posición N (ej: data[500]).", "output": "Definitivamente un Array (o lista en Python). Array Acceso aleatorio directo O(1). El ordenador sabe exactamente dónde está la memoria calculando inicio (tamaño indice). Lista Enlazada Acceso secuencial O(n). Tienes que recorrer 500 nodos uno por uno desde la cabecera para llegar al elemento deseado."}
{"id": "facf21a059", "mode": "general", "instruction": "¿Qué estructura de datos es más eficiente para buscar un elemento por su índice: Array o Lista Enlazada con ejemplos de código?", "input": "Necesito acceder frecuentemente al elemento en la posición N (ej: data[500]).", "output": "Definitivamente un Array (o lista en Python). Array Acceso aleatorio directo O(1). El ordenador sabe exactamente dónde está la memoria calculando inicio (tamaño indice). Lista Enlazada Acceso secuencial O(n). Tienes que recorrer 500 nodos uno por uno desde la cabecera para llegar al elemento deseado."}
{"id": "1d2e5853fc", "mode": "general", "instruction": "¿Qué estructura de datos es más eficiente para buscar un elemento por su índice: Array o Lista Enlazada paso a paso?", "input": "Necesito acceder frecuentemente al elemento en la posición N (ej: data[500]).", "output": "Definitivamente un Array (o lista en Python). Array Acceso aleatorio directo O(1). El ordenador sabe exactamente dónde está la memoria calculando inicio (tamaño indice). Lista Enlazada Acceso secuencial O(n). Tienes que recorrer 500 nodos uno por uno desde la cabecera para llegar al elemento deseado."}
{"id": "0a81c20c59", "mode": "general", "instruction": "Depura esta función que acumula errores en una estructura predeterminada.", "input": "def log_error(msg, error_list=[]): error_list. append(msg) return error_list print(log_error(\"Error 1\")) print(log_error(\"Error 2\")) # Esperaba solo [\"Error 2\"]", "output": "Este es el problema del argumento por defecto mutable. En Python, la lista se crea una sola vez al definir la función, no cada vez que se llama. Las llamadas subsiguientes reutilizan la misma lista, acumulando datos viejos. Corrección python def log_error(msg, error_listNone) if error_list is None error_list error_list. append(msg) return error_list"}
{"id": "51672b01ba", "mode": "general", "instruction": "Depura esta función que acumula errores en una estructura predeterminada. con ejemplos de código?", "input": "def log_error(msg, error_list=[]): error_list. append(msg) return error_list print(log_error(\"Error 1\")) print(log_error(\"Error 2\")) # Esperaba solo [\"Error 2\"]", "output": "Este es el problema del argumento por defecto mutable. En Python, la lista se crea una sola vez al definir la función, no cada vez que se llama. Las llamadas subsiguientes reutilizan la misma lista, acumulando datos viejos. Corrección python def log_error(msg, error_listNone) if error_list is None error_list error_list. append(msg) return error_list"}
{"id": "1d9fde2e39", "mode": "general", "instruction": "Depura esta función que acumula errores en una estructura predeterminada. paso a paso?", "input": "def log_error(msg, error_list=[]): error_list. append(msg) return error_list print(log_error(\"Error 1\")) print(log_error(\"Error 2\")) # Esperaba solo [\"Error 2\"]", "output": "Este es el problema del argumento por defecto mutable. En Python, la lista se crea una sola vez al definir la función, no cada vez que se llama. Las llamadas subsiguientes reutilizan la misma lista, acumulando datos viejos. Corrección python def log_error(msg, error_listNone) if error_list is None error_list error_list. append(msg) return error_list"}
{"id": "a313037120", "mode": "general", "instruction": "Implementando una Cola Circular (Ring Buffer), mi índice crece indefinidamente.", "input": "class RingBuffer: def __init__(self, size): self. buffer = [None] * size self. size = size self. tail = 0 def enqueue(self, item): self. buffer[self. tail] = item self. tail = self. tail + 1 # Aquí creo que falla algo", "output": "Correcto, va a fallar. En una cola circular, cuando tail llega al final del array, debe volver al principio (índice 0). Tu código actual causará un IndexError eventualmente. Corrección Usa el operador módulo. python self. tail (self. tail 1) self. size Esto asegura que el índice siempre se mantenga entre 0 y size-1."}
{"id": "1c6ef47786", "mode": "general", "instruction": "Implementando una Cola Circular (Ring Buffer), mi índice crece indefinidamente. con ejemplos de código?", "input": "class RingBuffer: def __init__(self, size): self. buffer = [None] * size self. size = size self. tail = 0 def enqueue(self, item): self. buffer[self. tail] = item self. tail = self. tail + 1 # Aquí creo que falla algo", "output": "Correcto, va a fallar. En una cola circular, cuando tail llega al final del array, debe volver al principio (índice 0). Tu código actual causará un IndexError eventualmente. Corrección Usa el operador módulo. python self. tail (self. tail 1) self. size Esto asegura que el índice siempre se mantenga entre 0 y size-1."}
{"id": "5436ced7f0", "mode": "general", "instruction": "Implementando una Cola Circular (Ring Buffer), mi índice crece indefinidamente. paso a paso?", "input": "class RingBuffer: def __init__(self, size): self. buffer = [None] * size self. size = size self. tail = 0 def enqueue(self, item): self. buffer[self. tail] = item self. tail = self. tail + 1 # Aquí creo que falla algo", "output": "Correcto, va a fallar. En una cola circular, cuando tail llega al final del array, debe volver al principio (índice 0). Tu código actual causará un IndexError eventualmente. Corrección Usa el operador módulo. python self. tail (self. tail 1) self. size Esto asegura que el índice siempre se mantenga entre 0 y size-1."}
{"id": "a9d333f8ee", "mode": "general", "instruction": "Pregunta conceptual sobre gestión de memoria en Listas Enlazadas.", "input": "Si tengo una lista enlazada doble y borro un nodo, ¿basta con hacer `prev. next = current. next`?", "output": "No, eso es insuficiente para una lista Doble. Solo has arreglado el puntero de ida. Faltan dos cosas 1. Arreglar el puntero prev del nodo siguiente current. next. prev prev. 2. Eliminar las referencias del nodo borrado (current. next None, current. prev None) para ayudar al Garbage Collector (especialmente en lenguajes sin GC automático para evitar fugas o accesos ilegales)."}
{"id": "1c67b0dea8", "mode": "general", "instruction": "Pregunta conceptual sobre gestión de memoria en Listas Enlazadas. con ejemplos de código?", "input": "Si tengo una lista enlazada doble y borro un nodo, ¿basta con hacer `prev. next = current. next`?", "output": "No, eso es insuficiente para una lista Doble. Solo has arreglado el puntero de ida. Faltan dos cosas 1. Arreglar el puntero prev del nodo siguiente current. next. prev prev. 2. Eliminar las referencias del nodo borrado (current. next None, current. prev None) para ayudar al Garbage Collector (especialmente en lenguajes sin GC automático para evitar fugas o accesos ilegales)."}
{"id": "6136b8ee07", "mode": "general", "instruction": "Pregunta conceptual sobre gestión de memoria en Listas Enlazadas. paso a paso?", "input": "Si tengo una lista enlazada doble y borro un nodo, ¿basta con hacer `prev. next = current. next`?", "output": "No, eso es insuficiente para una lista Doble. Solo has arreglado el puntero de ida. Faltan dos cosas 1. Arreglar el puntero prev del nodo siguiente current. next. prev prev. 2. Eliminar las referencias del nodo borrado (current. next None, current. prev None) para ayudar al Garbage Collector (especialmente en lenguajes sin GC automático para evitar fugas o accesos ilegales)."}
{"id": "de20b0b536", "mode": "general", "instruction": "Encuentra el bug al manejar colisiones en este HashMap simple.", "input": "class HashMap: def __init__(self, size=8): self. buckets = [[] for _ in range(size)] def put(self, key, value): idx = hash(key) % len(self. buckets) self. buckets[idx] = [(key, value)] def get(self, key): idx = hash(key) % len(self. buckets) for k, v in self. buckets[idx]: if k == key: return v return None", "output": "en put estás reemplazando el bucket completo con una lista nueva, perdiendo claves previas que colisionen. Debes buscar si la clave existe y actualizar, o agregar si no. No sobrescribas todo el bucket."}
{"id": "094a8ca2be", "mode": "general", "instruction": "Encuentra el bug al manejar colisiones en este HashMap simple. con ejemplos de código?", "input": "class HashMap: def __init__(self, size=8): self. buckets = [[] for _ in range(size)] def put(self, key, value): idx = hash(key) % len(self. buckets) self. buckets[idx] = [(key, value)] def get(self, key): idx = hash(key) % len(self. buckets) for k, v in self. buckets[idx]: if k == key: return v return None", "output": "en put estás reemplazando el bucket completo con una lista nueva, perdiendo claves previas que colisionen. Debes buscar si la clave existe y actualizar, o agregar si no. No sobrescribas todo el bucket."}
{"id": "b4d18152eb", "mode": "general", "instruction": "Encuentra el bug al manejar colisiones en este HashMap simple. paso a paso?", "input": "class HashMap: def __init__(self, size=8): self. buckets = [[] for _ in range(size)] def put(self, key, value): idx = hash(key) % len(self. buckets) self. buckets[idx] = [(key, value)] def get(self, key): idx = hash(key) % len(self. buckets) for k, v in self. buckets[idx]: if k == key: return v return None", "output": "en put estás reemplazando el bucket completo con una lista nueva, perdiendo claves previas que colisionen. Debes buscar si la clave existe y actualizar, o agregar si no. No sobrescribas todo el bucket."}
{"id": "b192ae8e10", "mode": "general", "instruction": "Analiza la complejidad de implementar una cola con dos pilas.", "input": "push: stack_in. append(x) pop: if stack_out vacía -> mover todo desde stack_in a stack_out y hacer pop", "output": "cada elemento se mueve a lo sumo dos veces entre pilas. El costo amortizado de push y pop es O(1). Peor caso individual de pop puede ser O(n) cuando stack_out está vacía, pero en promedio es constante."}
{"id": "eaf1946a8b", "mode": "general", "instruction": "Analiza la complejidad de implementar una cola con dos pilas. con ejemplos de código?", "input": "push: stack_in. append(x) pop: if stack_out vacía -> mover todo desde stack_in a stack_out y hacer pop", "output": "cada elemento se mueve a lo sumo dos veces entre pilas. El costo amortizado de push y pop es O(1). Peor caso individual de pop puede ser O(n) cuando stack_out está vacía, pero en promedio es constante."}
{"id": "6af4cad0fb", "mode": "general", "instruction": "Analiza la complejidad de implementar una cola con dos pilas. paso a paso?", "input": "push: stack_in. append(x) pop: if stack_out vacía -> mover todo desde stack_in a stack_out y hacer pop", "output": "cada elemento se mueve a lo sumo dos veces entre pilas. El costo amortizado de push y pop es O(1). Peor caso individual de pop puede ser O(n) cuando stack_out está vacía, pero en promedio es constante."}
{"id": "25debc3661", "mode": "general", "instruction": "Evalúa mi solución para encontrar un elemento en una lista de usuarios ordenada alfabéticamente.", "input": "def buscar_usuario(usuarios, objetivo): # La lista 'usuarios' ya viene ordenada for u in usuarios: if u == objetivo: return True return False", "output": "Tu código funciona y es correcto lógicamente, pero es ineficiente para este contexto. Estás utilizando una Búsqueda Lineal (O(n)), lo que significa que si tienes 1 millón de usuarios, podrías tener que revisar el millón. Dado que la lista ya está ordenada, deberías implementar una Búsqueda Binaria (O(log n)). Esto reduciría drásticamente el tiempo de ejecución dividiendo el espacio de búsqueda a la mitad en cada paso."}
{"id": "309d9c27f3", "mode": "general", "instruction": "Evalúa mi solución para encontrar un elemento en una lista de usuarios ordenada alfabéticamente. con ejemplos de código?", "input": "def buscar_usuario(usuarios, objetivo): # La lista 'usuarios' ya viene ordenada for u in usuarios: if u == objetivo: return True return False", "output": "Tu código funciona y es correcto lógicamente, pero es ineficiente para este contexto. Estás utilizando una Búsqueda Lineal (O(n)), lo que significa que si tienes 1 millón de usuarios, podrías tener que revisar el millón. Dado que la lista ya está ordenada, deberías implementar una Búsqueda Binaria (O(log n)). Esto reduciría drásticamente el tiempo de ejecución dividiendo el espacio de búsqueda a la mitad en cada paso."}
{"id": "928a836a24", "mode": "general", "instruction": "Evalúa mi solución para encontrar un elemento en una lista de usuarios ordenada alfabéticamente. paso a paso?", "input": "def buscar_usuario(usuarios, objetivo): # La lista 'usuarios' ya viene ordenada for u in usuarios: if u == objetivo: return True return False", "output": "Tu código funciona y es correcto lógicamente, pero es ineficiente para este contexto. Estás utilizando una Búsqueda Lineal (O(n)), lo que significa que si tienes 1 millón de usuarios, podrías tener que revisar el millón. Dado que la lista ya está ordenada, deberías implementar una Búsqueda Binaria (O(log n)). Esto reduciría drásticamente el tiempo de ejecución dividiendo el espacio de búsqueda a la mitad en cada paso."}
{"id": "be7859f5bc", "mode": "general", "instruction": "Evalúa mi solución para calcular el precio total con impuestos.", "input": "a = 100 b = 0.21 c = a + (a * b) print(c)", "output": "El programa calcula el resultado correcto, pero tiene un problema grave de estilo y mantenibilidad. Nombres de variables como a, b y c no comunican nada a quien lee tu código (incluyéndote a ti mismo en el futuro). Según PEP8, usa nombres descriptivos (snake_case) python precio_base 100 tasa_impuesto 0.21 precio_total precio_base (precio_base tasa_impuesto) Así el código se documenta solo."}
{"id": "ac06b5210a", "mode": "general", "instruction": "Evalúa mi solución para calcular el precio total con impuestos. con ejemplos de código?", "input": "a = 100 b = 0.21 c = a + (a * b) print(c)", "output": "El programa calcula el resultado correcto, pero tiene un problema grave de estilo y mantenibilidad. Nombres de variables como a, b y c no comunican nada a quien lee tu código (incluyéndote a ti mismo en el futuro). Según PEP8, usa nombres descriptivos (snake_case) python precio_base 100 tasa_impuesto 0.21 precio_total precio_base (precio_base tasa_impuesto) Así el código se documenta solo."}
{"id": "26c403134e", "mode": "general", "instruction": "Evalúa mi solución para calcular el precio total con impuestos. paso a paso?", "input": "a = 100 b = 0.21 c = a + (a * b) print(c)", "output": "El programa calcula el resultado correcto, pero tiene un problema grave de estilo y mantenibilidad. Nombres de variables como a, b y c no comunican nada a quien lee tu código (incluyéndote a ti mismo en el futuro). Según PEP8, usa nombres descriptivos (snake_case) python precio_base 100 tasa_impuesto 0.21 precio_total precio_base (precio_base tasa_impuesto) Así el código se documenta solo."}
{"id": "bbd6ecec85", "mode": "general", "instruction": "Evalúa mi solución para contar cuántas veces aparece cada palabra en un texto.", "input": "text = [\"hola\", \"mundo\", \"hola\", \"python\"] conteo = {} for palabra in text: if palabra in conteo. keys(): conteo[palabra] = conteo[palabra] + 1 else: conteo[palabra] = 1", "output": "Es una solución funcional clásica, pero en Python podemos ser más elegantes y eficientes. 1. No necesitas llamar a. keys() en el if; if palabra in conteo es suficiente y más rápido. 2. Para este patrón específico, existe collections. Counter o el método. get(). Mejora sugerida python conteopalabra conteo. get(palabra, 0) 1 Esto elimina el bloque ifelse y hace el código mucho más limpio."}
{"id": "5579f8eea1", "mode": "general", "instruction": "Evalúa mi solución para contar cuántas veces aparece cada palabra en un texto. con ejemplos de código?", "input": "text = [\"hola\", \"mundo\", \"hola\", \"python\"] conteo = {} for palabra in text: if palabra in conteo. keys(): conteo[palabra] = conteo[palabra] + 1 else: conteo[palabra] = 1", "output": "Es una solución funcional clásica, pero en Python podemos ser más elegantes y eficientes. 1. No necesitas llamar a. keys() en el if; if palabra in conteo es suficiente y más rápido. 2. Para este patrón específico, existe collections. Counter o el método. get(). Mejora sugerida python conteopalabra conteo. get(palabra, 0) 1 Esto elimina el bloque ifelse y hace el código mucho más limpio."}
{"id": "977844302a", "mode": "general", "instruction": "Evalúa mi solución para contar cuántas veces aparece cada palabra en un texto. paso a paso?", "input": "text = [\"hola\", \"mundo\", \"hola\", \"python\"] conteo = {} for palabra in text: if palabra in conteo. keys(): conteo[palabra] = conteo[palabra] + 1 else: conteo[palabra] = 1", "output": "Es una solución funcional clásica, pero en Python podemos ser más elegantes y eficientes. 1. No necesitas llamar a. keys() en el if; if palabra in conteo es suficiente y más rápido. 2. Para este patrón específico, existe collections. Counter o el método. get(). Mejora sugerida python conteopalabra conteo. get(palabra, 0) 1 Esto elimina el bloque ifelse y hace el código mucho más limpio."}
{"id": "63cd5f991d", "mode": "general", "instruction": "Evalúa mi solución para iterar una lista e imprimir el índice y el valor.", "input": "frutas = [\"manzana\", \"banana\", \"cereza\"] for i in range(len(frutas)): print(str(i) + \": \" + frutas[i])", "output": "Este es un anti-patrón muy común en programadores que vienen de C o Java. Aunque funciona, en Python no se considera Pythonic iterar usando índices generados manualmente si no es estrictamente necesario. Mejora Usa la función enumerate(). Es más limpia y eficiente python for i, fruta in enumerate(frutas) print(fi fruta) Nota también el uso de f-strings para formatear el texto, que es más legible que concatenar con."}
{"id": "4ad1dde318", "mode": "general", "instruction": "Evalúa mi solución para iterar una lista e imprimir el índice y el valor. con ejemplos de código?", "input": "frutas = [\"manzana\", \"banana\", \"cereza\"] for i in range(len(frutas)): print(str(i) + \": \" + frutas[i])", "output": "Este es un anti-patrón muy común en programadores que vienen de C o Java. Aunque funciona, en Python no se considera Pythonic iterar usando índices generados manualmente si no es estrictamente necesario. Mejora Usa la función enumerate(). Es más limpia y eficiente python for i, fruta in enumerate(frutas) print(fi fruta) Nota también el uso de f-strings para formatear el texto, que es más legible que concatenar con."}
{"id": "e6581daeb4", "mode": "general", "instruction": "Evalúa mi solución para iterar una lista e imprimir el índice y el valor. paso a paso?", "input": "frutas = [\"manzana\", \"banana\", \"cereza\"] for i in range(len(frutas)): print(str(i) + \": \" + frutas[i])", "output": "Este es un anti-patrón muy común en programadores que vienen de C o Java. Aunque funciona, en Python no se considera Pythonic iterar usando índices generados manualmente si no es estrictamente necesario. Mejora Usa la función enumerate(). Es más limpia y eficiente python for i, fruta in enumerate(frutas) print(fi fruta) Nota también el uso de f-strings para formatear el texto, que es más legible que concatenar con."}
{"id": "4bfcb65ad1", "mode": "general", "instruction": "Evalúa mi solución para eliminar duplicados de una lista de números.", "input": "numeros = [1, 2, 2, 3, 4, 4, 5] unicos = [] for n in numeros: if n not in unicos: unicos. append(n) return unicos", "output": "Tu lógica es impecable para mantener el orden, pero ineficiente en términos de complejidad temporal. La operación if n not in unicos recorre la lista unicos cada vez. Esto convierte tu algoritmo en O(N²). Si el orden no importa, usa un Set (Conjunto), que elimina duplicados instantáneamente gracias a su estructura hash python return list(set(numeros)) Si necesitas mantener el orden, tu enfoque es aceptable, pero ten en cuenta el coste de rendimiento en listas grandes."}
{"id": "b5c7949266", "mode": "general", "instruction": "Evalúa mi solución para eliminar duplicados de una lista de números. con ejemplos de código?", "input": "numeros = [1, 2, 2, 3, 4, 4, 5] unicos = [] for n in numeros: if n not in unicos: unicos. append(n) return unicos", "output": "Tu lógica es impecable para mantener el orden, pero ineficiente en términos de complejidad temporal. La operación if n not in unicos recorre la lista unicos cada vez. Esto convierte tu algoritmo en O(N²). Si el orden no importa, usa un Set (Conjunto), que elimina duplicados instantáneamente gracias a su estructura hash python return list(set(numeros)) Si necesitas mantener el orden, tu enfoque es aceptable, pero ten en cuenta el coste de rendimiento en listas grandes."}
{"id": "37f0c9da5f", "mode": "general", "instruction": "Evalúa mi solución para eliminar duplicados de una lista de números. paso a paso?", "input": "numeros = [1, 2, 2, 3, 4, 4, 5] unicos = [] for n in numeros: if n not in unicos: unicos. append(n) return unicos", "output": "Tu lógica es impecable para mantener el orden, pero ineficiente en términos de complejidad temporal. La operación if n not in unicos recorre la lista unicos cada vez. Esto convierte tu algoritmo en O(N²). Si el orden no importa, usa un Set (Conjunto), que elimina duplicados instantáneamente gracias a su estructura hash python return list(set(numeros)) Si necesitas mantener el orden, tu enfoque es aceptable, pero ten en cuenta el coste de rendimiento en listas grandes."}
{"id": "71791c9791", "mode": "general", "instruction": "Evalúa mi solución para sumar una lista de números usando una variable externa.", "input": "total = 0 def sumar_lista(lista): global total for n in lista: total += n sumar_lista([10, 20, 30]) print(total)", "output": "Evita el uso de variables globales (global total) dentro de funciones siempre que sea posible. Esto hace que tu función tenga efectos secundarios (side effects), sea difícil de testear y propensa a errores si se llama dos veces (el total seguiría acumulando). Mejora La función debe ser autocontenida. Recibe datos, procesa y retorna un valor. python def sumar_lista(lista) return sum(lista) O un bucle con variable local resultado sumar_lista(10, 20, 30)"}
{"id": "3bbe78b853", "mode": "general", "instruction": "Evalúa mi solución para sumar una lista de números usando una variable externa. con ejemplos de código?", "input": "total = 0 def sumar_lista(lista): global total for n in lista: total += n sumar_lista([10, 20, 30]) print(total)", "output": "Evita el uso de variables globales (global total) dentro de funciones siempre que sea posible. Esto hace que tu función tenga efectos secundarios (side effects), sea difícil de testear y propensa a errores si se llama dos veces (el total seguiría acumulando). Mejora La función debe ser autocontenida. Recibe datos, procesa y retorna un valor. python def sumar_lista(lista) return sum(lista) O un bucle con variable local resultado sumar_lista(10, 20, 30)"}
{"id": "1ef77fbb96", "mode": "general", "instruction": "Evalúa mi solución para sumar una lista de números usando una variable externa. paso a paso?", "input": "total = 0 def sumar_lista(lista): global total for n in lista: total += n sumar_lista([10, 20, 30]) print(total)", "output": "Evita el uso de variables globales (global total) dentro de funciones siempre que sea posible. Esto hace que tu función tenga efectos secundarios (side effects), sea difícil de testear y propensa a errores si se llama dos veces (el total seguiría acumulando). Mejora La función debe ser autocontenida. Recibe datos, procesa y retorna un valor. python def sumar_lista(lista) return sum(lista) O un bucle con variable local resultado sumar_lista(10, 20, 30)"}
{"id": "4bbf82c61a", "mode": "general", "instruction": "Evalúa mi solución para verificar si una lista está vacía.", "input": "mi_lista = [] if len(mi_lista) == 0: print(\"Está vacía\")", "output": "Funciona, pero no es el estilo idiomático de Python (PEP8). Las listas vacías se evalúan como False en un contexto booleano. Mejora Escribe simplemente python if not mi_lista print(Está vacía) Es más directo y se lee casi como lenguaje natural."}
{"id": "82619a0dd1", "mode": "general", "instruction": "Evalúa mi solución para verificar si una lista está vacía. con ejemplos de código?", "input": "mi_lista = [] if len(mi_lista) == 0: print(\"Está vacía\")", "output": "Funciona, pero no es el estilo idiomático de Python (PEP8). Las listas vacías se evalúan como False en un contexto booleano. Mejora Escribe simplemente python if not mi_lista print(Está vacía) Es más directo y se lee casi como lenguaje natural."}
{"id": "421c0086dd", "mode": "general", "instruction": "Evalúa mi solución para verificar si una lista está vacía. paso a paso?", "input": "mi_lista = [] if len(mi_lista) == 0: print(\"Está vacía\")", "output": "Funciona, pero no es el estilo idiomático de Python (PEP8). Las listas vacías se evalúan como False en un contexto booleano. Mejora Escribe simplemente python if not mi_lista print(Está vacía) Es más directo y se lee casi como lenguaje natural."}
{"id": "07ea6941b9", "mode": "general", "instruction": "Evalúa mi solución para buscar un valor en una lista de 10,000 elementos.", "input": "datos = [i for i in range(10000)] # Lista grande def existe_valor(val): return val in datos", "output": "El problema aquí es la elección de la estructura de datos. Una búsqueda in sobre una Lista es O(n) (tiene que recorrerla). Si vas a hacer muchas búsquedas sobre estos datos estáticos, deberías usar un Diccionario o un Set. Mejora python datos_set set(datos) Convertir una vez La búsqueda ahora es O(1) (instantánea) return val in datos_set"}
{"id": "897f84a032", "mode": "general", "instruction": "Evalúa mi solución para buscar un valor en una lista de 10,000 elementos. con ejemplos de código?", "input": "datos = [i for i in range(10000)] # Lista grande def existe_valor(val): return val in datos", "output": "El problema aquí es la elección de la estructura de datos. Una búsqueda in sobre una Lista es O(n) (tiene que recorrerla). Si vas a hacer muchas búsquedas sobre estos datos estáticos, deberías usar un Diccionario o un Set. Mejora python datos_set set(datos) Convertir una vez La búsqueda ahora es O(1) (instantánea) return val in datos_set"}
{"id": "6162451ab4", "mode": "general", "instruction": "Evalúa mi solución para buscar un valor en una lista de 10,000 elementos. paso a paso?", "input": "datos = [i for i in range(10000)] # Lista grande def existe_valor(val): return val in datos", "output": "El problema aquí es la elección de la estructura de datos. Una búsqueda in sobre una Lista es O(n) (tiene que recorrerla). Si vas a hacer muchas búsquedas sobre estos datos estáticos, deberías usar un Diccionario o un Set. Mejora python datos_set set(datos) Convertir una vez La búsqueda ahora es O(1) (instantánea) return val in datos_set"}
{"id": "c2fc615717", "mode": "general", "instruction": "Evalúa mi solución para crear una lista con los cuadrados de los números pares.", "input": "numeros = [1, 2, 3, 4, 5] cuadrados = [] for n in numeros: if n % 2 == 0: cuadrados. append(n**2)", "output": "Tu código es perfectamente legible y correcto. Sin embargo, en Python solemos preferir las List Comprehensions (Comprensión de Listas) para transformaciones simples como esta. Son más compactas y a menudo más rápidas al ejecutarse en C bajo el capó. Versión Pythonic python cuadrados n2 for n in numeros if n 2 0"}
{"id": "2629f20f58", "mode": "general", "instruction": "Evalúa mi solución para crear una lista con los cuadrados de los números pares. con ejemplos de código?", "input": "numeros = [1, 2, 3, 4, 5] cuadrados = [] for n in numeros: if n % 2 == 0: cuadrados. append(n**2)", "output": "Tu código es perfectamente legible y correcto. Sin embargo, en Python solemos preferir las List Comprehensions (Comprensión de Listas) para transformaciones simples como esta. Son más compactas y a menudo más rápidas al ejecutarse en C bajo el capó. Versión Pythonic python cuadrados n2 for n in numeros if n 2 0"}
{"id": "3eb2779cdf", "mode": "general", "instruction": "Evalúa mi solución para crear una lista con los cuadrados de los números pares. paso a paso?", "input": "numeros = [1, 2, 3, 4, 5] cuadrados = [] for n in numeros: if n % 2 == 0: cuadrados. append(n**2)", "output": "Tu código es perfectamente legible y correcto. Sin embargo, en Python solemos preferir las List Comprehensions (Comprensión de Listas) para transformaciones simples como esta. Son más compactas y a menudo más rápidas al ejecutarse en C bajo el capó. Versión Pythonic python cuadrados n2 for n in numeros if n 2 0"}
{"id": "badaadcb92", "mode": "general", "instruction": "Evalúa mi función que retorna verdadero si 'x' es válido.", "input": "def validar(x): if x > 10: return True else: return False", "output": "Es redundante. La expresión x 10 ya se evalúa a True o False por sí misma. No necesitas un bloque ifelse para retornar un booleano basado en una condición booleana. Mejora Simplifica tu código python def validar(x) return x 10 Menos líneas, misma funcionalidad, menor carga cognitiva."}
{"id": "b5efa9df58", "mode": "general", "instruction": "Evalúa mi función que retorna verdadero si 'x' es válido. con ejemplos de código?", "input": "def validar(x): if x > 10: return True else: return False", "output": "Es redundante. La expresión x 10 ya se evalúa a True o False por sí misma. No necesitas un bloque ifelse para retornar un booleano basado en una condición booleana. Mejora Simplifica tu código python def validar(x) return x 10 Menos líneas, misma funcionalidad, menor carga cognitiva."}
{"id": "a41c43face", "mode": "general", "instruction": "Evalúa mi función que retorna verdadero si 'x' es válido. paso a paso?", "input": "def validar(x): if x > 10: return True else: return False", "output": "Es redundante. La expresión x 10 ya se evalúa a True o False por sí misma. No necesitas un bloque ifelse para retornar un booleano basado en una condición booleana. Mejora Simplifica tu código python def validar(x) return x 10 Menos líneas, misma funcionalidad, menor carga cognitiva."}
{"id": "e1b5ed593f", "mode": "general", "instruction": "Evalúa mi factorial recursivo que usa una variable global para acumular.", "input": "total = 1 def fact(n): global total if n == 0: return total total *= n return fact(n-1)", "output": "funciona para una sola llamada, pero la variable global deja basura para la siguiente invocación y rompe la pureza de la función. Haz que fact retorne el valor sin globales python def fact(n) if n 1 return 1 return n fact(n-1) Más limpio, testeable y sin efectos secundarios."}
{"id": "6643885714", "mode": "general", "instruction": "Evalúa mi factorial recursivo que usa una variable global para acumular. con ejemplos de código?", "input": "total = 1 def fact(n): global total if n == 0: return total total *= n return fact(n-1)", "output": "funciona para una sola llamada, pero la variable global deja basura para la siguiente invocación y rompe la pureza de la función. Haz que fact retorne el valor sin globales python def fact(n) if n 1 return 1 return n fact(n-1) Más limpio, testeable y sin efectos secundarios."}
{"id": "fbd6f18815", "mode": "general", "instruction": "Evalúa mi factorial recursivo que usa una variable global para acumular. paso a paso?", "input": "total = 1 def fact(n): global total if n == 0: return total total *= n return fact(n-1)", "output": "funciona para una sola llamada, pero la variable global deja basura para la siguiente invocación y rompe la pureza de la función. Haz que fact retorne el valor sin globales python def fact(n) if n 1 return 1 return n fact(n-1) Más limpio, testeable y sin efectos secundarios."}
{"id": "eb5fe2f3b4", "mode": "general", "instruction": "Evalúa este uso de list comprehension para efectos secundarios.", "input": "[print(x) for x in range(3)]", "output": "las comprehensions se usan para construir listas, no para efectos secundarios. Aquí creas una lista de None que ni usas. Mejor un for simple python for x in range(3) print(x) Más legible y evita listas basura."}
{"id": "825307df72", "mode": "general", "instruction": "Evalúa este uso de list comprehension para efectos secundarios. con ejemplos de código?", "input": "[print(x) for x in range(3)]", "output": "las comprehensions se usan para construir listas, no para efectos secundarios. Aquí creas una lista de None que ni usas. Mejor un for simple python for x in range(3) print(x) Más legible y evita listas basura."}
{"id": "925b3ab329", "mode": "general", "instruction": "Evalúa este uso de list comprehension para efectos secundarios. paso a paso?", "input": "[print(x) for x in range(3)]", "output": "las comprehensions se usan para construir listas, no para efectos secundarios. Aquí creas una lista de None que ni usas. Mejor un for simple python for x in range(3) print(x) Más legible y evita listas basura."}
{"id": "c70ea1d012", "mode": "general", "instruction": "Escribe una función para verificar si una cadena es un palíndromo.", "input": "s = \"racecar\"", "output": "Estrategia 1. Comparar caracteres desde ambos extremos hacia el centro 2. Si todos los pares coinciden, es palíndromo 3. Complejidad O(n) tiempo, O(1) espacio Solución óptima def is_palindrome(s) left 0 right len(s) - 1 while left right if sleft! sright return False left 1 right - 1 return True Alternativa con slicing (más pythónica) def is_palindrome_simple(s) return s s-1 Pruebas print(is_palindrome(racecar)) True print(is_palindrome(hello)) False print(is_palindrome(a)) True print(is_palindrome()) True"}
{"id": "fd69454b35", "mode": "general", "instruction": "Escribe una función para verificar si una cadena es un palíndromo. con ejemplos de código?", "input": "s = \"racecar\"", "output": "Estrategia 1. Comparar caracteres desde ambos extremos hacia el centro 2. Si todos los pares coinciden, es palíndromo 3. Complejidad O(n) tiempo, O(1) espacio Solución óptima def is_palindrome(s) left 0 right len(s) - 1 while left right if sleft! sright return False left 1 right - 1 return True Alternativa con slicing (más pythónica) def is_palindrome_simple(s) return s s-1 Pruebas print(is_palindrome(racecar)) True print(is_palindrome(hello)) False print(is_palindrome(a)) True print(is_palindrome()) True"}
{"id": "3fcad046be", "mode": "general", "instruction": "Escribe una función para verificar si una cadena es un palíndromo. paso a paso?", "input": "s = \"racecar\"", "output": "Estrategia 1. Comparar caracteres desde ambos extremos hacia el centro 2. Si todos los pares coinciden, es palíndromo 3. Complejidad O(n) tiempo, O(1) espacio Solución óptima def is_palindrome(s) left 0 right len(s) - 1 while left right if sleft! sright return False left 1 right - 1 return True Alternativa con slicing (más pythónica) def is_palindrome_simple(s) return s s-1 Pruebas print(is_palindrome(racecar)) True print(is_palindrome(hello)) False print(is_palindrome(a)) True print(is_palindrome()) True"}
{"id": "b488c7b0ae", "mode": "general", "instruction": "Escribe una función para detectar si dos strings son anagramas.", "input": "str1 = \"listen\" str2 = \"silent\"", "output": "Estrategia 1. Anagramas tienen los mismos caracteres con las mismas frecuencias 2. Opción 1 Ordenar ambas cadenas y comparar - O(n log n) 3. Opción 2 Usar diccionariocontador para frecuencias - O(n) Solución 1 Usando ordenamiento (simple) def are_anagrams_sort(str1, str2) Si longitudes diferentes, no pueden ser anagramas if len(str1)! len(str2) return False return sorted(str1) sorted(str2) Solución 2 Usando contador (más eficiente) from collections import Counter def are_anagrams_counter(str1, str2) if len(str1)! len(str2) return False return Counter(str1) Counter(str2) Solución 3 Sin librerías (manual) def are_anagrams_manual(str1, str2) if len(str1)! len(str2) return False char_count Contar caracteres de str1 for char in str1 char_countchar char_count. get(char, 0) 1 Restar caracteres de str2 for char in str2 if char not in char_count return False char_countchar - 1 if char_countchar 0 return False return True Pruebas print(are_anagrams_sort(listen, silent)) True print(are_anagrams_sort(hello, world)) False"}
{"id": "7772a64d0d", "mode": "general", "instruction": "Escribe una función para detectar si dos strings son anagramas. con ejemplos de código?", "input": "str1 = \"listen\" str2 = \"silent\"", "output": "Estrategia 1. Anagramas tienen los mismos caracteres con las mismas frecuencias 2. Opción 1 Ordenar ambas cadenas y comparar - O(n log n) 3. Opción 2 Usar diccionariocontador para frecuencias - O(n) Solución 1 Usando ordenamiento (simple) def are_anagrams_sort(str1, str2) Si longitudes diferentes, no pueden ser anagramas if len(str1)! len(str2) return False return sorted(str1) sorted(str2) Solución 2 Usando contador (más eficiente) from collections import Counter def are_anagrams_counter(str1, str2) if len(str1)! len(str2) return False return Counter(str1) Counter(str2) Solución 3 Sin librerías (manual) def are_anagrams_manual(str1, str2) if len(str1)! len(str2) return False char_count Contar caracteres de str1 for char in str1 char_countchar char_count. get(char, 0) 1 Restar caracteres de str2 for char in str2 if char not in char_count return False char_countchar - 1 if char_countchar 0 return False return True Pruebas print(are_anagrams_sort(listen, silent)) True print(are_anagrams_sort(hello, world)) False"}
{"id": "c1b63aaa44", "mode": "general", "instruction": "Escribe una función para detectar si dos strings son anagramas. paso a paso?", "input": "str1 = \"listen\" str2 = \"silent\"", "output": "Estrategia 1. Anagramas tienen los mismos caracteres con las mismas frecuencias 2. Opción 1 Ordenar ambas cadenas y comparar - O(n log n) 3. Opción 2 Usar diccionariocontador para frecuencias - O(n) Solución 1 Usando ordenamiento (simple) def are_anagrams_sort(str1, str2) Si longitudes diferentes, no pueden ser anagramas if len(str1)! len(str2) return False return sorted(str1) sorted(str2) Solución 2 Usando contador (más eficiente) from collections import Counter def are_anagrams_counter(str1, str2) if len(str1)! len(str2) return False return Counter(str1) Counter(str2) Solución 3 Sin librerías (manual) def are_anagrams_manual(str1, str2) if len(str1)! len(str2) return False char_count Contar caracteres de str1 for char in str1 char_countchar char_count. get(char, 0) 1 Restar caracteres de str2 for char in str2 if char not in char_count return False char_countchar - 1 if char_countchar 0 return False return True Pruebas print(are_anagrams_sort(listen, silent)) True print(are_anagrams_sort(hello, world)) False"}
{"id": "b4be0fd755", "mode": "general", "instruction": "Implementa el clásico problema FizzBuzz: imprime números del 1 al n, pero para múltiplos de 3 imprime 'Fizz', para múltiplos de 5 imprime 'Buzz', y para múltiplos de ambos imprime 'FizzBuzz'.", "input": "n = 15", "output": "Estrategia 1. Iterar del 1 al n 2. Verificar divisibilidad primero por 15 (ambos), luego por 3, luego por 5 3. Orden importante verificar 15 antes de 3 o 5 individualmente 4. Complejidad O(n) tiempo, O(1) espacio Solución clásica def fizzbuzz(n) result for i in range(1, n 1) if i 15 0 result. append(FizzBuzz) elif i 3 0 result. append(Fizz) elif i 5 0 result. append(Buzz) else result. append(str(i)) return result Solución alternativa (más elegante) def fizzbuzz_elegant(n) result for i in range(1, n 1) output if i 3 0 output Fizz if i 5 0 output Buzz result. append(output or str(i)) return result Versión que imprime directamente def fizzbuzz_print(n) for i in range(1, n 1) if i 15 0 print(FizzBuzz) elif i 3 0 print(Fizz) elif i 5 0 print(Buzz) else print(i) Prueba print(fizzbuzz(15)) Output 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz"}
{"id": "e3e3f524f3", "mode": "general", "instruction": "Implementa el clásico problema FizzBuzz: imprime números del 1 al n, pero para múltiplos de 3 imprime 'Fizz', para múltiplos de 5 imprime 'Buzz', y para múltiplos de ambos imprime 'FizzBuzz'. con ejemplos de código?", "input": "n = 15", "output": "Estrategia 1. Iterar del 1 al n 2. Verificar divisibilidad primero por 15 (ambos), luego por 3, luego por 5 3. Orden importante verificar 15 antes de 3 o 5 individualmente 4. Complejidad O(n) tiempo, O(1) espacio Solución clásica def fizzbuzz(n) result for i in range(1, n 1) if i 15 0 result. append(FizzBuzz) elif i 3 0 result. append(Fizz) elif i 5 0 result. append(Buzz) else result. append(str(i)) return result Solución alternativa (más elegante) def fizzbuzz_elegant(n) result for i in range(1, n 1) output if i 3 0 output Fizz if i 5 0 output Buzz result. append(output or str(i)) return result Versión que imprime directamente def fizzbuzz_print(n) for i in range(1, n 1) if i 15 0 print(FizzBuzz) elif i 3 0 print(Fizz) elif i 5 0 print(Buzz) else print(i) Prueba print(fizzbuzz(15)) Output 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz"}
{"id": "85b65c549b", "mode": "general", "instruction": "Implementa el clásico problema FizzBuzz: imprime números del 1 al n, pero para múltiplos de 3 imprime 'Fizz', para múltiplos de 5 imprime 'Buzz', y para múltiplos de ambos imprime 'FizzBuzz'. paso a paso?", "input": "n = 15", "output": "Estrategia 1. Iterar del 1 al n 2. Verificar divisibilidad primero por 15 (ambos), luego por 3, luego por 5 3. Orden importante verificar 15 antes de 3 o 5 individualmente 4. Complejidad O(n) tiempo, O(1) espacio Solución clásica def fizzbuzz(n) result for i in range(1, n 1) if i 15 0 result. append(FizzBuzz) elif i 3 0 result. append(Fizz) elif i 5 0 result. append(Buzz) else result. append(str(i)) return result Solución alternativa (más elegante) def fizzbuzz_elegant(n) result for i in range(1, n 1) output if i 3 0 output Fizz if i 5 0 output Buzz result. append(output or str(i)) return result Versión que imprime directamente def fizzbuzz_print(n) for i in range(1, n 1) if i 15 0 print(FizzBuzz) elif i 3 0 print(Fizz) elif i 5 0 print(Buzz) else print(i) Prueba print(fizzbuzz(15)) Output 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz"}
{"id": "a4c79939db", "mode": "general", "instruction": "Invierte una cadena sin usar slicing ([::-1]) ni funciones built-in como reversed().", "input": "s = \"hello\"", "output": "Estrategia 1. Usar dos punteros uno al inicio, otro al final 2. Intercambiar caracteres y mover punteros hacia el centro 3. Como strings son inmutables en Python, convertir a lista 4. Complejidad O(n) tiempo, O(n) espacio Solución con dos punteros def reverse_string(s) Convertir a lista (strings son inmutables) chars list(s) left 0 right len(chars) - 1 while left right Intercambiar caracteres charsleft, charsright charsright, charsleft left 1 right - 1 return. join(chars) Solución iterativa simple def reverse_string_iterative(s) result for i in range(len(s) - 1, -1, -1) result si return result Solución con lista y append (más eficiente que concatenación) def reverse_string_list(s) result for i in range(len(s) - 1, -1, -1) result. append(si) return. join(result) Solución recursiva def reverse_string_recursive(s) if len(s) 1 return s return reverse_string_recursive(s1) s0 Pruebas print(reverse_string(hello)) olleh print(reverse_string(Python)) nohtyP print(reverse_string(a)) a print(reverse_string())"}
{"id": "c11049d460", "mode": "general", "instruction": "Invierte una cadena sin usar slicing ([::-1]) ni funciones built-in como reversed(). con ejemplos de código?", "input": "s = \"hello\"", "output": "Estrategia 1. Usar dos punteros uno al inicio, otro al final 2. Intercambiar caracteres y mover punteros hacia el centro 3. Como strings son inmutables en Python, convertir a lista 4. Complejidad O(n) tiempo, O(n) espacio Solución con dos punteros def reverse_string(s) Convertir a lista (strings son inmutables) chars list(s) left 0 right len(chars) - 1 while left right Intercambiar caracteres charsleft, charsright charsright, charsleft left 1 right - 1 return. join(chars) Solución iterativa simple def reverse_string_iterative(s) result for i in range(len(s) - 1, -1, -1) result si return result Solución con lista y append (más eficiente que concatenación) def reverse_string_list(s) result for i in range(len(s) - 1, -1, -1) result. append(si) return. join(result) Solución recursiva def reverse_string_recursive(s) if len(s) 1 return s return reverse_string_recursive(s1) s0 Pruebas print(reverse_string(hello)) olleh print(reverse_string(Python)) nohtyP print(reverse_string(a)) a print(reverse_string())"}
{"id": "4c0674c296", "mode": "general", "instruction": "Invierte una cadena sin usar slicing ([::-1]) ni funciones built-in como reversed(). paso a paso?", "input": "s = \"hello\"", "output": "Estrategia 1. Usar dos punteros uno al inicio, otro al final 2. Intercambiar caracteres y mover punteros hacia el centro 3. Como strings son inmutables en Python, convertir a lista 4. Complejidad O(n) tiempo, O(n) espacio Solución con dos punteros def reverse_string(s) Convertir a lista (strings son inmutables) chars list(s) left 0 right len(chars) - 1 while left right Intercambiar caracteres charsleft, charsright charsright, charsleft left 1 right - 1 return. join(chars) Solución iterativa simple def reverse_string_iterative(s) result for i in range(len(s) - 1, -1, -1) result si return result Solución con lista y append (más eficiente que concatenación) def reverse_string_list(s) result for i in range(len(s) - 1, -1, -1) result. append(si) return. join(result) Solución recursiva def reverse_string_recursive(s) if len(s) 1 return s return reverse_string_recursive(s1) s0 Pruebas print(reverse_string(hello)) olleh print(reverse_string(Python)) nohtyP print(reverse_string(a)) a print(reverse_string())"}
{"id": "6b895fd2ad", "mode": "general", "instruction": "Verifica si los paréntesis en una expresión están balanceados. Considera paréntesis (), corchetes [] y llaves {}.", "input": "expression = \"{[()]}\"", "output": "Estrategia 1. Usar una pila (stack) para almacenar paréntesis de apertura 2. Al encontrar cierre, verificar que coincida con el último apertura 3. Al final, la pila debe estar vacía 4. Complejidad O(n) tiempo, O(n) espacio Solución con pila def is_balanced(expression) stack Mapeo de cierres a aperturas matching ) (,, for char in expression if char in ( Paréntesis de apertura agregar a pila stack. append(char) elif char in ) Paréntesis de cierre verificar coincidencia if not stack return False No hay apertura correspondiente if stack-1! matchingchar return False No coincide stack. pop() La pila debe estar vacía al final return len(stack) 0 Versión más detallada con mensajes def is_balanced_verbose(expression) stack matching ) (,, for i, char in enumerate(expression) if char in ( stack. append((char, i)) elif char in ) if not stack print(fError char en posición i no tiene apertura) return False last_open, pos stack-1 if last_open! matchingchar print(fError char en i no coincide con last_open en pos) return False stack. pop() if stack print(fError len(stack) paréntesis sin cerrar) return False return True Pruebas print(is_balanced(())) True print(is_balanced(())) False print(is_balanced(((())))) True print(is_balanced((())) False print(is_balanced()()) False print(is_balanced()) True"}
{"id": "866fce81ae", "mode": "general", "instruction": "Verifica si los paréntesis en una expresión están balanceados. Considera paréntesis (), corchetes [] y llaves {}. con ejemplos de código?", "input": "expression = \"{[()]}\"", "output": "Estrategia 1. Usar una pila (stack) para almacenar paréntesis de apertura 2. Al encontrar cierre, verificar que coincida con el último apertura 3. Al final, la pila debe estar vacía 4. Complejidad O(n) tiempo, O(n) espacio Solución con pila def is_balanced(expression) stack Mapeo de cierres a aperturas matching ) (,, for char in expression if char in ( Paréntesis de apertura agregar a pila stack. append(char) elif char in ) Paréntesis de cierre verificar coincidencia if not stack return False No hay apertura correspondiente if stack-1! matchingchar return False No coincide stack. pop() La pila debe estar vacía al final return len(stack) 0 Versión más detallada con mensajes def is_balanced_verbose(expression) stack matching ) (,, for i, char in enumerate(expression) if char in ( stack. append((char, i)) elif char in ) if not stack print(fError char en posición i no tiene apertura) return False last_open, pos stack-1 if last_open! matchingchar print(fError char en i no coincide con last_open en pos) return False stack. pop() if stack print(fError len(stack) paréntesis sin cerrar) return False return True Pruebas print(is_balanced(())) True print(is_balanced(())) False print(is_balanced(((())))) True print(is_balanced((())) False print(is_balanced()()) False print(is_balanced()) True"}
{"id": "01f232a406", "mode": "general", "instruction": "Verifica si los paréntesis en una expresión están balanceados. Considera paréntesis (), corchetes [] y llaves {}. paso a paso?", "input": "expression = \"{[()]}\"", "output": "Estrategia 1. Usar una pila (stack) para almacenar paréntesis de apertura 2. Al encontrar cierre, verificar que coincida con el último apertura 3. Al final, la pila debe estar vacía 4. Complejidad O(n) tiempo, O(n) espacio Solución con pila def is_balanced(expression) stack Mapeo de cierres a aperturas matching ) (,, for char in expression if char in ( Paréntesis de apertura agregar a pila stack. append(char) elif char in ) Paréntesis de cierre verificar coincidencia if not stack return False No hay apertura correspondiente if stack-1! matchingchar return False No coincide stack. pop() La pila debe estar vacía al final return len(stack) 0 Versión más detallada con mensajes def is_balanced_verbose(expression) stack matching ) (,, for i, char in enumerate(expression) if char in ( stack. append((char, i)) elif char in ) if not stack print(fError char en posición i no tiene apertura) return False last_open, pos stack-1 if last_open! matchingchar print(fError char en i no coincide con last_open en pos) return False stack. pop() if stack print(fError len(stack) paréntesis sin cerrar) return False return True Pruebas print(is_balanced(())) True print(is_balanced(())) False print(is_balanced(((())))) True print(is_balanced((())) False print(is_balanced()()) False print(is_balanced()) True"}
{"id": "85e5ef0dca", "mode": "general", "instruction": "Encuentra el primer carácter no repetido en una cadena. Si todos se repiten, retorna None.", "input": "s = \"leetcode\"", "output": "Estrategia 1. Contar frecuencia de cada carácter (un solo recorrido) 2. Segundo recorrido encontrar primer carácter con frecuencia 1 3. Complejidad O(n) tiempo, O(k) espacio donde k es caracteres únicos Solución con diccionario def first_unique_char(s) Contar frecuencias char_count for char in s char_countchar char_count. get(char, 0) 1 Encontrar primer carácter con frecuencia 1 for char in s if char_countchar 1 return char return None Solución con Counter (más pythónica) from collections import Counter def first_unique_char_counter(s) count Counter(s) for char in s if countchar 1 return char return None Solución que retorna índice en lugar del carácter def first_unique_char_index(s) char_count for char in s char_countchar char_count. get(char, 0) 1 for i, char in enumerate(s) if char_countchar 1 return i return -1 Pruebas print(first_unique_char(leetcode)) l print(first_unique_char(loveleetcode)) v print(first_unique_char(aabb)) None print(first_unique_char_index(leetcode)) 0"}
{"id": "72e8199fbc", "mode": "general", "instruction": "Encuentra el primer carácter no repetido en una cadena. Si todos se repiten, retorna None. con ejemplos de código?", "input": "s = \"leetcode\"", "output": "Estrategia 1. Contar frecuencia de cada carácter (un solo recorrido) 2. Segundo recorrido encontrar primer carácter con frecuencia 1 3. Complejidad O(n) tiempo, O(k) espacio donde k es caracteres únicos Solución con diccionario def first_unique_char(s) Contar frecuencias char_count for char in s char_countchar char_count. get(char, 0) 1 Encontrar primer carácter con frecuencia 1 for char in s if char_countchar 1 return char return None Solución con Counter (más pythónica) from collections import Counter def first_unique_char_counter(s) count Counter(s) for char in s if countchar 1 return char return None Solución que retorna índice en lugar del carácter def first_unique_char_index(s) char_count for char in s char_countchar char_count. get(char, 0) 1 for i, char in enumerate(s) if char_countchar 1 return i return -1 Pruebas print(first_unique_char(leetcode)) l print(first_unique_char(loveleetcode)) v print(first_unique_char(aabb)) None print(first_unique_char_index(leetcode)) 0"}
{"id": "ed5e2c8b08", "mode": "general", "instruction": "Encuentra el primer carácter no repetido en una cadena. Si todos se repiten, retorna None. paso a paso?", "input": "s = \"leetcode\"", "output": "Estrategia 1. Contar frecuencia de cada carácter (un solo recorrido) 2. Segundo recorrido encontrar primer carácter con frecuencia 1 3. Complejidad O(n) tiempo, O(k) espacio donde k es caracteres únicos Solución con diccionario def first_unique_char(s) Contar frecuencias char_count for char in s char_countchar char_count. get(char, 0) 1 Encontrar primer carácter con frecuencia 1 for char in s if char_countchar 1 return char return None Solución con Counter (más pythónica) from collections import Counter def first_unique_char_counter(s) count Counter(s) for char in s if countchar 1 return char return None Solución que retorna índice en lugar del carácter def first_unique_char_index(s) char_count for char in s char_countchar char_count. get(char, 0) 1 for i, char in enumerate(s) if char_countchar 1 return i return -1 Pruebas print(first_unique_char(leetcode)) l print(first_unique_char(loveleetcode)) v print(first_unique_char(aabb)) None print(first_unique_char_index(leetcode)) 0"}
{"id": "395903b68a", "mode": "general", "instruction": "Verifica si una cadena es palíndromo ignorando espacios, puntuación y diferencias de mayúsculas/minúsculas.", "input": "s = \"A man, a plan, a canal: Panama\"", "output": "Estrategia 1. Limpiar la cadena solo caracteres alfanuméricos en minúsculas 2. Aplicar verificación de palíndromo estándar 3. Opción dos punteros sobre cadena original (más eficiente en espacio) 4. Complejidad O(n) tiempo, O(1) o O(n) espacio según método Solución 1 Limpiando la cadena primero def is_palindrome_clean(s) Filtrar y convertir a minúsculas cleaned. join(char. lower() for char in s if char. isalnum()) Verificar palíndromo left 0 right len(cleaned) - 1 while left right if cleanedleft! cleanedright return False left 1 right - 1 return True Solución 2 Dos punteros sin crear cadena nueva (O(1) espacio) def is_palindrome_two_pointers(s) left 0 right len(s) - 1 while left right Saltar caracteres no alfanuméricos desde la izquierda while left right and not sleft. isalnum() left 1 Saltar caracteres no alfanuméricos desde la derecha while left right and not sright. isalnum() right - 1 Comparar caracteres en minúsculas if sleft. lower()! sright. lower() return False left 1 right - 1 return True Solución 3 Usando expresiones regulares import re def is_palindrome_regex(s) Remover todo excepto alfanuméricos cleaned re. sub(ra-zA-Z0-9,, s). lower() return cleaned cleaned-1 Pruebas test1 A man, a plan, a canal Panama test2 race a car test3 Was it a car or a cat I saw? print(is_palindrome_clean(test1)) True print(is_palindrome_clean(test2)) False print(is_palindrome_two_pointers(test3)) True"}
{"id": "18f8261417", "mode": "general", "instruction": "Verifica si una cadena es palíndromo ignorando espacios, puntuación y diferencias de mayúsculas/minúsculas. con ejemplos de código?", "input": "s = \"A man, a plan, a canal: Panama\"", "output": "Estrategia 1. Limpiar la cadena solo caracteres alfanuméricos en minúsculas 2. Aplicar verificación de palíndromo estándar 3. Opción dos punteros sobre cadena original (más eficiente en espacio) 4. Complejidad O(n) tiempo, O(1) o O(n) espacio según método Solución 1 Limpiando la cadena primero def is_palindrome_clean(s) Filtrar y convertir a minúsculas cleaned. join(char. lower() for char in s if char. isalnum()) Verificar palíndromo left 0 right len(cleaned) - 1 while left right if cleanedleft! cleanedright return False left 1 right - 1 return True Solución 2 Dos punteros sin crear cadena nueva (O(1) espacio) def is_palindrome_two_pointers(s) left 0 right len(s) - 1 while left right Saltar caracteres no alfanuméricos desde la izquierda while left right and not sleft. isalnum() left 1 Saltar caracteres no alfanuméricos desde la derecha while left right and not sright. isalnum() right - 1 Comparar caracteres en minúsculas if sleft. lower()! sright. lower() return False left 1 right - 1 return True Solución 3 Usando expresiones regulares import re def is_palindrome_regex(s) Remover todo excepto alfanuméricos cleaned re. sub(ra-zA-Z0-9,, s). lower() return cleaned cleaned-1 Pruebas test1 A man, a plan, a canal Panama test2 race a car test3 Was it a car or a cat I saw? print(is_palindrome_clean(test1)) True print(is_palindrome_clean(test2)) False print(is_palindrome_two_pointers(test3)) True"}
{"id": "47f9ce4380", "mode": "general", "instruction": "Verifica si una cadena es palíndromo ignorando espacios, puntuación y diferencias de mayúsculas/minúsculas. paso a paso?", "input": "s = \"A man, a plan, a canal: Panama\"", "output": "Estrategia 1. Limpiar la cadena solo caracteres alfanuméricos en minúsculas 2. Aplicar verificación de palíndromo estándar 3. Opción dos punteros sobre cadena original (más eficiente en espacio) 4. Complejidad O(n) tiempo, O(1) o O(n) espacio según método Solución 1 Limpiando la cadena primero def is_palindrome_clean(s) Filtrar y convertir a minúsculas cleaned. join(char. lower() for char in s if char. isalnum()) Verificar palíndromo left 0 right len(cleaned) - 1 while left right if cleanedleft! cleanedright return False left 1 right - 1 return True Solución 2 Dos punteros sin crear cadena nueva (O(1) espacio) def is_palindrome_two_pointers(s) left 0 right len(s) - 1 while left right Saltar caracteres no alfanuméricos desde la izquierda while left right and not sleft. isalnum() left 1 Saltar caracteres no alfanuméricos desde la derecha while left right and not sright. isalnum() right - 1 Comparar caracteres en minúsculas if sleft. lower()! sright. lower() return False left 1 right - 1 return True Solución 3 Usando expresiones regulares import re def is_palindrome_regex(s) Remover todo excepto alfanuméricos cleaned re. sub(ra-zA-Z0-9,, s). lower() return cleaned cleaned-1 Pruebas test1 A man, a plan, a canal Panama test2 race a car test3 Was it a car or a cat I saw? print(is_palindrome_clean(test1)) True print(is_palindrome_clean(test2)) False print(is_palindrome_two_pointers(test3)) True"}
{"id": "9acb6a69b8", "mode": "general", "instruction": "Rota un array k posiciones hacia la derecha. Por ejemplo, [1,2,3,4,5] rotado 2 posiciones es [4,5,1,2,3].", "input": "nums = [1, 2, 3, 4, 5, 6, 7] k = 3", "output": "Estrategia 1. Método simple usar slicing - O(n) tiempo, O(n) espacio 2. Método eficiente invertir partes del array - O(n) tiempo, O(1) espacio 3. Importante manejar k len(array) usando módulo Solución 1 Usando slicing (más simple) def rotate_array_slicing(nums, k) n len(nums) k k n Manejar k mayor que n return nums-k nums-k if k 0 else nums Solución 2 In-place con reversión (más eficiente) def rotate_array_reverse(nums, k) def reverse(arr, start, end) while start end arrstart, arrend arrend, arrstart start 1 end - 1 n len(nums) k k n Invertir todo el array reverse(nums, 0, n - 1) Invertir primeros k elementos reverse(nums, 0, k - 1) Invertir elementos restantes reverse(nums, k, n - 1) return nums Solución 3 Usando deque (muy pythónico) from collections import deque def rotate_array_deque(nums, k) d deque(nums) d. rotate(k) return list(d) Solución 4 Con un array auxiliar def rotate_array_extra(nums, k) n len(nums) k k n result 0 n for i in range(n) result(i k) n numsi return result Pruebas nums 1, 2, 3, 4, 5, 6, 7 print(rotate_array_slicing(nums, 3)) 5, 6, 7, 1, 2, 3, 4 print(rotate_array_reverse(nums, 3)) 5, 6, 7, 1, 2, 3, 4 print(rotate_array_deque(nums, 3)) 5, 6, 7, 1, 2, 3, 4 Caso especial k len(array) print(rotate_array_slicing(1, 2, 5)) 2, 1 (k5 es equivalente a k1)"}
{"id": "b88b350030", "mode": "general", "instruction": "Rota un array k posiciones hacia la derecha. Por ejemplo, [1,2,3,4,5] rotado 2 posiciones es [4,5,1,2,3]. paso a paso?", "input": "nums = [1, 2, 3, 4, 5, 6, 7] k = 3", "output": "Estrategia 1. Método simple usar slicing - O(n) tiempo, O(n) espacio 2. Método eficiente invertir partes del array - O(n) tiempo, O(1) espacio 3. Importante manejar k len(array) usando módulo Solución 1 Usando slicing (más simple) def rotate_array_slicing(nums, k) n len(nums) k k n Manejar k mayor que n return nums-k nums-k if k 0 else nums Solución 2 In-place con reversión (más eficiente) def rotate_array_reverse(nums, k) def reverse(arr, start, end) while start end arrstart, arrend arrend, arrstart start 1 end - 1 n len(nums) k k n Invertir todo el array reverse(nums, 0, n - 1) Invertir primeros k elementos reverse(nums, 0, k - 1) Invertir elementos restantes reverse(nums, k, n - 1) return nums Solución 3 Usando deque (muy pythónico) from collections import deque def rotate_array_deque(nums, k) d deque(nums) d. rotate(k) return list(d) Solución 4 Con un array auxiliar def rotate_array_extra(nums, k) n len(nums) k k n result 0 n for i in range(n) result(i k) n numsi return result Pruebas nums 1, 2, 3, 4, 5, 6, 7 print(rotate_array_slicing(nums, 3)) 5, 6, 7, 1, 2, 3, 4 print(rotate_array_reverse(nums, 3)) 5, 6, 7, 1, 2, 3, 4 print(rotate_array_deque(nums, 3)) 5, 6, 7, 1, 2, 3, 4 Caso especial k len(array) print(rotate_array_slicing(1, 2, 5)) 2, 1 (k5 es equivalente a k1)"}
{"id": "4c58c52ca2", "mode": "general", "instruction": "Resuelve el problema Two Sum: dado un array de enteros y un target, encuentra dos números que sumen el target. Retorna sus índices.", "input": "nums = [2, 7, 11, 15] target = 9", "output": "Estrategia 1. Método ingenuo dos bucles anidados - O(n²) tiempo 2. Método óptimo usar hash map para búsqueda O(1) - O(n) tiempo, O(n) espacio 3. Guardar complementos mientras recorremos el array Solución 1 Fuerza bruta (O(n²)) def two_sum_brute(nums, target) for i in range(len(nums)) for j in range(i 1, len(nums)) if numsi numsj target return i, j return None Solución 2 Hash Map (O(n)) - ÓPTIMA def two_sum_hash(nums, target) seen valor - índice for i, num in enumerate(nums) complement target - num Si el complemento ya fue visto, encontramos la pareja if complement in seen return seencomplement, i Guardar el número actual y su índice seennum i return None Solución 3 Con explicación detallada def two_sum_verbose(nums, target) seen for i, num in enumerate(nums) complement target - num print(fÍndice i númeronum, necesitocomplement) if complement in seen print(f¡Encontrado! numsseencomplement num target) return seencomplement, i seennum i print(fGuardando num en índice i) return None Solución 4 Retornar todos los pares (si hay múltiples soluciones) def two_sum_all_pairs(nums, target) seen result for i, num in enumerate(nums) complement target - num if complement in seen result. append(seencomplement, i) seennum i return result Pruebas nums 2, 7, 11, 15 print(two_sum_hash(nums, 9)) 0, 1 print(two_sum_hash(3, 2, 4, 6)) 1, 2 print(two_sum_hash(3, 3, 6)) 0, 1 print(two_sum_all_pairs(1, 5, 3, 7, 2, 8)) 1, 2, 3, 4"}
{"id": "ea3252d6d9", "mode": "general", "instruction": "Resuelve el problema Two Sum: dado un array de enteros y un target, encuentra dos números que sumen el target. Retorna sus índices. con ejemplos de código?", "input": "nums = [2, 7, 11, 15] target = 9", "output": "Estrategia 1. Método ingenuo dos bucles anidados - O(n²) tiempo 2. Método óptimo usar hash map para búsqueda O(1) - O(n) tiempo, O(n) espacio 3. Guardar complementos mientras recorremos el array Solución 1 Fuerza bruta (O(n²)) def two_sum_brute(nums, target) for i in range(len(nums)) for j in range(i 1, len(nums)) if numsi numsj target return i, j return None Solución 2 Hash Map (O(n)) - ÓPTIMA def two_sum_hash(nums, target) seen valor - índice for i, num in enumerate(nums) complement target - num Si el complemento ya fue visto, encontramos la pareja if complement in seen return seencomplement, i Guardar el número actual y su índice seennum i return None Solución 3 Con explicación detallada def two_sum_verbose(nums, target) seen for i, num in enumerate(nums) complement target - num print(fÍndice i númeronum, necesitocomplement) if complement in seen print(f¡Encontrado! numsseencomplement num target) return seencomplement, i seennum i print(fGuardando num en índice i) return None Solución 4 Retornar todos los pares (si hay múltiples soluciones) def two_sum_all_pairs(nums, target) seen result for i, num in enumerate(nums) complement target - num if complement in seen result. append(seencomplement, i) seennum i return result Pruebas nums 2, 7, 11, 15 print(two_sum_hash(nums, 9)) 0, 1 print(two_sum_hash(3, 2, 4, 6)) 1, 2 print(two_sum_hash(3, 3, 6)) 0, 1 print(two_sum_all_pairs(1, 5, 3, 7, 2, 8)) 1, 2, 3, 4"}
{"id": "cc43acabe3", "mode": "general", "instruction": "Resuelve el problema Two Sum: dado un array de enteros y un target, encuentra dos números que sumen el target. Retorna sus índices. paso a paso?", "input": "nums = [2, 7, 11, 15] target = 9", "output": "Estrategia 1. Método ingenuo dos bucles anidados - O(n²) tiempo 2. Método óptimo usar hash map para búsqueda O(1) - O(n) tiempo, O(n) espacio 3. Guardar complementos mientras recorremos el array Solución 1 Fuerza bruta (O(n²)) def two_sum_brute(nums, target) for i in range(len(nums)) for j in range(i 1, len(nums)) if numsi numsj target return i, j return None Solución 2 Hash Map (O(n)) - ÓPTIMA def two_sum_hash(nums, target) seen valor - índice for i, num in enumerate(nums) complement target - num Si el complemento ya fue visto, encontramos la pareja if complement in seen return seencomplement, i Guardar el número actual y su índice seennum i return None Solución 3 Con explicación detallada def two_sum_verbose(nums, target) seen for i, num in enumerate(nums) complement target - num print(fÍndice i númeronum, necesitocomplement) if complement in seen print(f¡Encontrado! numsseencomplement num target) return seencomplement, i seennum i print(fGuardando num en índice i) return None Solución 4 Retornar todos los pares (si hay múltiples soluciones) def two_sum_all_pairs(nums, target) seen result for i, num in enumerate(nums) complement target - num if complement in seen result. append(seencomplement, i) seennum i return result Pruebas nums 2, 7, 11, 15 print(two_sum_hash(nums, 9)) 0, 1 print(two_sum_hash(3, 2, 4, 6)) 1, 2 print(two_sum_hash(3, 3, 6)) 0, 1 print(two_sum_all_pairs(1, 5, 3, 7, 2, 8)) 1, 2, 3, 4"}
{"id": "d6ae664ef3", "mode": "general", "instruction": "Elimina los duplicados de un array in-place (modificando el array original) y retorna la nueva longitud. Los elementos únicos deben estar al inicio del array.", "input": "nums = [1, 1, 2, 2, 3, 4, 4, 5]", "output": "Estrategia 1. Usar dos punteros uno para leer, otro para escribir elementos únicos 2. El array debe estar ordenado (o ordenarlo primero) 3. Complejidad O(n) tiempo, O(1) espacio 4. Alternativa usar set pero no es in-place Solución con dos punteros (array ordenado) def remove_duplicates(nums) if not nums return 0 Puntero de escritura (posición del siguiente único) write_pos 1 Iterar desde el segundo elemento for read_pos in range(1, len(nums)) Si el elemento actual es diferente al anterior if numsread_pos! numsread_pos - 1 numswrite_pos numsread_pos write_pos 1 return write_pos Solución alternativa (comparando con último único) def remove_duplicates_alt(nums) if not nums return 0 unique_count 1 for i in range(1, len(nums)) Comparar con el último elemento único if numsi! numsunique_count - 1 numsunique_count numsi unique_count 1 return unique_count Solución para array no ordenado (usando set, no in-place puro) def remove_duplicates_unordered(nums) seen set() write_pos 0 for num in nums if num not in seen seen. add(num) numswrite_pos num write_pos 1 return write_pos Función auxiliar para mostrar resultado def test_remove_duplicates(nums) print(fOriginal nums) length remove_duplicates(nums) print(fDespués numslength) print(fNueva longitud lengthn) Pruebas test_remove_duplicates(1, 1, 2, 2, 3, 4, 4, 5) Output 1, 2, 3, 4, 5, longitud 5 test_remove_duplicates(1, 1, 1, 1) Output 1, longitud 1 test_remove_duplicates(1, 2, 3, 4, 5) Output 1, 2, 3, 4, 5, longitud 5 Para array no ordenado nums_unordered 4, 2, 4, 1, 2, 3 length remove_duplicates_unordered(nums_unordered) print(fNo ordenado nums_unorderedlength) 4, 2, 1, 3"}
{"id": "ca3c1f582c", "mode": "general", "instruction": "Elimina los duplicados de un array in-place (modificando el array original) y retorna la nueva longitud. Los elementos únicos deben estar al inicio del array. con ejemplos de código?", "input": "nums = [1, 1, 2, 2, 3, 4, 4, 5]", "output": "Estrategia 1. Usar dos punteros uno para leer, otro para escribir elementos únicos 2. El array debe estar ordenado (o ordenarlo primero) 3. Complejidad O(n) tiempo, O(1) espacio 4. Alternativa usar set pero no es in-place Solución con dos punteros (array ordenado) def remove_duplicates(nums) if not nums return 0 Puntero de escritura (posición del siguiente único) write_pos 1 Iterar desde el segundo elemento for read_pos in range(1, len(nums)) Si el elemento actual es diferente al anterior if numsread_pos! numsread_pos - 1 numswrite_pos numsread_pos write_pos 1 return write_pos Solución alternativa (comparando con último único) def remove_duplicates_alt(nums) if not nums return 0 unique_count 1 for i in range(1, len(nums)) Comparar con el último elemento único if numsi! numsunique_count - 1 numsunique_count numsi unique_count 1 return unique_count Solución para array no ordenado (usando set, no in-place puro) def remove_duplicates_unordered(nums) seen set() write_pos 0 for num in nums if num not in seen seen. add(num) numswrite_pos num write_pos 1 return write_pos Función auxiliar para mostrar resultado def test_remove_duplicates(nums) print(fOriginal nums) length remove_duplicates(nums) print(fDespués numslength) print(fNueva longitud lengthn) Pruebas test_remove_duplicates(1, 1, 2, 2, 3, 4, 4, 5) Output 1, 2, 3, 4, 5, longitud 5 test_remove_duplicates(1, 1, 1, 1) Output 1, longitud 1 test_remove_duplicates(1, 2, 3, 4, 5) Output 1, 2, 3, 4, 5, longitud 5 Para array no ordenado nums_unordered 4, 2, 4, 1, 2, 3 length remove_duplicates_unordered(nums_unordered) print(fNo ordenado nums_unorderedlength) 4, 2, 1, 3"}
{"id": "98b332f350", "mode": "general", "instruction": "Elimina los duplicados de un array in-place (modificando el array original) y retorna la nueva longitud. Los elementos únicos deben estar al inicio del array. paso a paso?", "input": "nums = [1, 1, 2, 2, 3, 4, 4, 5]", "output": "Estrategia 1. Usar dos punteros uno para leer, otro para escribir elementos únicos 2. El array debe estar ordenado (o ordenarlo primero) 3. Complejidad O(n) tiempo, O(1) espacio 4. Alternativa usar set pero no es in-place Solución con dos punteros (array ordenado) def remove_duplicates(nums) if not nums return 0 Puntero de escritura (posición del siguiente único) write_pos 1 Iterar desde el segundo elemento for read_pos in range(1, len(nums)) Si el elemento actual es diferente al anterior if numsread_pos! numsread_pos - 1 numswrite_pos numsread_pos write_pos 1 return write_pos Solución alternativa (comparando con último único) def remove_duplicates_alt(nums) if not nums return 0 unique_count 1 for i in range(1, len(nums)) Comparar con el último elemento único if numsi! numsunique_count - 1 numsunique_count numsi unique_count 1 return unique_count Solución para array no ordenado (usando set, no in-place puro) def remove_duplicates_unordered(nums) seen set() write_pos 0 for num in nums if num not in seen seen. add(num) numswrite_pos num write_pos 1 return write_pos Función auxiliar para mostrar resultado def test_remove_duplicates(nums) print(fOriginal nums) length remove_duplicates(nums) print(fDespués numslength) print(fNueva longitud lengthn) Pruebas test_remove_duplicates(1, 1, 2, 2, 3, 4, 4, 5) Output 1, 2, 3, 4, 5, longitud 5 test_remove_duplicates(1, 1, 1, 1) Output 1, longitud 1 test_remove_duplicates(1, 2, 3, 4, 5) Output 1, 2, 3, 4, 5, longitud 5 Para array no ordenado nums_unordered 4, 2, 4, 1, 2, 3 length remove_duplicates_unordered(nums_unordered) print(fNo ordenado nums_unorderedlength) 4, 2, 1, 3"}
{"id": "62714ab010", "mode": "general", "instruction": "Implementa Two Sum en O(n) y explica la idea.", "input": "nums = [2,7,11,15], target = 9", "output": "usa un diccionario para recordar lo que necesitas. Recorre la lista, para cada num calcula complemento target - num, si complemento ya está en el diccionario, tienes la respuesta; si no, guarda num con su índice. Complejidad O(n) tiempo, O(n) espacio."}
{"id": "3c022a8134", "mode": "general", "instruction": "Implementa Two Sum en O(n) y explica la idea. con ejemplos de código?", "input": "nums = [2,7,11,15], target = 9", "output": "usa un diccionario para recordar lo que necesitas. Recorre la lista, para cada num calcula complemento target - num, si complemento ya está en el diccionario, tienes la respuesta; si no, guarda num con su índice. Complejidad O(n) tiempo, O(n) espacio."}
{"id": "76375fe3f4", "mode": "general", "instruction": "Implementa Two Sum en O(n) y explica la idea. paso a paso?", "input": "nums = [2,7,11,15], target = 9", "output": "usa un diccionario para recordar lo que necesitas. Recorre la lista, para cada num calcula complemento target - num, si complemento ya está en el diccionario, tienes la respuesta; si no, guarda num con su índice. Complejidad O(n) tiempo, O(n) espacio."}
{"id": "2f4ae107da", "mode": "general", "instruction": "Rota un arreglo k posiciones a la derecha sin usar arreglo extra grande.", "input": "nums = [1,2,3,4,5,6,7], k = 3", "output": "normaliza k con k len(nums), invierte todo, luego invierte los primeros k y después el resto. Tres inversiones in-place dan la rotación. Complejidad O(n) tiempo, O(1) espacio."}
{"id": "520b4ef1b0", "mode": "general", "instruction": "Rota un arreglo k posiciones a la derecha sin usar arreglo extra grande. con ejemplos de código?", "input": "nums = [1,2,3,4,5,6,7], k = 3", "output": "normaliza k con k len(nums), invierte todo, luego invierte los primeros k y después el resto. Tres inversiones in-place dan la rotación. Complejidad O(n) tiempo, O(1) espacio."}
{"id": "3da061d4be", "mode": "general", "instruction": "Rota un arreglo k posiciones a la derecha sin usar arreglo extra grande. paso a paso?", "input": "nums = [1,2,3,4,5,6,7], k = 3", "output": "normaliza k con k len(nums), invierte todo, luego invierte los primeros k y después el resto. Tres inversiones in-place dan la rotación. Complejidad O(n) tiempo, O(1) espacio."}
{"id": "fc9810f05f", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO SumaMatriz VARIABLES matriz[3][3]: ENTERO suma: ENTERO i, j: ENTERO INICIO suma <- 0 PARA i DE 1 A 3 HACER PARA j DE 1 A 3 HACER suma <- suma + matriz[i][j] FIN_PARA FIN_PARA ESCRIBIR suma FIN", "output": "Código Python equivalente matriz 1, 2, 3, 4, 5, 6, 7, 8, 9 Ejemplo de inicialización suma 0 for i in range(3) for j in range(3) suma suma matrizij print(suma) Diferencias sintácticas 1. Python usa range(3) que genera índices 0, 1, 2 (no 1, 2, 3 como el pseudocódigo). 2. La flecha de asignación - se convierte en. 3. Los bloques se definen por indentación, no por palabras clave FIN_PARA. 4. ESCRIBIR se convierte en print(). 5. Python accede a matrices con ij igual que el pseudocódigo, pero los índices comienzan en 0."}
{"id": "d76c6a2fb0", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO SumaMatriz VARIABLES matriz[3][3]: ENTERO suma: ENTERO i, j: ENTERO INICIO suma <- 0 PARA i DE 1 A 3 HACER PARA j DE 1 A 3 HACER suma <- suma + matriz[i][j] FIN_PARA FIN_PARA ESCRIBIR suma FIN", "output": "Código Python equivalente matriz 1, 2, 3, 4, 5, 6, 7, 8, 9 Ejemplo de inicialización suma 0 for i in range(3) for j in range(3) suma suma matrizij print(suma) Diferencias sintácticas 1. Python usa range(3) que genera índices 0, 1, 2 (no 1, 2, 3 como el pseudocódigo). 2. La flecha de asignación - se convierte en. 3. Los bloques se definen por indentación, no por palabras clave FIN_PARA. 4. ESCRIBIR se convierte en print(). 5. Python accede a matrices con ij igual que el pseudocódigo, pero los índices comienzan en 0."}
{"id": "e23f4c67e3", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO NumeroMayor VARIABLES a, b, c, mayor: ENTERO INICIO LEER a, b, c SI (a > b) Y (a > c) ENTONCES mayor <- a SINO SI (b > a) Y (b > c) ENTONCES mayor <- b SINO mayor <- c FIN_SI ESCRIBIR \"El mayor es: \", mayor FIN", "output": "Código Python equivalente a int(input(Ingrese a )) b int(input(Ingrese b )) c int(input(Ingrese c )) if (a b) and (a c) mayor a elif (b a) and (b c) mayor b else mayor c print(El mayor es, mayor) Diferencias sintácticas 1. LEER se convierte en input() envuelto en int() para convertir a entero. 2. SI se convierte en if, SINO SI en elif, y SINO en else. 3. Y lógico se escribe como and en Python (también existe or para O, y not para NO). 4. Los bloques condicionales usan al final y se definen por indentación. 5. No se necesita FIN_SI explícito, la indentación marca el fin del bloque."}
{"id": "4f9e27ca2a", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO NumeroMayor VARIABLES a, b, c, mayor: ENTERO INICIO LEER a, b, c SI (a > b) Y (a > c) ENTONCES mayor <- a SINO SI (b > a) Y (b > c) ENTONCES mayor <- b SINO mayor <- c FIN_SI ESCRIBIR \"El mayor es: \", mayor FIN", "output": "Código Python equivalente a int(input(Ingrese a )) b int(input(Ingrese b )) c int(input(Ingrese c )) if (a b) and (a c) mayor a elif (b a) and (b c) mayor b else mayor c print(El mayor es, mayor) Diferencias sintácticas 1. LEER se convierte en input() envuelto en int() para convertir a entero. 2. SI se convierte en if, SINO SI en elif, y SINO en else. 3. Y lógico se escribe como and en Python (también existe or para O, y not para NO). 4. Los bloques condicionales usan al final y se definen por indentación. 5. No se necesita FIN_SI explícito, la indentación marca el fin del bloque."}
{"id": "d5bdcccf03", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO AlgoritmoEuclides VARIABLES a, b, temp: ENTERO INICIO LEER a, b MIENTRAS b!= 0 HACER temp <- b b <- a MOD b a <- temp FIN_MIENTRAS ESCRIBIR \"MCD es: \", a FIN", "output": "Código Python equivalente a int(input(Ingrese a )) b int(input(Ingrese b )) while b! 0 temp b b a b a temp print(MCD es, a) Diferencias sintácticas 1. MIENTRAS se convierte en while seguido de y el bloque indentado. 2. MOD (módulo) en Python se representa con el operador. 3.! es el operador de desigualdad tanto en pseudocódigo como en Python. 4. No se necesita FIN_MIENTRAS, el fin del bucle se determina por la indentación. 5. Este es el algoritmo de Euclides clásico para encontrar el Máximo Común Divisor."}
{"id": "8c296fd5df", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO AlgoritmoEuclides VARIABLES a, b, temp: ENTERO INICIO LEER a, b MIENTRAS b!= 0 HACER temp <- b b <- a MOD b a <- temp FIN_MIENTRAS ESCRIBIR \"MCD es: \", a FIN", "output": "Código Python equivalente a int(input(Ingrese a )) b int(input(Ingrese b )) while b! 0 temp b b a b a temp print(MCD es, a) Diferencias sintácticas 1. MIENTRAS se convierte en while seguido de y el bloque indentado. 2. MOD (módulo) en Python se representa con el operador. 3.! es el operador de desigualdad tanto en pseudocódigo como en Python. 4. No se necesita FIN_MIENTRAS, el fin del bucle se determina por la indentación. 5. Este es el algoritmo de Euclides clásico para encontrar el Máximo Común Divisor."}
{"id": "4839183217", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO BusquedaElemento VARIABLES arreglo[10]: ENTERO buscar, i: ENTERO encontrado: BOOLEANO INICIO encontrado <- FALSO LEER buscar PARA i DE 1 A 10 HACER SI arreglo[i] = buscar ENTONCES encontrado <- VERDADERO ROMPER FIN_SI FIN_PARA SI encontrado ENTONCES ESCRIBIR \"Elemento encontrado\" SINO ESCRIBIR \"Elemento no encontrado\" FIN_SI FIN", "output": "Código Python equivalente arreglo 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 Ejemplo encontrado False buscar int(input(Ingrese número a buscar )) for i in range(10) if arregloi buscar encontrado True break if encontrado print(Elemento encontrado) else print(Elemento no encontrado) Diferencias sintácticas 1. BOOLEANO se maneja con True y False (capitalizados) en Python. 2. FALSO y VERDADERO se convierten en False y True. 3. ROMPER se convierte en break para salir del bucle anticipadamente. 4. El operador de igualdad en Python es (un solo es asignación). 5. range(10) genera índices 0-9, por lo que arregloi accede correctamente en Python."}
{"id": "a4a925b8ef", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO BusquedaElemento VARIABLES arreglo[10]: ENTERO buscar, i: ENTERO encontrado: BOOLEANO INICIO encontrado <- FALSO LEER buscar PARA i DE 1 A 10 HACER SI arreglo[i] = buscar ENTONCES encontrado <- VERDADERO ROMPER FIN_SI FIN_PARA SI encontrado ENTONCES ESCRIBIR \"Elemento encontrado\" SINO ESCRIBIR \"Elemento no encontrado\" FIN_SI FIN", "output": "Código Python equivalente arreglo 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 Ejemplo encontrado False buscar int(input(Ingrese número a buscar )) for i in range(10) if arregloi buscar encontrado True break if encontrado print(Elemento encontrado) else print(Elemento no encontrado) Diferencias sintácticas 1. BOOLEANO se maneja con True y False (capitalizados) en Python. 2. FALSO y VERDADERO se convierten en False y True. 3. ROMPER se convierte en break para salir del bucle anticipadamente. 4. El operador de igualdad en Python es (un solo es asignación). 5. range(10) genera índices 0-9, por lo que arregloi accede correctamente en Python."}
{"id": "c496b6402d", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO TablaMultiplicar VARIABLES numero, i, resultado: ENTERO INICIO LEER numero PARA i DE 1 A 10 HACER resultado <- numero * i ESCRIBIR numero, \" x \", i, \" = \", resultado FIN_PARA FIN", "output": "Código Python equivalente numero int(input(Ingrese número )) for i in range(1, 11) resultado numero i print(fnumero x i resultado) Diferencias sintácticas 1. range(1, 11) genera números del 1 al 10 (el límite superior es exclusivo). 2. Para iterar de 1 a N en pseudocódigo, usamos range(1, N1) en Python. 3. Usé f-strings (f...) para formateo de cadenas, más moderno que concatenación. 4. Alternativa clásica print(numero, x, i,, resultado) con comas. 5. El operador para multiplicación es idéntico en ambos lenguajes."}
{"id": "137b19a288", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO TablaMultiplicar VARIABLES numero, i, resultado: ENTERO INICIO LEER numero PARA i DE 1 A 10 HACER resultado <- numero * i ESCRIBIR numero, \" x \", i, \" = \", resultado FIN_PARA FIN", "output": "Código Python equivalente numero int(input(Ingrese número )) for i in range(1, 11) resultado numero i print(fnumero x i resultado) Diferencias sintácticas 1. range(1, 11) genera números del 1 al 10 (el límite superior es exclusivo). 2. Para iterar de 1 a N en pseudocódigo, usamos range(1, N1) en Python. 3. Usé f-strings (f...) para formateo de cadenas, más moderno que concatenación. 4. Alternativa clásica print(numero, x, i,, resultado) con comas. 5. El operador para multiplicación es idéntico en ambos lenguajes."}
{"id": "e14d36f9d9", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO FibonacciIterativo VARIABLES n, i, a, b, temp: ENTERO INICIO LEER n a <- 0 b <- 1 ESCRIBIR a ESCRIBIR b PARA i DE 3 A n HACER temp <- a + b a <- b b <- temp ESCRIBIR temp FIN_PARA FIN", "output": "Código Python equivalente n int(input(Ingrese cantidad de términos )) a 0 b 1 print(a) print(b) for i in range(3, n 1) temp a b a b b temp print(temp) Diferencias sintácticas 1. range(3, n 1) itera desde 3 hasta n inclusive (simulando DE 3 A n). 2. En Python, múltiples asignaciones se pueden hacer en una línea a, b b, a b. 3. Esta versión muestra la forma literal equivalente al pseudocódigo. 4. Alternativa pythónica for _ in range(n-2) temp a b; a, b b, temp; print(temp) 5. Los primeros dos términos (0, 1) se imprimen antes del bucle."}
{"id": "2f299fd358", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO FibonacciIterativo VARIABLES n, i, a, b, temp: ENTERO INICIO LEER n a <- 0 b <- 1 ESCRIBIR a ESCRIBIR b PARA i DE 3 A n HACER temp <- a + b a <- b b <- temp ESCRIBIR temp FIN_PARA FIN", "output": "Código Python equivalente n int(input(Ingrese cantidad de términos )) a 0 b 1 print(a) print(b) for i in range(3, n 1) temp a b a b b temp print(temp) Diferencias sintácticas 1. range(3, n 1) itera desde 3 hasta n inclusive (simulando DE 3 A n). 2. En Python, múltiples asignaciones se pueden hacer en una línea a, b b, a b. 3. Esta versión muestra la forma literal equivalente al pseudocódigo. 4. Alternativa pythónica for _ in range(n-2) temp a b; a, b b, temp; print(temp) 5. Los primeros dos términos (0, 1) se imprimen antes del bucle."}
{"id": "64874cb43e", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO OrdenamientoBurbuja VARIABLES arreglo[5]: ENTERO i, j, temp: ENTERO INICIO PARA i DE 1 A 4 HACER PARA j DE 1 A (5 - i) HACER SI arreglo[j] > arreglo[j+1] ENTONCES temp <- arreglo[j] arreglo[j] <- arreglo[j+1] arreglo[j+1] <- temp FIN_SI FIN_PARA FIN_PARA ESCRIBIR arreglo FIN", "output": "Código Python equivalente arreglo 64, 34, 25, 12, 22 Ejemplo de inicialización for i in range(4) for j in range(5 - i - 1) if arregloj arregloj 1 temp arregloj arregloj arregloj 1 arregloj 1 temp print(arreglo) Diferencias sintácticas 1. Ajuste crítico range(5 - i - 1) porque range genera índices base 0 y necesitamos evitar arregloj1 fuera de límites. 2. En pseudocódigo DE 1 A (5-i) incluye el límite, en Python range(5-i-1) genera 0 hasta 5-i-2. 3. Python permite intercambio elegante arregloj, arregloj1 arregloj1, arregloj sin variable temporal. 4. Esta es la implementación de Bubble Sort con bucles anidados. 5. print() puede mostrar listas directamente con formato a, b, c,...."}
{"id": "45c3fc871a", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO OrdenamientoBurbuja VARIABLES arreglo[5]: ENTERO i, j, temp: ENTERO INICIO PARA i DE 1 A 4 HACER PARA j DE 1 A (5 - i) HACER SI arreglo[j] > arreglo[j+1] ENTONCES temp <- arreglo[j] arreglo[j] <- arreglo[j+1] arreglo[j+1] <- temp FIN_SI FIN_PARA FIN_PARA ESCRIBIR arreglo FIN", "output": "Código Python equivalente arreglo 64, 34, 25, 12, 22 Ejemplo de inicialización for i in range(4) for j in range(5 - i - 1) if arregloj arregloj 1 temp arregloj arregloj arregloj 1 arregloj 1 temp print(arreglo) Diferencias sintácticas 1. Ajuste crítico range(5 - i - 1) porque range genera índices base 0 y necesitamos evitar arregloj1 fuera de límites. 2. En pseudocódigo DE 1 A (5-i) incluye el límite, en Python range(5-i-1) genera 0 hasta 5-i-2. 3. Python permite intercambio elegante arregloj, arregloj1 arregloj1, arregloj sin variable temporal. 4. Esta es la implementación de Bubble Sort con bucles anidados. 5. print() puede mostrar listas directamente con formato a, b, c,...."}
{"id": "1e4cb2f0da", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "FUNCIÓN Potencia(base, exponente: ENTERO): ENTERO VARIABLES resultado, i: ENTERO INICIO resultado <- 1 PARA i DE 1 A exponente HACER resultado <- resultado * base FIN_PARA RETORNAR resultado FIN_FUNCIÓN", "output": "Código Python equivalente def potencia(base, exponente) resultado 1 for i in range(1, exponente 1) resultado resultado base return resultado Ejemplo de uso print(potencia(2, 3)) Output 8 Diferencias sintácticas 1. FUNCIÓN se convierte en def nombre_funcion(parámetros). 2. Python no requiere declaración explícita de tipos en los parámetros. 3. RETORNAR se convierte en return. 4. FIN_FUNCIÓN no existe, el fin de la función se marca por cambio de indentación. 5. Python tiene operador para potencias base exponente sería más directo. 6. range(1, exponente 1) itera de 1 a exponente inclusive."}
{"id": "755bf0949b", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "FUNCIÓN Potencia(base, exponente: ENTERO): ENTERO VARIABLES resultado, i: ENTERO INICIO resultado <- 1 PARA i DE 1 A exponente HACER resultado <- resultado * base FIN_PARA RETORNAR resultado FIN_FUNCIÓN", "output": "Código Python equivalente def potencia(base, exponente) resultado 1 for i in range(1, exponente 1) resultado resultado base return resultado Ejemplo de uso print(potencia(2, 3)) Output 8 Diferencias sintácticas 1. FUNCIÓN se convierte en def nombre_funcion(parámetros). 2. Python no requiere declaración explícita de tipos en los parámetros. 3. RETORNAR se convierte en return. 4. FIN_FUNCIÓN no existe, el fin de la función se marca por cambio de indentación. 5. Python tiene operador para potencias base exponente sería más directo. 6. range(1, exponente 1) itera de 1 a exponente inclusive."}
{"id": "f3d2b4f51f", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO ContarParesImpares VARIABLES numeros[10]: ENTERO i, pares, impares: ENTERO INICIO pares <- 0 impares <- 0 PARA i DE 1 A 10 HACER SI numeros[i] MOD 2 = 0 ENTONCES pares <- pares + 1 SINO impares <- impares + 1 FIN_SI FIN_PARA ESCRIBIR \"Pares: \", pares ESCRIBIR \"Impares: \", impares FIN", "output": "Código Python equivalente numeros 12, 7, 5, 18, 3, 22, 9, 14, 6, 11 Ejemplo pares 0 impares 0 for i in range(10) if numerosi 2 0 pares pares 1 else impares impares 1 print(Pares, pares) print(Impares, impares) Diferencias sintácticas 1. MOD se representa con en Python para operación módulo. 2. Igualdad se verifica con no con (que es asignación). 3. Python permite incremento abreviado pares 1 en lugar de pares pares 1. 4. Alternativa pythónica for num in numeros itera directamente sobre valores sin índices. 5. Ejemplo pythónico completo pares sum(1 for n in numeros if n 2 0)"}
{"id": "0e15534b7a", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO ContarParesImpares VARIABLES numeros[10]: ENTERO i, pares, impares: ENTERO INICIO pares <- 0 impares <- 0 PARA i DE 1 A 10 HACER SI numeros[i] MOD 2 = 0 ENTONCES pares <- pares + 1 SINO impares <- impares + 1 FIN_SI FIN_PARA ESCRIBIR \"Pares: \", pares ESCRIBIR \"Impares: \", impares FIN", "output": "Código Python equivalente numeros 12, 7, 5, 18, 3, 22, 9, 14, 6, 11 Ejemplo pares 0 impares 0 for i in range(10) if numerosi 2 0 pares pares 1 else impares impares 1 print(Pares, pares) print(Impares, impares) Diferencias sintácticas 1. MOD se representa con en Python para operación módulo. 2. Igualdad se verifica con no con (que es asignación). 3. Python permite incremento abreviado pares 1 en lugar de pares pares 1. 4. Alternativa pythónica for num in numeros itera directamente sobre valores sin índices. 5. Ejemplo pythónico completo pares sum(1 for n in numeros if n 2 0)"}
{"id": "dfe480fd79", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO MCDEuclidesRecursivo FUNCIÓN MCD(a, b: ENTERO): ENTERO INICIO SI b = 0 ENTONCES RETORNAR a SINO RETORNAR MCD(b, a MOD b) FIN_SI FIN_FUNCIÓN INICIO_PROGRAMA VARIABLES num1, num2, resultado: ENTERO LEER num1, num2 resultado <- MCD(num1, num2) ESCRIBIR \"El MCD es: \", resultado FIN_PROGRAMA", "output": "Código Python equivalente def mcd(a, b) if b 0 return a else return mcd(b, a b) Programa principal num1 int(input(Ingrese primer número )) num2 int(input(Ingrese segundo número )) resultado mcd(num1, num2) print(El MCD es, resultado) Diferencias sintácticas 1. Función recursiva Python maneja la recursión igual que el pseudocódigo, llamándose a sí misma. 2. El caso base SI b 0 detiene la recursión y comienza el retorno. 3. a MOD b se escribe como a b en Python. 4. No existe separación INICIO_PROGRAMA, el código de nivel superior se ejecuta directamente. 5. Esta es la versión recursiva del algoritmo de Euclides (más elegante que la iterativa). 6. Python permite versión de una línea return a if b 0 else mcd(b, a b)."}
{"id": "ef2c4e6662", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO MCDEuclidesRecursivo FUNCIÓN MCD(a, b: ENTERO): ENTERO INICIO SI b = 0 ENTONCES RETORNAR a SINO RETORNAR MCD(b, a MOD b) FIN_SI FIN_FUNCIÓN INICIO_PROGRAMA VARIABLES num1, num2, resultado: ENTERO LEER num1, num2 resultado <- MCD(num1, num2) ESCRIBIR \"El MCD es: \", resultado FIN_PROGRAMA", "output": "Código Python equivalente def mcd(a, b) if b 0 return a else return mcd(b, a b) Programa principal num1 int(input(Ingrese primer número )) num2 int(input(Ingrese segundo número )) resultado mcd(num1, num2) print(El MCD es, resultado) Diferencias sintácticas 1. Función recursiva Python maneja la recursión igual que el pseudocódigo, llamándose a sí misma. 2. El caso base SI b 0 detiene la recursión y comienza el retorno. 3. a MOD b se escribe como a b en Python. 4. No existe separación INICIO_PROGRAMA, el código de nivel superior se ejecuta directamente. 5. Esta es la versión recursiva del algoritmo de Euclides (más elegante que la iterativa). 6. Python permite versión de una línea return a if b 0 else mcd(b, a b)."}
{"id": "b22a50e499", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO SumaPares VARIABLES suma: ENTERO i: ENTERO INICIO suma <- 0 PARA i DE 1 A 10 HACER SI i MOD 2 = 0 ENTONCES suma <- suma + i FIN_SI FIN_PARA ESCRIBIR suma FIN", "output": "Código Python equivalente suma 0 for i in range(1, 11) if i 2 0 suma i print(suma) Notas MOD es, el rango en Python termina en 10 con range(1, 11), y la indentación reemplaza los FIN_PARAFIN_SI."}
{"id": "b7f69217bd", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO SumaPares VARIABLES suma: ENTERO i: ENTERO INICIO suma <- 0 PARA i DE 1 A 10 HACER SI i MOD 2 = 0 ENTONCES suma <- suma + i FIN_SI FIN_PARA ESCRIBIR suma FIN", "output": "Código Python equivalente suma 0 for i in range(1, 11) if i 2 0 suma i print(suma) Notas MOD es, el rango en Python termina en 10 con range(1, 11), y la indentación reemplaza los FIN_PARAFIN_SI."}
{"id": "cc8c459a14", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo.", "input": "ALGORITMO ConteoRegresivo VARIABLES n: ENTERO INICIO LEER n MIENTRAS n > 0 HACER ESCRIBIR n n <- n - 1 FIN_MIENTRAS ESCRIBIR Despegue FIN", "output": "Código Python equivalente n int(input(Ingresa n )) while n 0 print(n) n - 1 print(Despegue) Diferencias MIENTRAS es while, el decremento es n - 1, y las comillas dobles en pseudocódigo se escriben como string normal en Python."}
{"id": "03253cc983", "mode": "general", "instruction": "Convierte este pseudocódigo a Python y explícalo. paso a paso?", "input": "ALGORITMO ConteoRegresivo VARIABLES n: ENTERO INICIO LEER n MIENTRAS n > 0 HACER ESCRIBIR n n <- n - 1 FIN_MIENTRAS ESCRIBIR Despegue FIN", "output": "Código Python equivalente n int(input(Ingresa n )) while n 0 print(n) n - 1 print(Despegue) Diferencias MIENTRAS es while, el decremento es n - 1, y las comillas dobles en pseudocódigo se escriben como string normal en Python."}
{"id": "18fdcb22f5", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de dijkstra en la vida real?", "input": "", "output": "Google Maps lo usa para encontrar la ruta más rápida entre dos puntos. Calcula caminos más cortos como si fueran carreteras interconectadas por nodos."}
{"id": "557e613ec5", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve la búsqueda binaria?", "input": "", "output": "Amazon la utiliza cuando buscas un producto entre millones. La búsqueda binaria reduce el tiempo de búsqueda a la mitad en cada paso."}
{"id": "d35e9a677b", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de hashing?", "input": "", "output": "Facebook usa hashing para guardar tus contraseñas de forma segura. No se guarda tu contraseña real, sino una versión irreconocible."}
{"id": "9257e8871f", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve un árbol binario de búsqueda (bst)?", "input": "", "output": "LinkedIn usa estructuras tipo BST para buscar conexiones rápidamente. Ordena usuarios por nombre, ID u otros atributos."}
{"id": "17adb55745", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve un stack (pila)?", "input": "", "output": "Microsoft Word usa stacks para el botón de deshacer (CtrlZ). Cada acción se apila, y puedes deshacerlas en orden inverso."}
{"id": "ab20374727", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve un heap (montículo)?", "input": "", "output": "Netflix usa heaps para priorizar contenidos en cola, como mostrarte las recomendaciones más relevantes primero."}
{"id": "67b70dd72d", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de k-means?", "input": "", "output": "Spotify lo usa para agrupar canciones similares y crear playlists personalizadas según tus gustos."}
{"id": "41a82a315c", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirven los grafos en redes sociales?", "input": "", "output": "Instagram modela tus amigos y seguidores como grafos. Así puede sugerirte a quién seguir o con quién te relacionas más."}
{"id": "a9c53ed35e", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve un trie?", "input": "", "output": "Google lo usa para autocompletar tus búsquedas en tiempo real. Cada letra que escribes navega por el Trie."}
{"id": "67d13c0dcf", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de backtracking?", "input": "", "output": "Airbnb lo usa para encontrar combinaciones viables de filtros cuando buscas alojamiento. Prueba rutas y retrocede si algo no encaja."}
{"id": "0ea16d184e", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de floyd-warshall?", "input": "", "output": "las aerolíneas lo usan para calcular rutas mínimas entre todas las ciudades a la vez y ajustar conexiones. Optimiza tiempos y costos en redes densas."}
{"id": "555b44de61", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de prim?", "input": "", "output": "las compañías eléctricas lo usan para tender cableado minimizando el costo total sin dejar casas desconectadas. Construye un árbol de menor costo."}
{"id": "ba792c878a", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de kruskal?", "input": "", "output": "las empresas de internet lo aplican para diseñar redes de fibra baratas conectando ciudades con el costo mínimo. Ordena aristas y arma el MST."}
{"id": "c801a81e96", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo a* (a estrella)?", "input": "", "output": "los videojuegos lo usan para que los NPC encuentren el camino más corto sin atascarse. Combina costo recorrido heurística para moverse rápido."}
{"id": "a85ac0691f", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de bellman-ford?", "input": "", "output": "en telecomunicaciones se usa cuando hay enlaces con costos variables o negativos, detecta ciclos malos y aun así encuentra rutas más baratas."}
{"id": "9bac25f274", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve la programación dinámica (ejemplo knapsack)?", "input": "", "output": "en logística se usa para cargar camiones maximizando valor sin pasarse de peso. Divide en subproblemas y rellena tablas para decidir qué llevar."}
{"id": "27000eb459", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de union-find (dsu)?", "input": "", "output": "en redes sociales se usa para saber rápidamente si dos usuarios están conectados en la misma comunidad. Une conjuntos y comprueba conectividad en casi O(1)."}
{"id": "552ae49bb1", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de ordenamiento rápido (quicksort)?", "input": "", "output": "bases de datos y tiendas online lo usan para ordenar millones de registros rápido antes de mostrarlos. Parte y conquista con pivotes para ordenar en promedio O(n log n)."}
{"id": "b7d63056ee", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de ordenamiento por mezcla (mergesort)?", "input": "", "output": "cuando los datos no caben en RAM, Mergesort permite ordenar en disco divide, ordena trozos y luego mezcla de forma estable. Ideal para archivos enormes."}
{"id": "5232c3c066", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el método de monte carlo?", "input": "", "output": "los bancos lo usan para simular riesgos financieros generando miles de escenarios aleatorios y estimar pérdidas probables. Simulación estadísticas."}
{"id": "1505836920", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo pagerank?", "input": "", "output": "Google lo popularizó para ordenar páginas según cuántas otras las referencian. Es un ranking por importancia en el grafo de la web."}
{"id": "e1425faf50", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de kmp (knuth–morris–pratt)?", "input": "", "output": "editores de texto y buscadores lo usan para encontrar patrones en documentos sin reescanear todo. Reutiliza información de prefijos para buscar más rápido."}
{"id": "98d976d0f5", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de ventanas deslizantes?", "input": "", "output": "en streaming de datos se usa para calcular métricas en tiempo real (promedios, máximos) sobre los últimos N elementos sin recalcular todo."}
{"id": "ae013a4083", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de compresión huffman?", "input": "", "output": "formatos como ZIP o imágenes lo usan para comprimir asignando códigos cortos a símbolos frecuentes. Ahorra espacio sin perder información."}
{"id": "00318fe619", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve el algoritmo de detección de componentes fuertemente conexas (kosaraju/tarjan)?", "input": "", "output": "en análisis de dependencias de software se usa para detectar ciclos entre módulos. Encuentra subgrafos donde cada nodo alcanza a los demás."}
{"id": "e68c9fd19e", "mode": "socratico", "instruction": "Necesito ayuda con: ¿qué es un algoritmo?", "input": "", "output": "Imagina que vas a preparar un sándwich. Primero tomas el pan, luego agregas jamón, después queso, y finalmente cierras con otro pan. ¡Eso es un algoritmo! Una serie de pasos ordenados para lograr un objetivo. En programación, un algoritmo es simplemente la receta para resolver un problema."}
{"id": "401fbb6cd7", "mode": "socratico", "instruction": "Necesito ayuda con: ¿qué es una variable?", "input": "", "output": "Piensa en una variable como una cajita con una etiqueta. Puedes ponerle dentro una manzana, un número, un nombre ¡lo que necesites! Luego puedes abrirla, cambiar su contenido, o usar lo que tiene dentro. Es una forma de guardar información para usarla más adelante."}
{"id": "931e9c11eb", "mode": "socratico", "instruction": "Necesito ayuda con: explica el concepto de recursividad de forma sencilla", "input": "", "output": "La recursividad es como una muñeca rusa cuando la abres, hay otra igual adentro, y luego otra, y otra... hasta que llegas a la más pequeña que ya no se abre. En programación, una función recursiva se llama a sí misma, pero siempre debe haber una muñeca final que detiene todo. ¡Es como decir repítelo hasta que sea tan simple que ya no se pueda dividir más!"}
{"id": "833bd85d4c", "mode": "socratico", "instruction": "Necesito ayuda con: ¿qué es el factorial y cómo se calcula con recursividad?", "input": "¿Me puedes dar una explicación fácil?", "output": "Imagina que tienes que apilar platos el factorial de 4 (escrito 4!) es como decir 4 platos, debajo uno de 3, luego uno de 2, y al final uno de 1. Cada plato se apoya en el de abajo. Con recursividad, hacemos que la función se apile una y otra vez hasta llegar al 1. Así 4! 4 3 2 1. Cuando llegamos al 1, ¡dejamos de apilar!"}
{"id": "d693d96839", "mode": "socratico", "instruction": "Necesito ayuda con: ¿qué es fibonacci con recursividad?", "input": "", "output": "La secuencia de Fibonacci es como criar conejos. Empiezas con una pareja. Cada mes, esa pareja produce una nueva, y las nuevas también empezarán a producir después de un tiempo. Así, los conejos se multiplican como 1, 1, 2, 3, 5, 8... En recursividad, cada número se calcula sumando los dos anteriores. ¡Solo recuerda que empieza con 1 y 1!"}
{"id": "d4f1efc8d4", "mode": "bigtech", "instruction": "Necesito ayuda con: ¿para qué sirve un bucle en programación?", "input": "", "output": "Un bucle es como cuando saltas la cuerda 10 veces. En vez de decirle a alguien salta, salta, salta... diez veces, dices salta 10 veces. En programación, un bucle te permite repetir instrucciones sin tener que escribirlas una por una. ¡Es súper útil para no hacer trabajo repetitivo!"}
{"id": "bf3393ae4e", "mode": "socratico", "instruction": "Necesito ayuda con: ¿qué diferencia hay entre un bucle 'for' y uno 'while'?", "input": "", "output": "Piensa en un bucle for como cuando haces una lista de 5 ejercicios y haces cada uno una vez. Sabes cuántas veces vas a repetir algo. En cambio, un while es como lavar platos lavas mientras haya platos sucios. No sabes cuántos hay, solo repites mientras la condición sea cierta."}
{"id": "89739a9993", "mode": "socratico", "instruction": "Necesito ayuda con: ¿qué es un array?", "input": "", "output": "Un array es como un tren. Cada vagón (posición) puede llevar un objeto un número, una palabra, etc. Puedes saber qué hay en cada vagón con solo mirar su número. Así, si el tercer vagón tiene chocolate, solo dices muéstrame el vagón 3, y listo. ¡Muy útil para ordenar cosas!"}
{"id": "0b8828e4ab", "mode": "socratico", "instruction": "Necesito ayuda con: ¿qué pasa si olvido el caso base en una función recursiva?", "input": "", "output": "¡Uy! Es como meterte a un laberinto sin salida. Si una función recursiva no tiene un caso base (el punto donde se detiene), se va llamando a sí misma una y otra vez, sin fin, hasta que la computadora se cansa. El caso base es la puerta de salida, lo que le dice ¡Ya basta, hemos terminado!"}
{"id": "2144fac41c", "mode": "socratico", "instruction": "Necesito ayuda con: ¿cómo puedo imaginarme el flujo de un programa?", "input": "Me cuesta entender qué hace primero, qué hace después...", "output": "Imagina que eres un chef siguiendo una receta. Tu programa empieza en la primera línea (como el primer paso), y va bajando línea por línea, ejecutando cada instrucción. Si encuentra un si pasa esto, haz aquello, es como un paso condicional en la receta. Si hay un bucle, es como mezcla durante 5 minutos. Paso a paso, tu código cocina una solución deliciosa."}
{"id": "aff5e3b4e1", "mode": "socratico", "instruction": "Necesito ayuda con: explícame la diferencia entre un bucle for y un while.", "input": "", "output": "piensa en subir escaleras un for es como saber que subirás 10 escalones exactos (cuentas de 1 a 10). Un while es como subir hasta que te canses sigues mientras la condición sea verdadera. El for sabe cuántas vueltas; el while depende de una condición que cambia."}
{"id": "1b7601f8c3", "mode": "socratico", "instruction": "Necesito ayuda con: ¿qué es un diccionario en programación?", "input": "", "output": "imagina un cajón con fichas de palabra - definición. Buscas por la clave y obtienes el valor al instante. Un diccionario (mapa) guarda pares clave-valor y permite acceso rápido sin recorrer todo, como abrir directamente la ficha que necesitas."}
{"id": "4c49bb9b81", "mode": "socratico", "instruction": "Necesito ayuda con: no sé cómo romper el bucle while.", "input": "", "output": "Piensa un momento ¿qué condición estás usando para que el bucle siga? ¿Puedes imaginar un momento en que esa condición ya no sea verdadera? ¿Qué tendría que pasar para que eso ocurriera? Tal vez ahí esté la clave."}
{"id": "e342ba7286", "mode": "socratico", "instruction": "Necesito ayuda con: ¿cómo empiezo a pensar en recursividad?", "input": "", "output": "Imagina que estás contando hacia atrás desde 5. ¿Qué pasa cuando llegas a 1? Esa podría ser tu base. Ahora pregúntate ¿cómo resolverías el problema de tamaño N usando la solución del tamaño N-1? ¿Puedes visualizarlo?"}
{"id": "e62115fede", "mode": "socratico", "instruction": "Necesito ayuda con: mi código entra en un bucle infinito y no sé por qué.", "input": "", "output": "Una buena pista observa si dentro de tu bucle estás cambiando alguna de las variables que forman parte de la condición. ¿Esa condición se está acercando a ser falsa en algún momento? ¿O siempre se mantiene igual?"}
{"id": "f6e1c72e34", "mode": "socratico", "instruction": "Necesito ayuda con: no sé cómo comparar elementos en una lista.", "input": "", "output": "Imagina que estás buscando el objeto más pesado en una fila de mochilas. ¿Cómo lo harías a mano? ¿Tal vez comparas una a una con la más pesada hasta ahora? ¿Cómo trasladarías ese pensamiento a código?"}
{"id": "24878d9e71", "mode": "socratico", "instruction": "Necesito ayuda con: no entiendo qué hace mal mi función recursiva.", "input": "La función es para calcular el factorial.", "output": "¿Has probado pensar qué pasa si le das como entrada el número 1? ¿Y el 0? ¿Qué debería devolver en esos casos? ¿Estás seguro de que tu función tiene una condición clara para detenerse?"}
{"id": "5b72edad67", "mode": "socratico", "instruction": "Necesito ayuda con: ¿cómo empiezo a resolver este problema de contar palabras en una frase?", "input": "", "output": "¿Qué pasaría si escribieras la frase en una hoja de papel y pusieras una marca cada vez que ves un espacio? ¿Cuántas palabras contarías así? ¿Puedes replicar ese mismo enfoque en código?"}
{"id": "aef9c06975", "mode": "socratico", "instruction": "Necesito ayuda con: no se me ocurre cómo ordenar esta lista sin usar funciones predefinidas.", "input": "", "output": "Piensa en cómo ordenarías cartas en tu mano si las vas recibiendo una por una. ¿Buscarías la menor y la pondrías primero? ¿Cómo sabrías cuál es la menor entre todas? ¿Qué harías después?"}
{"id": "e23017897f", "mode": "socratico", "instruction": "Necesito ayuda con: no entiendo por qué no entra en el if.", "input": "", "output": "¿Has revisado qué valor exacto tiene la variable justo antes del if? ¿Qué esperas que tenga? ¿Coincide con la condición que escribiste? A veces, solo ver el valor real ya te da una gran pista."}
{"id": "cae14378d9", "mode": "socratico", "instruction": "Necesito ayuda con: ¿cómo se me ocurre una solución si no sé ni por dónde empezar?", "input": "", "output": "Imagina que el problema es una caja cerrada. ¿Puedes describir en palabras sencillas lo que se espera que ocurra? ¿Y si lo intentas con un ejemplo pequeño? ¿Qué harías paso a paso para resolverlo sin código? Ahí suele estar el algoritmo escondido."}
{"id": "715ec2cc11", "mode": "socratico", "instruction": "Necesito ayuda con: mi código funciona, pero es muy lento con listas grandes.", "input": "", "output": "Buena observación. ¿Cuántas veces se repite tu bucle si tienes 10 elementos? ¿Y si tienes 1,000? ¿Puedes pensar en una manera de evitar repeticiones innecesarias o de aprovechar algo ya calculado? ¡Tu intuición está cerca de mejorar tu algoritmo!"}
{"id": "b0749f257d", "mode": "socratico", "instruction": "Necesito ayuda con: no sé por qué mi lista queda vacía después del for.", "input": "", "output": "¿estás reasignando la lista dentro del for en vez de llenarla? ¿Agregas con append o la sustituyes? ¿Qué pasa si imprimes la lista dentro del bucle para ver en qué momento se pierde?"}
{"id": "d4416f91f7", "mode": "socratico", "instruction": "Necesito ayuda con: mi función recursiva explota la pila.", "input": "", "output": "¿tienes un caso base que siempre se alcance? ¿El argumento se acerca al caso base en cada llamada? ¿Podrías probar con un valor mínimo y ver si retorna sin llamar de nuevo?"}
{"id": "1afa428f00", "mode": "socratico", "instruction": "Necesito ayuda con: ¿cómo optimizar esta solución recursiva de fibonacci que es extremadamente lenta para n > 40?", "input": "def fibonacci(n): if n <= 1: return n return fibonacci(n - 1) + fibonacci(n - 2) # Para n=40 toma varios segundos print(fibonacci(40))", "output": "El problema es que esta solución tiene complejidad O(2n) porque recalcula los mismos valores múltiples veces. La solución es usar Memoization (programación dinámica top-down). Solución optimizada con memoization def fibonacci_memo(n, memoNone) if memo is None memo if n 1 return n if n not in memo memon fibonacci_memo(n - 1, memo) fibonacci_memo(n - 2, memo) return memon print(fibonacci_memo(40)) Respuesta instantánea Explicación de Memoization Almacenamos resultados ya calculados en un diccionario (memo). Antes de calcular fibonacci(n), verificamos si ya está en memo. Esto garantiza que cada valor se calcula solo una vez. Cambio drástico en complejidad - Original O(2n) tiempo, O(n) espacio (pila) - Optimizada O(n) tiempo, O(n) espacio - Para n40 de 2 mil millones de llamadas a solo 40 llamadas. - fibonacci(100) es ahora posible en milisegundos vs imposible antes."}
{"id": "eed3539993", "mode": "general", "instruction": "¿Qué pasó con los estudiantes del Tecnológico de Morelia?", "input": "", "output": "disculpa pero ese tema no está relacionado con algoritmos y programación, que es mi área de especialidad. ¿Tienes alguna pregunta sobre algoritmos, estructuras de datos o programación en Python que pueda ayudarte a resolver?"}
{"id": "73957ddd84", "mode": "general", "instruction": "¿Quién ganó el mundial de fútbol?", "input": "", "output": "esa pregunta no está relacionada con programación. Mi especialidad es ayudarte con algoritmos, estructuras de datos y código en Python. ¿Hay algo de programación en lo que pueda ayudarte?"}
{"id": "3ab9691081", "mode": "general", "instruction": "¿Cuál es la capital de Francia?", "input": "", "output": "esa pregunta es de geografía, no de programación. Estoy especializado en ayudarte con algoritmos, estructuras de datos y código. ¿Tienes alguna duda sobre programación?"}
{"id": "ccb68d07b2", "mode": "general", "instruction": "¿Cómo cocinar arroz?", "input": "", "output": "eso es cocina, no programación. Mi área es ayudarte con algoritmos y código en Python. ¿Quieres que te explique algún algoritmo o concepto de programación?"}
{"id": "e9c338bc9b", "mode": "general", "instruction": "¿Qué tiempo hace hoy?", "input": "", "output": "no tengo información sobre el clima. Mi especialidad es algoritmos y programación. ¿Puedo ayudarte con algún concepto de programación o algoritmos?"}
{"id": "339dc7ac36", "mode": "general", "instruction": "¿Quien es el maestro shifu?", "input": "", "output": "RREGRESA VALERIAAAAAAAAAA (de fondo suena como cuando no era cantante del bogueto)"}
