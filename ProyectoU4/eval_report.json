{
  "n": 40,
  "by_mode": {
    "bigtech": 8,
    "general": 27,
    "socratico": 5
  },
  "code_rate": 0.075,
  "avg_len_chars": 291.8,
  "avg_distinct2": 0.957260324740217,
  "avg_repetition": 0.14573330888592834,
  "rows": [
    {
      "id": "b10619f72d",
      "mode": "bigtech",
      "len_chars": 103,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.0,
      "generated": "en texto pirata buscan patrones sin repetir símbolos. Reutiliza información previa sobre coincidencias.",
      "reference": "editores de texto y buscadores lo usan para encontrar patrones en documentos sin reescanear todo. Reutiliza información de prefijos para buscar más rápido."
    },
    {
      "id": "a75c916bb6",
      "mode": "bigtech",
      "len_chars": 214,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.08571428571428574,
      "generated": "en exploración de mapas virtuales o de búsqueda de ruta te ayuda a decidir cuál camino seguir explorando primero, como si pidieras la mejor ruta entre casa y trabajo deteniéndote solo donde realmente sea necesario.",
      "reference": "los videojuegos lo usan para que los NPC encuentren el camino más corto sin atascarse. Combina costo recorrido heurística para moverse rápido."
    },
    {
      "id": "4b98252391",
      "mode": "bigtech",
      "len_chars": 228,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.07894736842105265,
      "generated": "Netflix usa stacks para gestionar episodios en tu lista de descarga. Cada vez que agregas un nuevo episodio a la pila, si ya estás intentando descargar otro, Netflix sabe que debes detenerse antes para no repetir nada duplicado.",
      "reference": "Microsoft Word usa stacks para el botón de deshacer (CtrlZ). Cada acción se apila, y puedes deshacerlas en orden inverso."
    },
    {
      "id": "e8972c7cfd",
      "mode": "bigtech",
      "len_chars": 154,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.07999999999999996,
      "generated": "LinkedIn utiliza hashing para almacenar contraseñas de forma segura. Si cambias la contraseña, se genera una nueva hash y se guarda, no la clave original.",
      "reference": "Facebook usa hashing para guardar tus contraseñas de forma segura. No se guarda tu contraseña real, sino una versión irreconocible."
    },
    {
      "id": "1505836920",
      "mode": "bigtech",
      "len_chars": 188,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.0,
      "generated": "en redes profesionales detecta la importancia de cada página según cuántas otras lo hacen apuntan. Google usa este para ordenar resultados relevancia inversamente proporcional a distancia.",
      "reference": "Google lo popularizó para ordenar páginas según cuántas otras las referencian. Es un ranking por importancia en el grafo de la web."
    },
    {
      "id": "41d48222ba",
      "mode": "bigtech",
      "len_chars": 145,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.04761904761904767,
      "generated": "los bancos lo usan para simular riesgos financieros generando miles de escenarios aleatorios. Simula pérdidas y calcula la probabilidad de fallo.",
      "reference": "los bancos lo usan para simular riesgos financieros generando miles de escenarios aleatorios y estimar pérdidas probables. Simulación estadísticas."
    },
    {
      "id": "9e131c827a",
      "mode": "bigtech",
      "len_chars": 139,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.0,
      "generated": "Google Maps lo usa para calcular el camino más rápido entre dos puntos, considerando carreteras, congestión y tiempo estimado de cada ruta.",
      "reference": "Google Maps lo usa para encontrar la ruta más rápida entre dos puntos. Calcula caminos más cortos como si fueran carreteras interconectadas por nodos."
    },
    {
      "id": "bd0a7310f9",
      "mode": "bigtech",
      "len_chars": 139,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.04166666666666663,
      "generated": "en análisis de dependencias de software se usa para encontrar ciclos entre módulos. Divide la gráfica y luego aplica DFS por fondo a punta.",
      "reference": "en análisis de dependencias de software se usa para detectar ciclos entre módulos. Encuentra subgrafos donde cada nodo alcanza a los demás."
    },
    {
      "id": "e458758041",
      "mode": "general",
      "len_chars": 133,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.16666666666666663,
      "generated": "en texto para buscar patrones en documentos enormes, precalcula información sobre coincidencias para evitar rebuscarse todo el texto.",
      "reference": "editores de texto y buscadores lo usan para encontrar patrones en documentos sin reescanear todo. Reutiliza información de prefijos para buscar más rápido."
    },
    {
      "id": "fc9810f05f",
      "mode": "general",
      "len_chars": 227,
      "has_code": false,
      "distinct2": 0.9215686274509803,
      "repetition": 0.1777777777777778,
      "generated": "Código Python equivalente matriz1 4 2 7 8 5 6 9 1 3 resultado for i in range(3) for j in range(3) resultarsi,jmatrizij El RANGE es como el FIN_PARAFIN del pseudocódigo. Luego se ejecuta una sola vez para obtener el valor final.",
      "reference": "Código Python equivalente matriz 1, 2, 3, 4, 5, 6, 7, 8, 9 Ejemplo de inicialización suma 0 for i in range(3) for j in range(3) suma suma matrizij print(suma) Diferencias sintácticas 1. Python usa range(3) que genera índices 0, 1, 2 (no 1, 2, 3 como el pseudocódigo). 2. La flecha de asignación - se convierte en. 3. Los bloques se definen por indentación, no por palabras clave FIN_PARA. 4. ESCRIBIR se convierte en print(). 5. Python accede a matrices con ij igual que el pseudocódigo, pero los índices comienzan en 0."
    },
    {
      "id": "e2d0f32f90",
      "mode": "general",
      "len_chars": 345,
      "has_code": false,
      "distinct2": 0.9848484848484849,
      "repetition": 0.054545454545454564,
      "generated": "muchos programas se ven rápidos o lentos porque manejan datos uno por uno. Tu código está haciendo cosas innecesarias para cada elemento. Una estrategia común es pensar en cómo hacerlo si pudieras trabajar simultáneamente todos los elementos. ¿Puedes imaginar una forma que procese 2, luego 4, 8... hasta llegar solo el último? ¡Es como escalar!",
      "reference": "Buena observación. ¿Cuántas veces se repite tu bucle si tienes 10 elementos? ¿Y si tienes 1,000? ¿Puedes pensar en una manera de evitar repeticiones innecesarias o de aprovechar algo ya calculado? ¡Tu intuición está cerca de mejorar tu algoritmo!"
    },
    {
      "id": "0f6ebc329c",
      "mode": "general",
      "len_chars": 252,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.11904761904761907,
      "generated": "El paradigma Pythonico es abrir y cerrar archivos en bloques. Así evitas errores de cierre accidental y mejoras eficiencia. Versión pythonica with open(datos.txt, r) as f contenido f.read() print(contenido) No se cierra nunca, el bloque se auto-cierne.",
      "reference": "Si tu programa falla antes de llegar a f. close(), el archivo queda abierto (fuga de recursos). Usa un Context Manager (with). Versión Pythonic python with open(datos. txt, r) as f contenido f. read() print(contenido) El archivo se cierra aquí automáticamente, pase lo que pase. ¿Por qué es mejor? Garantiza que los recursos se liberen correctamente incluso si ocurren excepciones dentro del bloque."
    },
    {
      "id": "b06fa74b8a",
      "mode": "general",
      "len_chars": 309,
      "has_code": false,
      "distinct2": 0.9833333333333333,
      "repetition": 0.13725490196078427,
      "generated": "En programación, un diccionario (también conocido como mapa o tabla asociativa) es una estructura de datos que permite almacenar pares clave-valor. Cada clave tiene una única asociación con un valor. Puedes acceder a los valores por sus claves rápidamente, lo que hace que sean ideales para mapeos uno-a-unos.",
      "reference": "imagina un cajón con fichas de palabra - definición. Buscas por la clave y obtienes el valor al instante. Un diccionario (mapa) guarda pares clave-valor y permite acceso rápido sin recorrer todo, como abrir directamente la ficha que necesitas."
    },
    {
      "id": "b7f69217bd",
      "mode": "general",
      "len_chars": 446,
      "has_code": false,
      "distinct2": 0.9207920792079208,
      "repetition": 0.22666666666666668,
      "generated": "Código Python equivalente suma 0 for i in range(1, 11) if i 2 0 suma i print(fsuma) Diferencias sintácticas 1. range(1, 11) genera números del 1 al 10 (no incluye el 11). 2. En Pseudocódigo, ELIF es UNIFORMLYDECLARED (declara en cada bloque), aquí usamos indentación para estructura condicional. 3. El segundo fin_si se convierte en una línea separada para mejorar lectura. 4. python tiene fstrings para formatear texto con fstring() o .format().",
      "reference": "Código Python equivalente suma 0 for i in range(1, 11) if i 2 0 suma i print(suma) Notas MOD es, el rango en Python termina en 10 con range(1, 11), y la indentación reemplaza los FIN_PARAFIN_SI."
    },
    {
      "id": "ac550d5671",
      "mode": "general",
      "len_chars": 604,
      "has_code": false,
      "distinct2": 0.926829268292683,
      "repetition": 0.26315789473684215,
      "generated": "Análisis Complejidad Temporal O(log n) - El bucle continúa mientras i n (i se duplica cada iteración). La condición i n implica que la cantidad de iteraciones no puede ser mayor que log₂(n). - Cada iteración incrementa solo por i, lo que reduce drásticamente el número de operaciones. Complejidad Espacial O(1) - Solo usa variables auxiliares constantes (result, i). No hay recirculación de datos en memoria. Justificación Este patrón de duplicar una variable a medida que avanza es comúnmente llamado Fatorial con decrecimiento (F₀, F₁, F₂... ). En esta implementación, cada Fk se calcula dependiendo de",
      "reference": "Análisis de complejidad Complejidad Temporal O(log n) Razonamiento - La variable i comienza en 1 y se duplica en cada iteración (i 2). - Secuencia de valores de i 1, 2, 4, 8, 16,..., hasta que i n - Esto es una progresión geométrica con razón 2. - Número de iteraciones k, donde 2k n, por tanto k log₂(n) Ejemplo - n 100 iteraciones 7 (27 128) - n 1000 iteraciones 10 (210 1024) Complejidad Espacial O(1) - Solo usa variables auxiliares constantes (result, i). Este patrón de duplicación (i 2) siempre indica complejidad logarítmica, similar a búsqueda binaria donde el espacio de búsqueda se divide (o multiplica) por 2."
    },
    {
      "id": "94a4b55637",
      "mode": "general",
      "len_chars": 245,
      "has_code": false,
      "distinct2": 0.9791666666666666,
      "repetition": 0.050000000000000044,
      "generated": "pathlib es más seguro y eficiente para abrir archivos en Python. with ruta. txt as archivo Open file using context manager archivo. read() Maneja el cierre automático without f.close() Reduce riesgos de errores no cerrar archivo después del uso.",
      "reference": "pathlib hace el código más declarativo y el context manager asegura cierre aunque falle algo. python from pathlib import Path path Path(data. txt) with path. open() as f data f. read() Menos fugas de recursos y paths manejables multiplataforma."
    },
    {
      "id": "4c0674c296",
      "mode": "general",
      "len_chars": 462,
      "has_code": false,
      "distinct2": 0.8173076923076923,
      "repetition": 0.35365853658536583,
      "generated": "Estrategia 1. Usar dos punteros uno izquierda (left) en 0 otro derecho (right) en len(s)-1 2. Mientras left right, intercambia caracteres sleft sright 3. mueve punteros hacia dentro left 1 right-1 4. Retornar cadena invertida return s0-rightleft-1 for char in zip(índice para iterar sobre cada par de caracteres left 1 right-1 while left right if left right - 1 char leftchar right else False left 1 right-1 print(fresultado invierte s0-rightleft-1) Output helle",
      "reference": "Estrategia 1. Usar dos punteros uno al inicio, otro al final 2. Intercambiar caracteres y mover punteros hacia el centro 3. Como strings son inmutables en Python, convertir a lista 4. Complejidad O(n) tiempo, O(n) espacio Solución con dos punteros def reverse_string(s) Convertir a lista (strings son inmutables) chars list(s) left 0 right len(chars) - 1 while left right Intercambiar caracteres charsleft, charsright charsright, charsleft left 1 right - 1 return. join(chars) Solución iterativa simple def reverse_string_iterative(s) result for i in range(len(s) - 1, -1, -1) result si return result Solución con lista y append (más eficiente que concatenación) def reverse_string_list(s) result for i in range(len(s) - 1, -1, -1) result. append(si) return. join(result) Solución recursiva def reverse_string_recursive(s) if len(s) 1 return s return reverse_string_recursive(s1) s0 Pruebas print(reverse_string(hello)) olleh print(reverse_string(Python)) nohtyP print(reverse_string(a)) a print(reverse_string())"
    },
    {
      "id": "866fce81ae",
      "mode": "general",
      "len_chars": 201,
      "has_code": false,
      "distinct2": 0.9302325581395349,
      "repetition": 0.1515151515151515,
      "generated": "Usaremos un stack para saber dónde comienza cada paréntesis. Al llegar a uno cerrar, debe haber un correspondiente abierto antes. Complejidad O(n) tiempo, O(n) espacio (máximo n elementos en el stack).",
      "reference": "Estrategia 1. Usar una pila (stack) para almacenar paréntesis de apertura 2. Al encontrar cierre, verificar que coincida con el último apertura 3. Al final, la pila debe estar vacía 4. Complejidad O(n) tiempo, O(n) espacio Solución con pila def is_balanced(expression) stack Mapeo de cierres a aperturas matching ) (,, for char in expression if char in ( Paréntesis de apertura agregar a pila stack. append(char) elif char in ) Paréntesis de cierre verificar coincidencia if not stack return False No hay apertura correspondiente if stack-1! matchingchar return False No coincide stack. pop() La pila debe estar vacía al final return len(stack) 0 Versión más detallada con mensajes def is_balanced_verbose(expression) stack matching ) (,, for i, char in enumerate(expression) if char in ( stack. append((char, i)) elif char in ) if not stack print(fError char en posición i no tiene apertura) return False last_open, pos stack-1 if last_open! matchingchar print(fError char en i no coincide con last_open en pos) return False stack. pop() if stack print(fError len(stack) paréntesis sin cerrar) return False return True Pruebas print(is_balanced(())) True print(is_balanced(())) False print(is_balanced(((())))) True print(is_balanced((())) False print(is_balanced()()) False print(is_balanced()) True"
    },
    {
      "id": "755bf0949b",
      "mode": "general",
      "len_chars": 569,
      "has_code": true,
      "distinct2": 0.8547008547008547,
      "repetition": 0.348314606741573,
      "generated": "Código Python equivalente python def potencia(base int, exponente int) resultado 1 for i in range(1, exponente 1) resultado resultado base return resultado Diferencias sintácticas - En Pseudocódigo usa indentación (con espacios), aquí usamos bloques anidados en Python. - Para iterar desde 1 hasta el exponente incluido se usa range(1, exponente 1). - El HACER se convierte en for i in range(len(lista)), o simplemente con una variable auxiliar como aquí. - Python tiene argumentos por defecto, así no necesitas exponer el valor del segundo parámetro en potencia(2, 3).",
      "reference": "Código Python equivalente def potencia(base, exponente) resultado 1 for i in range(1, exponente 1) resultado resultado base return resultado Ejemplo de uso print(potencia(2, 3)) Output 8 Diferencias sintácticas 1. FUNCIÓN se convierte en def nombre_funcion(parámetros). 2. Python no requiere declaración explícita de tipos en los parámetros. 3. RETORNAR se convierte en return. 4. FIN_FUNCIÓN no existe, el fin de la función se marca por cambio de indentación. 5. Python tiene operador para potencias base exponente sería más directo. 6. range(1, exponente 1) itera de 1 a exponente inclusive."
    },
    {
      "id": "a177a6f6e6",
      "mode": "general",
      "len_chars": 495,
      "has_code": true,
      "distinct2": 0.8691588785046729,
      "repetition": 0.388235294117647,
      "generated": "Funcional, pero tiene problemas. El bloqueamiento en el while se expresa claramente con las condiciones left right. Pero el cálculo del índice mid puede generar índices fuera de límites si len(arr) 1000. En Python, los arreglos siempre tienen longitud exacta, por lo que left mid o right mid generan índices fuera de rango. Mejora python def binary_search(arr, target) left, right 0, len(arr)-1 while left right if arrmid(target) return mid if arrmid(mid) target return mid right mid-1 return -1",
      "reference": "La implementación es correcta y representa la versión iterativa estándar de búsqueda binaria. Análisis de complejidad Complejidad Temporal O(log n) - En cada iteración, el espacio de búsqueda se reduce a la mitad. - Si tenemos n elementos, necesitamos como máximo log₂(n) comparaciones. - Ejemplo para 1024 elementos, máximo 10 iteraciones (2¹⁰ 1024). Complejidad Espacial O(1) - Solo usa variables auxiliares (left, right, mid). - No hay llamadas recursivas ni estructuras adicionales. Precondición importante El arreglo debe estar ordenado. Si no lo está, la búsqueda binaria no garantiza encontrar el elemento incluso si existe."
    },
    {
      "id": "eed3539993",
      "mode": "general",
      "len_chars": 408,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.21666666666666667,
      "generated": "Los estudiantes del Tecnológico de Monterrey (TecMilenio) se rebelaron en 2016, convirtiéndose en una de las movilizaciones más grandes de México en ese momento. Se quejaban de altas tasas de impuestos, estafas y falta de oportunidades laborales. El gobierno les propuso reformar sus estudios para adaptarse a las necesidades laborales actuales. ¡Esos estudiantes cambiaron el curso de la educación mexicana!",
      "reference": "disculpa pero ese tema no está relacionado con algoritmos y programación, que es mi área de especialidad. ¿Tienes alguna pregunta sobre algoritmos, estructuras de datos o programación en Python que pueda ayudarte a resolver?"
    },
    {
      "id": "668dc852c8",
      "mode": "general",
      "len_chars": 433,
      "has_code": false,
      "distinct2": 0.9659090909090909,
      "repetition": 0.19999999999999996,
      "generated": "Imagina que tienes a una tortuga que debe subir escaleras. Si las escaleras son simples (uno por vez), es sencillo decirle a la tortuga ir 1 escalera, luego 2, 3, etc. Pero si cada escalón tiene escalones adyacentes, ahora la cosa se complica. La recursividad es como decir a la tortuga que suba esta escalonada, después esa, y así sucesivamente hasta llegar donde debe estar. Es simplemente hacer lo mismo pero con algo más pequeño.",
      "reference": "La recursividad es como una muñeca rusa cuando la abres, hay otra igual adentro, y luego otra, y otra... hasta que llegas a la más pequeña que ya no se abre. En programación, una función recursiva se llama a sí misma, pero siempre debe haber una muñeca final que detiene todo. ¡Es como decir repítelo hasta que sea tan simple que ya no se pueda dividir más!"
    },
    {
      "id": "d41c4409b3",
      "mode": "general",
      "len_chars": 495,
      "has_code": true,
      "distinct2": 0.7857142857142857,
      "repetition": 0.3695652173913043,
      "generated": "La solución recursiva tiene complejidad O(2(nm)), porque reescribe los mismos subproblemas múltiples veces. Usaremos Programación Dinámica con Tabulation Solución óptima def lcs_dp(X, Y) Crear tabla para almacenar resultados dp 0 for i in range(len(X) 1) for j in range(len(Y) 1) Complejidad Temporal O(mn) espacio Auxiliar O(mxny) def lcs_top_down(X, Y, m, n) Recurso Memoization table if m 0 or n 0 return 0 if table m,n not None table m,n lcs_top_down(X, Y, m - 1, n - 1) Return length of LCS",
      "reference": "La solución recursiva tiene complejidad exponencial O(2(mn)) por recalcular subproblemas. Usaremos Programación Dinámica con Tabulation. Solución optimizada con Tabulation def lcs_dp(X, Y) m len(X) n len(Y) Crear tabla dp donde dpij LCS de X0.. i-1 y Y0.. j-1 dp 0 for _ in range(n 1) for _ in range(m 1) Llenar tabla bottom-up for i in range(1, m 1) for j in range(1, n 1) if Xi - 1 Yj - 1 Caracteres coinciden agregar 1 al LCS anterior dpij 1 dpi - 1j - 1 else No coinciden tomar el máximo de excluir uno u otro dpij max(dpi - 1j, dpij - 1) return dpmn Para obtener la secuencia real def lcs_with_string(X, Y) m, n len(X), len(Y) dp 0 (n 1) for _ in range(m 1) Llenar tabla for i in range(1, m 1) for j in range(1, n 1) if Xi - 1 Yj - 1 dpij 1 dpi - 1j - 1 else dpij max(dpi - 1j, dpij - 1) Reconstruir la secuencia lcs i, j m, n while i 0 and j 0 if Xi - 1 Yj - 1 lcs. append(Xi - 1) i - 1 j - 1 elif dpi - 1j dpij - 1 i - 1 else j - 1 return. join(reversed(lcs)) X AGGTAB Y GXTXAYB print(fLongitud lcs_dp(X, Y)) Output 4 print(fLCS lcs_with_string(X, Y)) Output GTAB Mejora de complejidad - Recursiva O(2(mn)) - inviable para strings 20 caracteres - DP O(m n) tiempo, O(m n) espacio - Para strings de 1000 caracteres de imposible a milisegundos"
    },
    {
      "id": "d915a49d56",
      "mode": "general",
      "len_chars": 467,
      "has_code": false,
      "distinct2": 0.9537037037037037,
      "repetition": 0.31034482758620685,
      "generated": "El problema aquí es que revisa cada elemento con todos los demás, lo que hace que sea O(n²). La idea de duplicar (append) un elemento dentro del mismo bucle hace que se repita para cada combinación de dos elementos. Mejora Usa set() para evitar duplicidades y evita el append redundante . El Set solo contiene elementos únicos. Versión optimizada python duplicates set(x for i, x in enumerate(arr) for j in range(i) if j len(arr) and x arr[j] and x not in duplicates)",
      "reference": "Problema identificado Complejidad cuadrática con búsqueda lineal adicional. Complejidad actual - Temporal O(n²) debido al bucle anidado, más O(n) por la operación in en cada iteración, resultando en O(n³) en el peor caso. - Espacial O(n) para almacenar duplicados. Mejora propuesta usando un conjunto def find_duplicates(arr) seen set() duplicates set() for num in arr if num in seen duplicates. add(num) else seen. add(num) return list(duplicates) Complejidad mejorada - Temporal O(n) - un solo recorrido con operaciones de conjunto O(1). - Espacial O(n) para los dos conjuntos. La mejora reduce drásticamente el tiempo de O(n³) a O(n), sacrificando mínimamente espacio adicional."
    },
    {
      "id": "1c917b6daf",
      "mode": "general",
      "len_chars": 548,
      "has_code": false,
      "distinct2": 0.911504424778761,
      "repetition": 0.2934782608695652,
      "generated": "Análisis de complejidad Temporal O(1) (constante) La variable result se inicializa una vez, y luego se itera solo mientras i sea menor que n. El número de iteraciones depende de n, pero no crece exponencialmente con respectiva a n. Espacial O(log n) (polinomial) Usa dos variables adicionales, i y result, lo que hace que el espacio de la función proporcione información logarítmica sobre el tamaño de entrada. Complejidad total O(log n) operaciones en tiempo, O(1) en espacio. Esto es mucho más eficiente que métodos recursivos o bucles infinitos.",
      "reference": "Análisis de complejidad Complejidad Temporal O(log n) Razonamiento - La variable i comienza en 1 y se duplica en cada iteración (i 2). - Secuencia de valores de i 1, 2, 4, 8, 16,..., hasta que i n - Esto es una progresión geométrica con razón 2. - Número de iteraciones k, donde 2k n, por tanto k log₂(n) Ejemplo - n 100 iteraciones 7 (27 128) - n 1000 iteraciones 10 (210 1024) Complejidad Espacial O(1) - Solo usa variables auxiliares constantes (result, i). Este patrón de duplicación (i 2) siempre indica complejidad logarítmica, similar a búsqueda binaria donde el espacio de búsqueda se divide (o multiplica) por 2."
    },
    {
      "id": "5d8f926a78",
      "mode": "general",
      "len_chars": 191,
      "has_code": false,
      "distinct2": 0.8888888888888888,
      "repetition": 0.12903225806451613,
      "generated": "Lista de prioridad (heap) O((VE) logV) - Topologías grandes pueden ser lenta. Implementación ingenua (enlazado simple) O(VE) - Cada nodo se examina una vez, pero cada arista se itera V veces.",
      "reference": "con lista de prioridad (heap) Dijkstra es O((VE) log V); con implementación ingenua buscando el mínimo en O(V) cada vez, termina en O(V2 E). Para grafos densos V2 y para esparsos el heap es claramente superior."
    },
    {
      "id": "e52840d4b2",
      "mode": "general",
      "len_chars": 255,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.15909090909090906,
      "generated": "un algoritmo es como una receta para hacer algo, ordenadamente. Cода que se repite siempre para llegar a la soluciòn. Ejemplo de algoritmo para calcular el área de un círculo pi r2. Complejidad O(n) cuando la longitud del arreglo se duplica, tiempo igual.",
      "reference": "Imagina que vas a preparar un sándwich. Primero tomas el pan, luego agregas jamón, después queso, y finalmente cierras con otro pan. ¡Eso es un algoritmo! Una serie de pasos ordenados para lograr un objetivo. En programación, un algoritmo es simplemente la receta para resolver un problema."
    },
    {
      "id": "43cf645a43",
      "mode": "general",
      "len_chars": 144,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.04347826086956519,
      "generated": "Amazon lo usa para mostrarte tus productos más vendidos en el lado derecho, es una forma de presentar información repetitiva de manera elegante.",
      "reference": "Un bucle es como cuando saltas la cuerda 10 veces. En vez de decirle a alguien salta, salta, salta... diez veces, dices salta 10 veces. En programación, un bucle te permite repetir instrucciones sin tener que escribirlas una por una. ¡Es súper útil para no hacer trabajo repetitivo!"
    },
    {
      "id": "acc27989a9",
      "mode": "general",
      "len_chars": 135,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.0,
      "generated": "Google lo usa para construir sus grafos instantáneamente. Cada vez que buscas a alguien, primero muestra todos los caminos más baratos.",
      "reference": "las compañías eléctricas lo usan para tender cableado minimizando el costo total sin dejar casas desconectadas. Construye un árbol de menor costo."
    },
    {
      "id": "07ea6941b9",
      "mode": "general",
      "len_chars": 312,
      "has_code": false,
      "distinct2": 0.918918918918919,
      "repetition": 0.31746031746031744,
      "generated": "Tu código es óptimo si el valor se encuentra entre los extremos de la lista (0-9999). Si el valor puede ser menor que 0 o mayor que 9999, debe realizar N busquedas adicionales fuera del rango, donde N es la longitud de la lista. Esto hace que tu método sea O(N) en contraste con el buscador típico de lista O(1).",
      "reference": "El problema aquí es la elección de la estructura de datos. Una búsqueda in sobre una Lista es O(n) (tiene que recorrerla). Si vas a hacer muchas búsquedas sobre estos datos estáticos, deberías usar un Diccionario o un Set. Mejora python datos_set set(datos) Convertir una vez La búsqueda ahora es O(1) (instantánea) return val in datos_set"
    },
    {
      "id": "37f0c9da5f",
      "mode": "general",
      "len_chars": 379,
      "has_code": false,
      "distinct2": 0.9302325581395349,
      "repetition": 0.15873015873015872,
      "generated": "Tu código elimina duplicados en O(N^2), porque el append() crea una nueva lista cada vez. Esto causa recorridos adicionales. La forma correcta es usar sets (clave para no tener duplicados). Versión Pythonica python unicos set(n for n in numeros) ¿Por qué es mejor? - Complejidad O(N) tiempo, O(N) espacio - No crea nuevas listas, simplemente maneja elementos como valores únicos.",
      "reference": "Tu lógica es impecable para mantener el orden, pero ineficiente en términos de complejidad temporal. La operación if n not in unicos recorre la lista unicos cada vez. Esto convierte tu algoritmo en O(N²). Si el orden no importa, usa un Set (Conjunto), que elimina duplicados instantáneamente gracias a su estructura hash python return list(set(numeros)) Si necesitas mantener el orden, tu enfoque es aceptable, pero ten en cuenta el coste de rendimiento en listas grandes."
    },
    {
      "id": "d210ed1889",
      "mode": "general",
      "len_chars": 274,
      "has_code": false,
      "distinct2": 0.9423076923076923,
      "repetition": 0.11111111111111116,
      "generated": "Para encontrar el camino más corto entre dos nodos en un grafo no dirigido o con aristas pesadas, usa BFS (Breadth-First Search). La búsqueda se realiza desde un nodo inicial, expandiéndose hacia abajo por nivel, lo que garantiza encontrarte rápidamente el camino más corto.",
      "reference": "Análisis de DFS (Depth-First Search) Complejidad Temporal O(V E) - Similar a BFS, visita cada vértice y arista una vez. Complejidad Espacial O(V) - visited O(V) - Pila de recursión O(V) en el peor caso (grafo lineal) Comparación BFS vs DFS BFS - Usa cola (FIFO) - Explora por niveles - Garantiza camino más corto en grafos no ponderados - Mejor para encontrar distancias mínimas DFS - Usa pila (recursión o explícita) - Explora en profundidad primero - NO garantiza camino más corto - Mejor para detección de ciclos, ordenamiento topológico, componentes conectados Respuesta Para encontrar el camino más corto en un grafo no ponderado, SIEMPRE usa BFS. BFS explora todos los nodos a distancia k antes de explorar nodos a distancia k1, garantizando el camino mínimo."
    },
    {
      "id": "f356b970da",
      "mode": "general",
      "len_chars": 310,
      "has_code": false,
      "distinct2": 0.9818181818181818,
      "repetition": 0.1428571428571429,
      "generated": "Un diccionario (también conocido como map o hash table) es como una caja registradora personalizada donde cada artículo tiene un número único asociado. En tu programa, cada llave tiene un valor, y puedes buscar rápido si algo está allí sin abrir nada. Es increíblemente rápido para encontrar cosas específicas.",
      "reference": "imagina un cajón con fichas de palabra - definición. Buscas por la clave y obtienes el valor al instante. Un diccionario (mapa) guarda pares clave-valor y permite acceso rápido sin recorrer todo, como abrir directamente la ficha que necesitas."
    },
    {
      "id": "5294d37c25",
      "mode": "general",
      "len_chars": 182,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.0,
      "generated": "Aprende Python dictionary comprehension. Versión pythonic mi_dict zip(keys, values) ¿Por qué es mejor? No reescribes el mismo código para agregar valores, solo cambia los argumentos.",
      "reference": "Puedes combinar el constructor dict() con zip() para hacer esto en una sola línea. Versión Pythonic python mi_dict dict(zip(keys, values)) ¿Por qué es mejor? Es extremadamente rápido y directo. zip genera pares (tuplas) y dict sabe exactamente cómo convertir una secuencia de pares clave-valor en un diccionario."
    },
    {
      "id": "892e9b3440",
      "mode": "general",
      "len_chars": 233,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.025000000000000022,
      "generated": "Evita nested ifs cuando sea posible usar una simple condición en lugar de un if anidado. Esto reduce la complejidad lógica, hace el código más legible y mejora su escalabilidad. Versión limpia python status Adulto if 20 18 else Menor",
      "reference": "Para asignaciones simples condicionales, usa el Operador Ternario de Python. Versión Pythonic python status Adulto if edad 18 else Menor ¿Por qué es mejor? Mantiene la asignación en una sola línea lógica, facilitando la lectura cuando la lógica no es compleja."
    },
    {
      "id": "a997ad90a1",
      "mode": "socratico",
      "len_chars": 167,
      "has_code": false,
      "distinct2": 0.9722222222222222,
      "repetition": 0.0,
      "generated": "¿Estás reemplazando tu lista con algo nueva dentro del for? ¿Has visto una línea como list() en algún lugar? ¿Qué pasa si el contenido se pierde mientras vas iterando?",
      "reference": "¿estás reasignando la lista dentro del for en vez de llenarla? ¿Agregas con append o la sustituyes? ¿Qué pasa si imprimes la lista dentro del bucle para ver en qué momento se pierde?"
    },
    {
      "id": "d693d96839",
      "mode": "socratico",
      "len_chars": 356,
      "has_code": false,
      "distinct2": 0.9120879120879121,
      "repetition": 0.2727272727272727,
      "generated": "Imagina que tienes dos gallinas. Primero produce una paja, luego las dos gallinas entran en arrugas. Cada gallina nueva genera una paja por cada una ya existente. Así, la cantidad de paja sigue el patrón 0, 1, 2, 3, 5... donde cada número después es la suma de los dos anteriores. Con recursiva, hacemos que fib(n) sea fib(n-1) + fib(n-2), ¡sin detenernos!",
      "reference": "La secuencia de Fibonacci es como criar conejos. Empiezas con una pareja. Cada mes, esa pareja produce una nueva, y las nuevas también empezarán a producir después de un tiempo. Así, los conejos se multiplican como 1, 1, 2, 3, 5, 8... En recursividad, cada número se calcula sumando los dos anteriores. ¡Solo recuerda que empieza con 1 y 1!"
    },
    {
      "id": "4c49bb9b81",
      "mode": "socratico",
      "len_chars": 195,
      "has_code": false,
      "distinct2": 1.0,
      "repetition": 0.033333333333333326,
      "generated": "Piensa en una condición clave que siempre sea falsa. ¿Cuál sería tu condición inicial perfectamente imposible de verificar? ¿Qué harías si ya estuvieras dentro del bucle exactamente como se debe?",
      "reference": "Piensa un momento ¿qué condición estás usando para que el bucle siga? ¿Puedes imaginar un momento en que esa condición ya no sea verdadera? ¿Qué tendría que pasar para que eso ocurriera? Tal vez ahí esté la clave."
    },
    {
      "id": "e342ba7286",
      "mode": "socratico",
      "len_chars": 342,
      "has_code": false,
      "distinct2": 0.96,
      "repetition": 0.19672131147540983,
      "generated": "Imagina que estás repitiendo una tarea. ¿Puedes hacerla dos veces, o tres veces? ¿Qué pasaría si la hacieras mil veces? ¿Y si fuera mil millones de veces? En recursión, lo que haces es dividir tu problema en partes iguales y luego resolver cada parte uno por uno. Si llegas al punto donde ya sabes qué hacer (un caso base), ¡puedes detenerte!",
      "reference": "Imagina que estás contando hacia atrás desde 5. ¿Qué pasa cuando llegas a 1? Esa podría ser tu base. Ahora pregúntate ¿cómo resolverías el problema de tamaño N usando la solución del tamaño N-1? ¿Puedes visualizarlo?"
    },
    {
      "id": "86a78d9599",
      "mode": "socratico",
      "len_chars": 248,
      "has_code": false,
      "distinct2": 0.9791666666666666,
      "repetition": 0.07894736842105265,
      "generated": "Piensa en que condición estás evaluando dentro del while. ¿Puedes pensar qué harías si esa condición ya no se cumple? ¿Qué cambió hace poco tiempo? ¿Podrías haberlo logrado entonces? ¡Sigue pensándolo! ¿Por qué es importante saber cuando detenerse?",
      "reference": "Piensa un momento ¿qué condición estás usando para que el bucle siga? ¿Puedes imaginar un momento en que esa condición ya no sea verdadera? ¿Qué tendría que pasar para que eso ocurriera? Tal vez ahí esté la clave."
    }
  ]
}